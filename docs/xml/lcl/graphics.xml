<?xml version="1.0"?>
<fpdoc-descriptions>
  <package name="lcl">
    <!--
  ====================================================================
    Graphics
  ====================================================================
-->
    <module name="Graphics">
      <short>Unit contains definitions for many fundamental classes and types used in graphic applications</short>
      <descr/>
      <!-- unresolved type reference Visibility: default -->
      <element name="SysUtils">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="Classes">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="Contnrs">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="FPCAdds">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="FPImage">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="FPReadPNG">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="FPWritePNG">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="FPReadBMP">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="FPWriteBMP">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="IntfGraphics">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="AvgLvlTree">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLStrConsts">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLType">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLProc">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LMessages">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLIntf">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LResources">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLResCache">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="GraphType">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="GraphMath">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="InterfaceBase">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- pointer type Visibility: default -->
      <element name="PColor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TColor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TFontPitch">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFontPitch.fpDefault">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFontPitch.fpVariable">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFontPitch.fpFixed">
        <short/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TFontName">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TFontDataName">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TFontStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFontStyle.fsBold">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFontStyle.fsItalic">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFontStyle.fsStrikeOut">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFontStyle.fsUnderline">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TFontStyles">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TFontStylesbase">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- range type Visibility: default -->
      <element name="TFontCharSet">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TFontQuality">
        <short>Output font quality, such as antialiasing</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFontQuality.fqDefault">
        <short>Default font quality</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFontQuality.fqDraft">
        <short>Prefer other font features (size, style) against output quality</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFontQuality.fqProof">
        <short>Prefer output quality against other font features (size, style)</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFontQuality.fqNonAntialiased">
        <short>Disable font antialiasing</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFontQuality.fqAntialiased">
        <short>Use font antialiasing</short>
      </element>
      <!-- record type Visibility: default -->
      <element name="TFontData">
        <short>A <b>record</b> holding <var>Data</var> about the current <var>Font</var>
        </short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TFontData.Handle">
        <short>The Operating System <var>Handle</var> for the current <var>Font</var>
        </short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TFontData.Height">
        <short>The <var>Height</var> (in pixels) if the current <var>Font</var>
        </short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TFontData.Pitch">
        <short>The <var>Pitch</var> (in points) of the current<var>Font</var>
        </short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TFontData.Style">
        <short>The <var>Style</var> of the <var>Font</var>
        </short>
        <descr>Bold, Italic, Strikeout or Underlined</descr>
      </element>
      <!-- variable Visibility: default -->
      <element name="TFontData.CharSet">
        <short>The <var>Character Set</var> of the current <var>Font</var> (expresed as an integer)</short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TFontData.Quality">
        <short>Output <var>Quality</var> of the current <var>Font</var>, such as antialiasing</short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TFontData.Name">
        <short>The <var>Name</var> (as a string) of the current <var>Font</var>
        </short>
      </element>
      <!-- constant Visibility: default -->
      <element name="DefFontData">
        <short>
          <var>Default Data</var>  for any new 
          
          
          
          <var>Font</var>
        </short>
        <descr>
          <p>New <var>TFont</var> instances are initialized with the values in this structure.</p>
          <p>About font default values: The default font is chosen by the interfaces depending on the context. </p>
          <p>For example, there can be a different default font for a button and a groupbox.</p>
        </descr>
        <seealso>
          <link id="TFontData"/>
        </seealso>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TTextLayout">
        <short>How the <var>Text</var>  is to be laid out in the Text Rectangle</short>
        <descr>At the Bottom, Centre or Top of the available window or box</descr>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TTextLayout.tlTop">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TTextLayout.tlCenter">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TTextLayout.tlBottom">
        <short/>
      </element>
      <!-- record type Visibility: default -->
      <element name="TTextStyle">
        <short>The <var>Style</var> of the <var>Text</var> to be drawn in a rectangle</short>
        <descr>
          <p>The <var>Style</var> of the <var>Text</var> to be drawn in a rectangle</p>
          <ul>
            <li>Alignment :  TextRect Only: horizontal alignment</li>
            <li>Layout    : TextRect Only: vertical alignment</li>
            <li>SingleLine: boolean;    If WordBreak is false then process #13, #10 as standard chars and perform no Line breaking.</li>
            <li>Clipping  : boolean;    TextRect Only: Clip Text to passed Rectangle</li>
            <li>ExpandTabs: boolean;    currently ignored</li>
            <li>ShowPrefix: boolean;    TextRect Only: Process first single ampersand per line as an underscore and draw double ampersand as a single ampersand</li>
            <li>Wordbreak : boolean;    TextRect Only: If line of text is too long to fit between left and right boundaries,   try to break into multiple lines between words</li>
            <li>Opaque    : boolean;    TextRect: Fills background with current Brush</li>
            <li>Opaque    :             TextOut : Fills background with current foreground color</li>
            <li>SystemFont: Boolean;    Use the system font instead of Canvas Font</li>
            <li>RightToLeft: Boolean;   For RightToLeft text reading (Text Direction)</li>
          </ul>
        </descr>
      </element>
      <!-- variable Visibility: default -->
      <element name="TTextStyle.Alignment">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TTextStyle.Layout">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TTextStyle.SingleLine">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TTextStyle.Clipping">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TTextStyle.ExpandTabs">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TTextStyle.ShowPrefix">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TTextStyle.Wordbreak">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TTextStyle.Opaque">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TTextStyle.SystemFont">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TPenStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenStyle.psSolid">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenStyle.psDash">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenStyle.psDot">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenStyle.psDashDot">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenStyle.psDashDotDot">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenStyle.psClear">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenStyle.psInsideframe">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TPenMode">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenMode.pmBlack">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenMode.pmWhite">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenMode.pmNop">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenMode.pmNot">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenMode.pmCopy">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenMode.pmNotCopy">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenMode.pmMergePenNot">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenMode.pmMaskPenNot">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenMode.pmMergeNotPen">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenMode.pmMaskNotPen">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenMode.pmMerge">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenMode.pmNotMerge">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenMode.pmMask">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenMode.pmNotMask">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenMode.pmXor">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPenMode.pmNotXor">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TBrushStyle">
        <short>Style of <var>Brush</var> to be used</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TBrushStyle.bsSolid">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TBrushStyle.bsClear">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TBrushStyle.bsHorizontal">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TBrushStyle.bsVertical">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TBrushStyle.bsFDiagonal">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TBrushStyle.bsBDiagonal">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TBrushStyle.bsCross">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TBrushStyle.bsDiagCross">
        <short/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TFillStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TFillMode">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFillMode.fmAlternate">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFillMode.fmWinding">
        <short/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TCopymode">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TCanvasStates">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TCanvasStates.csHandleValid">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TCanvasStates.csFontValid">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TCanvasStates.csPenvalid">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TCanvasStates.csBrushValid">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TCanvasStates.csRegionValid">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TCanvasState">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TCanvasOrientation">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TCanvasOrientation.csLefttoRight">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TCanvasOrientation.coRighttoLeft">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TProgressStage">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TProgressStage.psStarting">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TProgressStage.psRunning">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TProgressStage.psEnding">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TProgressEvent">
        <short>TProgressEvent - for monitoring the progress of a drawing process</short>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TProgressEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TProgressEvent.Stage">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TProgressEvent.PercentDone">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TProgressEvent.RedrawNow">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TProgressEvent.R">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TProgressEvent.Msg">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TProgressEvent.DoContinue">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TPixelFormat">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPixelFormat.pfDevice">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPixelFormat.pf1bit">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPixelFormat.pf4bit">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPixelFormat.pf8bit">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPixelFormat.pf15bit">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPixelFormat.pf16bit">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPixelFormat.pf24bit">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPixelFormat.pf32bit">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TPixelFormat.pfCustom">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TTransparentMode">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TTransparentMode.tmAuto">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TTransparentMode.tmFixed">
        <short/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clBlack">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clMaroon">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clGreen">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clOlive">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clNavy">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clPurple">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clTeal">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clGray">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clSilver">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clRed">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clLime">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clYellow">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clBlue">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clFuchsia">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clAqua">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clLtGray">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDkGray">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clWhite">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clCream">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clNone">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDefault">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clScrollBar">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clBackground">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clActiveCaption">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clInactiveCaption">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clMenu">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clWindow">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clWindowFrame">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clMenuText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clWindowText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clCaptionText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clActiveBorder">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clInactiveBorder">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clAppWorkspace">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clHighlight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clHighlightText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clBtnFace">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clBtnShadow">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clGrayText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clBtnText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clInactiveCaptionText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clBtnHighlight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cl3DDkShadow">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cl3DLight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clInfoText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clInfoBk">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clHotLight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clGradientActiveCaption">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clGradientInactiveCaption">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clForm">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clEndColors">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clColorDesktop">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cl3DFace">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cl3DShadow">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cl3DHiLight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clBtnHiLight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clFirstSpecialColor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clMask">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDontMask">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clForeground">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clButton">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clLight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clMidlight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDark">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clMid">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clBrightText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clButtonText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clBase">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clxBackground">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clShadow">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clxHighlight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clHighlightedText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cloNormal">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cloDisabled">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cloActive">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clNormalForeground">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clNormalButton">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clNormalLight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clNormalMidlight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clNormalDark">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clNormalMid">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clNormalText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clNormalBrightText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clNormalButtonText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clNormalBase">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clNormalBackground">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clNormalShadow">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clNormalHighlight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clNormalHighlightedText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDisabledForeground">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDisabledButton">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDisabledLight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDisabledMidlight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDisabledDark">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDisabledMid">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDisabledText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDisabledBrightText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDisabledButtonText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDisabledBase">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDisabledBackground">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDisabledShadow">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDisabledHighlight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clDisabledHighlightedText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clActiveForeground">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clActiveButton">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clActiveLight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clActiveMidlight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clActiveDark">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clActiveMid">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clActiveText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clActiveBrightText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clActiveButtonText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clActiveBase">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clActiveBackground">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clActiveShadow">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clActiveHighlight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clActiveHighlightedText">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- range type Visibility: default -->
      <element name="TMappedColor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TColorGroup">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorGroup.cgInactive">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorGroup.cgDisabled">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorGroup.cgActive">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TColorRole">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorRole.crForeground">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorRole.crButton">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorRole.crLight">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorRole.crMidlight">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorRole.crDark">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorRole.crMid">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorRole.crText">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorRole.crBrightText">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorRole.crButtonText">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorRole.crBase">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorRole.crBackground">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorRole.crShadow">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorRole.crHighlight">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorRole.crHighlightText">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TColorRole.crNoRole">
        <short/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cmBlackness">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cmDstInvert">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cmMergeCopy">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cmMergePaint">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cmNotSrcCopy">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cmNotSrcErase">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cmPatCopy">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cmPatInvert">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cmPatPaint">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cmSrcAnd">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cmSrcCopy">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cmSrcErase">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cmSrcInvert">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cmSrcPaint">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="cmWhiteness">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TPortableNetworkGraphic">
        <short>
          <var>TPortableNetworkGraphic</var> - a PNG image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TGraphicsObject">
        <short>
          <var>TGraphicsObject</var> - Primitive ancestor class, mainly for Delphi compatibility</short>
        <descr>TGraphicsObject - In Delphi VCL this is the ancestor of TFont, TPen and TBrush.<br/>
Since FPC 2.0 the LCL uses TFPCanvasHelper as ancestor.
</descr>
      </element>
      <!-- variable Visibility: private -->
      <element name="TGraphicsObject.FOnChanging">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TGraphicsObject.FOnChange">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TGraphicsObject.DoChange">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphicsObject.DoChange.Msg">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphicsObject.Changing">
        <short>
          <var>Changing</var> - software emulation of 
          <var>OnChanging</var> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphicsObject.Changed">
        <short>
          <var>Changed</var> - software emulation of 
          <var>OnChange</var> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphicsObject.Lock">
        <short>
          <var>Lock</var> - method for locking the object, making it unavailable for changes</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphicsObject.UnLock">
        <short>
          <var>UnLock</var> - method for releasing locked object</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TGraphicsObject.OnChanging">
        <short>
          <var>OnChanging</var> - event handler for changing object</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TGraphicsObject.OnChange">
        <short>
          <var>OnChange</var> - event handler for changed object</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TFontHandleCacheDescriptor">
        <short>
          <var>TFontHandleCacheDescriptor</var> - descriptor for items in Font Handle Cache</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: public -->
      <element name="TFontHandleCacheDescriptor.LogFont">
        <short>
          <var>LogFont</var> - a font used (especially in Windows) for logs</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: public -->
      <element name="TFontHandleCacheDescriptor.LongFontName">
        <short>
          <var>LongFontName</var> - the long name for the Font</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TFontHandleCache">
        <short>
          <var>TFontHandleCache</var> - a resource cache for font handles</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.LCLResCache.TResourceCache.RemoveItem" name="TFontHandleCache.RemoveItem">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFontHandleCache.RemoveItem.Item">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element link="#rtl.System.TObject.Create" name="TFontHandleCache.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.LCLResCache.TResourceCache.CompareDescriptors" name="TFontHandleCache.CompareDescriptors">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFontHandleCache.CompareDescriptors.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFontHandleCache.CompareDescriptors.Tree">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFontHandleCache.CompareDescriptors.Desc1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFontHandleCache.CompareDescriptors.Desc2">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TFontHandleCache.FindFont">
        <short>
          <var>FindFont</var> - returns the Font specified by its handle as a cache item from the FontHandleCache</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFontHandleCache.FindFont.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFontHandleCache.FindFont.TheFont">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TFontHandleCache.FindFontDesc">
        <short>
          <var>FindFontDesc</var> - returns the descriptor for the FontHandle using its 
          <var>LogName</var> and its 
          <var>LongFontName</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFontHandleCache.FindFontDesc.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFontHandleCache.FindFontDesc.LogFont">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFontHandleCache.FindFontDesc.LongFontName">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TFontHandleCache.Add">
        <short>
          <var>Add</var> the Font specified by its handle, 
          <var>LogFont</var> and 
          <var>LongFontName</var>, and returns a descriptor</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFontHandleCache.Add.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFontHandleCache.Add.TheFont">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFontHandleCache.Add.LogFont">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFontHandleCache.Add.LongFontName">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TFont">
        <short>The <var>Font</var>  to be used for drawing <var>Text</var>
        </short>
        <descr>
          <p>Most of the data about the font are dealt with by the protected procedures GetData and SetData which operate on TFontData</p>
          <p>Individual properties such as Character Set, colour and size can be accessed in the public area</p>
        </descr>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FCanUTF8">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FPitch">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FQuality">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FCharSet">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FPixelsPerInch">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FUpdateCount">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FChanged">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FFontHandleCached">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FColor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FFontName">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FSize">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FHeight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TFont.FreeHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TFont.GetData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.GetData.FontData">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TFont.IsNameStored">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFont.IsNameStored.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TFont.SetData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.SetData.FontData">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFont.SetName">
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomFont.SetName">TFPCustomFont.SetName</link>
        </seealso>
        <short>
          <var>SetName</var> - if 
          <var>AValue</var> is a new name, frees the old reference, calls inherited method and sets the 
          <var>Changed</var> property</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.SetName.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFont.SetSize">
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomFont.SetSize">TFPCustomFont.SetSize</link>
        </seealso>
        <short>
          <var>SetSize</var> - if 
          <var>AValue</var> is a new size, frees the old reference, calls the inherited method, performs the appropriate rounding and sets the 
          <var>Changed</var> property</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.SetSize.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFont.Changed">
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCanvasHelper.Changed">TFPCanvasHelper.Changed</link>
        </seealso>
        <short>
          <var>Changed</var> - checks for pending updates (if there are any, returns True) or calls inherited 
          <var>Changed</var>
        </short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TFont.GetCharSet">
        <short>
          <var>GetCharSet</var> - returns the Character Set to be used for this Font</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFont.GetCharSet.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TFont.GetHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFont.GetHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TFont.GetHeight">
        <short>
          <var>GetHeight</var> - returns the height of the Font</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFont.GetHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TFont.GetName">
        <short>
          <var>GetName</var> - returns the name of the Font</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFont.GetName.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TFont.GetPitch">
        <short>
          <var>GetPitch</var> - returns the pitch of the Font</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFont.GetPitch.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TFont.GetSize">
        <short>
          <var>GetSize</var> - returns the size of the Font</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFont.GetSize.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TFont.GetStyle">
        <short>
          <var>GetStyle</var> - returns the style of the Font</short>
        <descr>Bold, Italic, StrikeOut, Underline</descr>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFont.GetStyle.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFont.SetCharSet">
        <short>
          <var>SetCharSet</var> - specify the character set</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.SetCharSet.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFont.SetColor">
        <short>
          <var>SetColor</var> - specify the colour for the font</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.SetColor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFont.SetHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.SetHandle.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFont.SetHeight">
        <short>
          <var>SetHeight</var> - specify the height of the Font</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.SetHeight.value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFont.SetPitch">
        <short>
          <var>SetPitch</var> - specify the pitch for the Font</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.SetPitch.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFont.SetStyle">
        <short>
          <var>SetStyle</var> - specify which style to use</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.SetStyle.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFont.SetQuality">
        <short>
          <var>SetQuality</var> - specify the quality</short>
        <descr>Default, Draft, Proof, NonAntialiased, Antialiased</descr>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.SetQuality.AValue">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TFont.Create">
        <descr>
          <p>
            <var>Create</var> - constructor for 
            <var>TFont</var>: Opens a new instance of the class , calling inherited 
            <var>Create</var> and sets defaults for character set, colour, size etc</p>
        </descr>
        <short>
          <var>Create</var> - constructor for 
          <var>TFont</var>: Opens a new instance of the class, calling inherited 
          <var>Create</var> and setting some defaults</short>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TFont.Destroy">
        <short>
          <var>Destroy</var> - destructor for 
          <var>TFont</var>: frees reference then performs inherited 
          <var>Destroy</var>
        </short>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Destroy">TPersistent.Destroy</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TFont.Assign">
        <short>
          <var>Assign</var> - copies the source settings to itself</short>
        <descr>
          <p>Method: <var>TFont.Assign</var>
          </p>
          <p>
            <var>Source</var>: another font</p>
          <p>Returns:  nothing</p>
          <p>Copies the source settings to itself</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Assign"/>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.Assign.Source">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TFont.Assign">
        <short>Copies the settings from the given font.</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.Assign.ALogFont">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TFont.BeginUpdate">
        <short>
          <var>BeginUpdate</var> - start the update process</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TFont.EndUpdate">
        <short>
          <var>EndUpdate</var> - finish the update process</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TFont.HandleAllocated">
        <short>
          <var>HandleAllocated</var> - returns True if a handle has been allocated</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFont.HandleAllocated.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TFont.IsDefault">
        <short>
          <var>IsDefault</var> - returns True if this is the default Font</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFont.IsDefault.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TFont.Handle">
        <short>Operataing system <var>Handle</var> for this Font</short>
        <descr>Operataing system <var>Handle</var> for this Font - deprecated</descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TFont.PixelsPerInch">
        <short>
          <var>PixelsPerInch</var> - scaling factor for drawing Font</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TFont.CanUTF8">
        <short>
          <var>CanUTF8</var> - returns True if Font can be used for UTF8</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TFont.CharSet">
        <short>The <var>Character Set</var> to be used by the current<var>Font</var>
        </short>
      </element>
      <!-- property Visibility: published -->
      <element name="TFont.Color">
        <short>
          <var>Colour</var> of the current 
          
          
          
          <var>Font</var>
        </short>
        <descr>Default is the same as the text used for the rest of the Window
</descr>
      </element>
      <!-- property Visibility: published -->
      <element name="TFont.Height">
        <short>The <var>Height</var> of the current Font</short>
      </element>
      <!-- property Visibility: published -->
      <element link="#fcl.FPCanvas.TFPCustomFont.Name" name="TFont.Name"/>
      <!-- property Visibility: published -->
      <element name="TFont.Pitch">
        <short>
          <var>Pitch</var> type of the 
          
          
          
          
          
          
          
          <var>Font</var>
        </short>
        <descr>Fixed or variable pitch, or Default<br/>
Reads or writes a flag to determine pitch type</descr>
        <seealso>
          <link id="TFontPitch"/>
        </seealso>
      </element>
      <!-- property Visibility: published -->
      <element name="TFont.Quality">
        <short>Output quality of the <var>Font</var>, such as antialiasing</short>
        <descr/>
        <seealso>
          <link id="TFontQuality"/>
        </seealso>
      </element>
      <!-- property Visibility: published -->
      <element link="#fcl.FPCanvas.TFPCustomFont.Size" name="TFont.Size"/>
      <!-- property Visibility: published -->
      <element name="TFont.Style">
        <short>
          <var>Style</var> of the 
          
          
          
          
          
          
          
          <var>Font</var>
        </short>
        <descr>Bold, Italic, Strike out, Underline<br/>
Property is a set, so may contain zero or more of the above (if set is empty, Normal font is displayed)</descr>
      </element>
      <!-- record type Visibility: default -->
      <element name="TPenData">
        <short>The <var>Data</var> associated with the current <var>Pen</var>
        </short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TPenData.Handle">
        <short>The Operating System <var>Handle</var> associated with the current <var>Pen</var>
        </short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TPenData.Color">
        <short>The <var>Colour</var> of the curent <var>Pen</var>
        </short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TPenData.Width">
        <short>The <var>Width</var> in pixels of the current <var>Pen</var>
        </short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TPenData.Style">
        <short>The <var>Style</var> asociated with the current <var>Pen</var>
        </short>
        <descr>The <var>Style</var> asociated with the current <var>Pen</var><br/>
Can take any of the values:
psSolid, psDash, psDot, psDashDot, psDashDotDot, psinsideFrame, psPattern,psClear</descr>
      </element>
      <!-- object Visibility: default -->
      <element name="TPenHandleCache">
        <short>
          <var>TPenHandleCache</var> - Resource Cache for Pen Handles</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.LCLResCache.TResourceCache.RemoveItem" name="TPenHandleCache.RemoveItem">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPenHandleCache.RemoveItem.Item">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element link="#rtl.System.TObject.Create" name="TPenHandleCache.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TPen">
        <short>The current <var>Pen</var> for drawing on the current <var>Canvas</var>
        </short>
      </element>
      <!-- variable Visibility: private -->
      <element name="TPen.FHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TPen.FColor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TPen.FPenHandleCached">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TPen.FWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TPen.FStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TPen.FMode">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TPen.FreeHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TPen.GetHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPen.GetHandle.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TPen.SetHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPen.SetHandle.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TPen.SetColor">
        <short>
          <var>SetColor</var> - specifies Colour for the Pen</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPen.SetColor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#fcl.FPCanvas.TFPCustomPen.SetMode" name="TPen.SetMode">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPen.SetMode.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#fcl.FPCanvas.TFPCustomPen.SetStyle" name="TPen.SetStyle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPen.SetStyle.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#fcl.FPCanvas.TFPCustomPen.SetWidth" name="TPen.SetWidth">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPen.SetWidth.value">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TPen.Create">
        <descr>Most of its properties are <b>inherited</b>
 from the parent class
</descr>
        <short>
          <var>Create</var> - constructor for TPen: performs inherited 
          <var>Create</var> then sets some local defaults, style, mode, width and colour</short>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TPen.Destroy">
        <descr>Most of its properties are <b>inherited</b> from the parent class
</descr>
        <short>
          <var>Destroy</var> - destructor for 
          <var>TPen</var>: frees reference then performs inherited 
          <var>Destroy</var>
        </short>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Destroy">TPersistent.Destroy</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TPen.Assign">
        <short>
          <var>Assign</var> - copies settings from Source to itself (provided Source is another 
          <var>TPen</var>), then performs inherited 
          <var>Assign</var>
        </short>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Assign">TPersistent.Assign</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPen.Assign.Source">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TPen.Handle">
        <short>The Operating System <var>Handle</var> for the current <var>Pen</var>
        </short>
        <descr>Reads or writes a flag to determine the handle
</descr>
      </element>
      <!-- property Visibility: published -->
      <element name="TPen.Color">
        <short>The <var>Colour </var>of the current <var>Pen</var>
        </short>
        <descr>Reads or Writes a flag to determine the colour. Default is black</descr>
      </element>
      <!-- property Visibility: published -->
      <element link="#fcl.FPCanvas.TFPCustomPen.Mode" name="TPen.Mode">
        <descr>Can take any of the values:<br/>
pmBlack, pmWhite, pmNop, pmNot, pmCopy, pmNotCopy,<br/>
pmMergePenNot, pmMaskPenNot, pmMergeNotPen, pmMaskNotPen, pmMerge,<br/>
pmNotMerge, pmMask, pmNotMask, pmXor, pmNotXor<br/>
Default is pmCopy
</descr>
      </element>
      <!-- property Visibility: published -->
      <element link="#fcl.FPCanvas.TFPCustomPen.Style" name="TPen.Style">
        <descr>Can be one of the following: <br/>
psSolid, psDash, psDot, psDashDot, psDashDotDot, psinsideFrame, psPattern,psClear<br/>
Default is psSolid
</descr>
      </element>
      <!-- property Visibility: published -->
      <element link="#fcl.FPCanvas.TFPCustomPen.Width" name="TPen.Width"/>
      <!-- record type Visibility: default -->
      <element name="TBrushData">
        <short>The <var>Data</var> associated with the current <var>Brush</var>
        </short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TBrushData.Handle">
        <short>The Operating System <var>Handle</var> associated with the current <var>Brush</var>
        </short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TBrushData.Color">
        <short>The <var>Colour</var> to be used by the current <var>Brush</var>
        </short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TBrushData.Bitmap">
        <short>The <var>Bitmap</var> on which the current <var>Brush</var> is working</short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TBrushData.Style">
        <short>The <var>Style</var>   to be used by the current <var>Brush</var>
        </short>
        <descr>Enumerated type defined in <var>TBrushStyle</var>
        </descr>
        <seealso>
          <link id="TBrushStyle"/>
        </seealso>
      </element>
      <!-- object Visibility: default -->
      <element name="TBrushHandleCache">
        <short>
          <var>TBrushHandleCache</var> - resource cache for Brush Handles</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.LCLResCache.TResourceCache.RemoveItem" name="TBrushHandleCache.RemoveItem">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBrushHandleCache.RemoveItem.Item">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element link="#rtl.System.TObject.Create" name="TBrushHandleCache.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TBrush">
        <short>The <var>Brush</var> to be used to <var>Paint</var> on the current <var>Canvas</var>
        </short>
        <descr>A <var>Brush</var> is typically used to fill an enclosed area on the<var>Canvas</var> with one particular colour or coloured pattern</descr>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBrush.FHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBrush.FColor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBrush.FBitmap">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBrush.FStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBrush.FBrushHandleCached">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TBrush.FreeHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TBrush.GetHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBrush.GetHandle.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBrush.SetBitmap">
        <short>
          <var>SetBitmap</var> - specify the Bitmap for the Brush</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBrush.SetBitmap.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBrush.SetColor">
        <descr/>
        <errors/>
        <seealso/>
        <short>
          <var>SetColor</var> - specify Colour for the Brush</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBrush.SetColor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBrush.SetHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBrush.SetHandle.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#fcl.FPCanvas.TFPCustomBrush.SetStyle" name="TBrush.SetStyle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBrush.SetStyle.Value">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBrush.Assign">
        <descr>Method: TBrush.Assign<br/>
  Params: Source: Another brush<br/>
  Returns:  nothing<br/>

  Copies the source brush to itself
</descr>
        <short>
          <var>Assign</var> - if 
          <var>Source</var> is another 
          <var>TBrush</var>, copies settings to itself, else performs inherited 
          <var>Assign</var>
        </short>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Assign">TPersistent.Assign</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBrush.Assign.Source">
        <short>
          <var>Source</var> - another 
          
          
          
          
          
          
          
          <var>Brush</var>
        </short>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TBrush.Create">
        <descr>
          <b>Inherits</b> most of its properties from ancestor Classes
</descr>
        <short>
          <var>Create</var> - constructor for 
          <var>TBrush</var>: perform inherited 
          <var>Create</var> then initialise some local variables and 
          <var>SetStyle</var>
        </short>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TBrush.Destroy">
        <descr>
          <b>Inherits</b> properties to remove 
          
          
          
          
          
          
          
          <var>Brush</var> and frees 
          
          
          
          
          
          
          
          <var>Handle</var>
        </descr>
        <short>
          <var>Destroy</var> - destructor for 
          <var>TBrush</var>: free reference then perform inherited 
          <var>Destroy</var>
        </short>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Destroy">TPersistent.Destroy</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TBrush.Bitmap">
        <short>The <var>BitMap</var> associated with the current <var>Brush</var>
        </short>
        <descr>Reads or writes a flag to determine the current <var>BitMap</var>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TBrush.Handle">
        <short>Operating System <var>Handle</var> for this <var>Brush</var>
        </short>
        <descr>Reads or writes flag to determine system <var>Handle</var>
        </descr>
      </element>
      <!-- property Visibility: published -->
      <element name="TBrush.Color">
        <short>The <var>Colour</var> of the current <var>Brush</var>
        </short>
        <descr>Reads or writes a flag to determine the <var>Colour</var>. Default is White</descr>
      </element>
      <!-- property Visibility: published -->
      <element name="TBrush.Style">
        <short>
          <var>Style</var> of the <var>Brush</var>
        </short>
        <descr>Enumerated type - default Solid</descr>
        <seealso>
          <link id="TBrushStyle"/>
        </seealso>
      </element>

      <!-- record type Visibility: default -->
      <element name="TRegionData">
        <short>The <var>Data</var> about the current <var>Region</var> on the <var>Screen</var> or <var>Canvas</var>
          [found where???]
        </short>
        <descr>At present the Region can only be rectangular; the ability to define it as a Polygon is not yet implemented</descr>
      </element>
      <!-- variable Visibility: default -->
      <element name="TRegionData.Handle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element link="#rtl.Classes.Rect" name="TRegionData.Rect">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TRegionData.Polygon">
        <short>
          <var>Polygon</var> - a list of points defining a polygon</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TRegionData.NumPoints">
        <short>
          <var>NumPoints</var> - the number of points in the polygon list</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TRegionData.Winding">
        <short>If True, use <var>Winding</var> mode to construct the Polygon</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TRegionData.Reference">
        <short>A <var>Reference</var> made to the current Region</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TRegion">
        <short>A defined <var>Region</var> on the screen, in which text is written</short>
        <seealso>
        </seealso>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TRegion.FreeHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TRegion.GetHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRegion.GetHandle.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRegion.SetHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRegion.SetHandle.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRegion.SetClipRect">
        <short>
          <var>SetClipRect</var> - specify the rectangle to use for clipping</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRegion.SetClipRect.value">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TRegion.GetClipRect">
        <short>
          <var>GetClipRect</var> - returns the coordinates of the clipping rectangle</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRegion.GetClipRect.Result">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TRegion.Create">
        <short>
          <var>Create</var> - constructor for 
          <var>TRegion</var>: calls inherited 
          <var>Create</var> and sets FillChar</short>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TRegion.Destroy">
        <short>
          <var>Destroy</var> - destructor for 
          <var>TRegion</var>: frees reference then calls inherited 
          <var>Destroy</var>
        </short>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Destroy">TPersistent.Destroy</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TRegion.Assign">
        <short>
          <var>Assign</var> - if 
          <var>Source</var> is another 
          <var>TRegion</var>, copies the dimensions of the clipping rectangle</short>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Assign">TPersistent.Assign</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRegion.Assign.Source">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TRegion.Handle">
        <short>Operating System <var>Handle</var>  for this <var>Region</var>
        </short>
        <seealso>
          <link id="#lcl.lcltype.HRGN">HRGN </link>
          <link id="#rtl.sysutils.thandle">THandle </link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TRegion.ClipRect">
        <short>
          <var>ClipRect</var> - The rectangle to be used for clipping text</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TGraphic">
        <short>
          <var>TGraphic</var> - Base class for dealing with 
          <var>Graphic</var>   images</short>
        <descr>The <var>TGraphic</var> class is an <b>abstract</b> base class for dealing with graphic images such as bitmaps, pixmaps, icons, and other image formats. It does not contain an actual area for displaying the image; this is provided by the descendant classes eg <var>BitMap</var>, <var>Icon</var> etc which have a <var>Canvas</var> element defined <br/><var>LoadFromFile</var> - Read the graphic from the file system.  The old contents of the graphic are lost.  If the file is not of the right format, an exception will be generated.<br/><var>SaveToFile</var> - Writes the graphic to disk in the file provided.<br/><var>LoadFromStream</var> - Like <var>LoadFromFile</var>  except source is a stream (e.g.  <var>TBlobStream</var>
).<br/><var>SaveToStream</var> - stream analogue of <var>SaveToFile</var> .<br/><var>LoadFromClipboardFormat</var> - Replaces the current image with the data provided.  If the <var>TGraphic</var>
 does not support that format it will generate an exception.<br/><var>SaveToClipboardFormats</var> - Converts the image to a clipboard format.  If the image does not support being translated into a clipboard format it will generate an exception.<br/><var>Height</var> - The native, unstretched, height of the graphic.<br/><var>Palette</var> - Color palette of image.  Zero if graphic doesn't need/use palettes.<br/><var>Transparent</var> - Some parts of the image are not opaque, ie the background can be seen through.<br/><var>Width</var> - The native, unstretched, width of the graphic.<br/><var>OnChange</var> - Called whenever the graphic changes<br/><var>PaletteModified</var> - Indicates in <var>OnChange</var>  whether color palette has changed. Stays true until whoever is responsible for realizing this new palette    (ex: TImage) sets it to False.<br/><var>OnProgress</var> - Generic progress indicator event. Propagates out to <var>TPicture</var>
  and <var>TImage OnProgress</var> events.<br/><br/>
 
  As many of the methods and properties are <b>virtual</b> and/or <b>abstract</b>, it is the responsibility of the application programmer to supply suitable methods when implementing any descendant classes
</descr>
      </element>
      <!-- variable Visibility: private -->
      <element name="TGraphic.FModified">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TGraphic.FTransparent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TGraphic.FOnChange">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TGraphic.FOnProgress">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TGraphic.FPaletteModified">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphic.Changed">
        <short>
          <var>Changed</var> - software emulation of a call to the 
          <var>OnChange</var> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.Changed.Sender">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TGraphic.Equals">
        <short>
          <var>Equals</var> - returns True if the current Graphic is the same as the specified Graphic</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TGraphic.Equals.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.Equals.Graphic">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphic.DefineProperties">
        <short>
          <var>DefineProperties</var> finds out whether the object really is a binary (graphic)</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TPersistent.DefineProperties">TPersistent.DefineProperties</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.DefineProperties.Filer">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphic.Draw">
        <short>Method to <var>Draw</var> the Graphic on the specified Canvas, in the specified Rectangle</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.Draw.ACanvas">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.Draw.Rect">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TGraphic.GetEmpty">
        <short>
          <var>GetEmpty</var> - returns True if the Graphic is empty</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TGraphic.GetEmpty.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TGraphic.GetHeight">
        <short>
          <var>GetHeight</var> - returns the height of the Graphic</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TGraphic.GetHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TGraphic.GetMimeType">
        <short>
          <var>GetMimeType</var> - returns the MIME type of the Graphic</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TGraphic.GetMimeType.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TGraphic.GetPalette">
        <short>
          <var>GetPalette</var> - returns a Handle for the Palette</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TGraphic.GetPalette.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TGraphic.GetTransparent">
        <short>
          <var>GetTransparent</var> - returns True if the graphic is transparent</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TGraphic.GetTransparent.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TGraphic.GetWidth">
        <short>
          <var>GetWidth</var> - returns the width of the Graphic</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TGraphic.GetWidth.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphic.Progress">
        <short>Monitor the <var>Progress</var> of the drawing</short>
        <seealso>
          <link id="Graphics.Progress"/>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.Progress.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.Progress.Stage">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.Progress.PercentDone">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.Progress.RedrawNow">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.Progress.R">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.Progress.Msg">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.Progress.DoContinue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphic.ReadData">
        <short>
          <var>ReadData</var> - reads data for the Graphic from a stream</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.ReadData.Stream">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphic.SetHeight">
        <short>
          <var>SetHeight</var> - defines the height for the Graphic</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.SetHeight.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphic.SetPalette">
        <short>
          <var>SetPalette</var> - deefines the Palette Handle to be used</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.SetPalette.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphic.SetTransparent">
        <short>
          <var>SetTransparent</var> - defines whether the graphic is to be transparent</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.SetTransparent.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphic.SetWidth">
        <short>
          <var>SetWidth</var> - defines the width for the Graphic</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.SetWidth.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphic.SetModified">
        <short>
          <var>SetModified</var> - defines whether the graphic has been modified</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.SetModified.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphic.WriteData">
        <short>
          <var>WriteData</var> - writes Graphic data to a stream</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.WriteData.Stream">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TGraphic.Assign">
        <short>
          <var>Assign</var> - checks if there really is a source to assign (if not, calls 
          <var>Clear</var>), then calls inherited method</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Assign">TPersistent.Assign</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.Assign.ASource">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TGraphic.Clear">
        <short>
          <var>Clear</var> the resources used by the Graphic, leaving a blank Graphic</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TGraphic.Create">
        <descr>
          <b>Virtual</b> method, so recommend that a constructor be supplied to 
          
          
          
          
          
          
          
          <b>override</b> this method in descendant classes
</descr>
        <short>
          <var>Create</var> - constructor for 
          <var>TGraphic</var>: calls inherited 
          <var>Create</var>
        </short>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TGraphic.LoadFromFile">
        <short>
          <var>LoadFromFile</var> - Read the graphic from the file system.</short>
        <descr>LoadFromFile - Read the graphic from the file system.  <br/>
The old contents of the graphic are lost.  <br/>
If the file is not of the right format, an exception will be generated.</descr>
        <errors>Incorrect file format generates an exception</errors>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.LoadFromFile.Filename">
        <short>The name of the file containing the graphic, held as a string</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TGraphic.SaveToFile">
        <short>
          <var>SaveToFile</var> - Writes the graphic to disk in the file provided.</short>
        <descr>
          <var>SaveToFile</var> - Writes the graphic to disk in the file whose name is provided.</descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.SaveToFile.Filename">
        <short>The name of the file to which the graphic will be written</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TGraphic.LoadFromStream">
        <short>
          <var>LoadFromStream</var>  - reads graphic data from a stream (e.g. 
          
          
          
          <var>TBlobStream</var> )</short>
        <descr>
          <var>LoadFromStream</var>
 - Like 
          
          
          
          
          
          
          
          <var>LoadFromFile</var>
 except source is a stream (e.g. 
          
          
          
          
          
          
          
          <var>TBlobStream</var>)
</descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.LoadFromStream.Stream">
        <short>Identity of the stream from which the graphic data are to be read</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TGraphic.SaveToStream">
        <short>
          <var>SaveToStream</var> - write graphic data to a stream</short>
        <descr>
          <var>SaveToStream</var> - write graphic data to a stream</descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.SaveToStream.Stream">
        <short>Identity of the stream to which the graphic data are to be written</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TGraphic.LoadFromMimeStream">
        <short>
          <var>LoadFromMimeStream </var>- reads graphic data from a MIME stream</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.LoadFromMimeStream.AStream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.LoadFromMimeStream.AMimeType">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TGraphic.MimeType">
        <short>
          <var>MimeType</var> - the MIME type of the graphic</short>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.LoadFromMimeStream.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.LoadFromMimeStream.MimeType">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TGraphic.LoadFromLazarusResource">
        <short>Load the graphic data from a Lazarus Resource (eg a *.lrs file)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.LoadFromLazarusResource.ResName">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TGraphic.LoadFromClipboardFormat">
        <short>
          <var>LoadFromClipboardFormat</var> - Replace the current image with the contents of the clipboard</short>
        <descr>
          <var>LoadFromClipboardFormat</var> - Replaces the current image with the data provided from the clipboard.</descr>
        <errors>If the <var>TGraphic</var> does not support that format it will generate an exception.</errors>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.LoadFromClipboardFormat.FormatID">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TGraphic.LoadFromClipboardFormatID">
        <short>Load the data from the clipboard using the format type specified by <var>ClipboardType</var> and the format identifier <var>FormatID</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.LoadFromClipboardFormatID.ClipboardType">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.LoadFromClipboardFormatID.FormatID">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TGraphic.SaveToClipboardFormat">
        <short>
          <var>SaveToClipboardFormats</var> - Converts the image to a clipboard format</short>
        <descr>
          <var>SaveToClipboardFormats</var> - Converts the image to a clipboard format</descr>
        <errors>If the image does not support being translated into a clipboard format it will generate an exception</errors>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.SaveToClipboardFormat.FormatID">
        <short>Identity of the clipboard format</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TGraphic.SaveToClipboardFormatID">
        <short>Saves the data to a clipboard of Type <var>ClipboardType</var> using the format <var>FormatID</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.SaveToClipboardFormatID.ClipboardType">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.SaveToClipboardFormatID.FormatID">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TGraphic.GetSupportedSourceMimeTypes">
        <short>Gets a list of the MIME types that are supported</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.GetSupportedSourceMimeTypes.List">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TGraphic.GetDefaultMimeType">
        <short>Finds the default MIME type </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TGraphic.GetDefaultMimeType.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TGraphic.GetFileExtensions">
        <short>
          <var>GetFileExtensions</var> - returns a list of the file extensions available</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TGraphic.GetFileExtensions.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TGraphic.GetFPReaderForFileExt">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TGraphic.GetFPReaderForFileExt.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.GetFPReaderForFileExt.FileExtension">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TGraphic.GetFPWriterForFileExt">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TGraphic.GetFPWriterForFileExt.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.GetFPWriterForFileExt.FileExtension">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TGraphic.GetDefaultFPReader">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TGraphic.GetDefaultFPReader.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TGraphic.GetDefaultFPWriter">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TGraphic.GetDefaultFPWriter.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TGraphic.Empty">
        <short>Is this an empty (blank) graphic?</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TGraphic.Height">
        <short>
          <var>Height</var> - The native, unstretched, height of the graphic.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TGraphic.Modified">
        <short>Has the graphic been modified?</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TGraphic.OnChange">
        <short>Event handler for any change in the data</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TGraphic.OnProgress">
        <short>Event handler for monitoring progress of the graphic</short>
        <seealso>
          <link id="Graphics.Progress"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TGraphic.Palette">
        <short>
          <var>Palette</var> - Color palette of image</short>
        <descr>
          <var>Palette</var> - Color palette of image.  Zero if graphic doesn't need/use palettes</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TGraphic.PaletteModified">
        <short>Has the palette of colours been modified?</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TGraphic.Transparent">
        <short>
          <var>Transparent</var> - Some parts of the image are not opaque. ie the background
 can be seen through</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TGraphic.Width">
        <short>
          <var>Width</var> - The native, unstretched, width of the graphic.</short>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TGraphicClass">
        <short>
          <var>TGraphicClass</var> - class of TGraphic</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TPicture">
        <short>
          <var>TPicture</var> is a  
          
          
          
          <var>TGraphic</var>  container, used in place of a  
          
          
          
          <var>TGraphic</var> if the graphic can be of any 
          
          
          
          <var>TGraphic</var> class.</short>
        <descr>
          <p>
            <var>TPicture</var> is a 
            
            
            
            <var>TGraphic</var> container.  It is used in place of a 
            
            
            
            <var>TGraphic</var> if the graphic can be of any 
            
            
            
            <var>TGraphic</var> class. </p>
          <p>It is not a direct descendant of <var>TGraphic</var>, so you will not see <var>TGraphic</var> listed in the <var>Inheritance</var> chart, but it contains a property <var>Graphic</var>, of type <var>TGraphic</var>, so can contain all the properties of a <var>TGraphic</var>
          </p>
          <p>Defines many <b>private</b> methods for getting and storing various sorts of images such as bitmaps, pixmaps, icons, PNGs etc</p>
          <p>It does not itself contain a defined area for displaying the image, but this is supplied by the descendant classes such as BitMap, PixMap, PNG or Icon, which define a <var>Canvas</var> property.</p>
          <p>
            <var>LoadFromFile</var> and 
            
            
            
            <var>SaveToFile</var> are polymorphic. For example, if the 
            
            
            
            <var>TPicture</var> is holding an 
            
            
            
            <var>Icon</var>, you can 
            
            
            
            <var>LoadFromFile</var> a bitmap file, whereas if the class is 
            
            
            
            <var>TIcon</var> you could only read  .ICO files.</p>
          <ul>
            <li>
              <var>LoadFromFile</var> - Reads a picture from disk. The 
              
              
              
              <var>TGraphic</var> class created is determined by the file extension of the file. If the file extension is  not recognized an exception is generated.</li>
            <li>
              <var>SaveToFile</var> - Writes the picture to disk.</li>
            <li>
              <var>LoadFromClipboardFormat</var> - ToDo: Reads the picture from the handle provided in the given clipboard format.  If the format is not supported, an exception is generated.</li>
            <li>
              <var>SaveToClipboardFormats</var> - ToDo: Allocates a global handle and writes the picture in its native clipboard format (CF_BITMAP for bitmaps, CF_METAFILE for metafiles, etc.).  Formats will contain the formats written.  Returns the number of clipboard items written to the array pointed to by Formats and Datas or would be written if either Formats or Datas are  nil.</li>
            <li>
              <var>SupportsClipboardFormat</var> - Returns true if the given clipboard format  is supported by 
              
              
              
              <var>LoadFromClipboardFormat</var>
            </li>
            <li>
              <var>Assign</var> - Copies the contents of the given 
              
              
              
              <var>TPicture</var>.  Used most often in  the implementation of TPicture properties.</li>
            <li>
              <var>RegisterFileFormat</var> - Register a new 
              
              
              
              <var>TGraphic</var> class for use in 
              
              
              
              <var>LoadFromFile</var>.</li>
            <li>
              <var>RegisterClipboardFormat</var> - Registers a new 
              
              
              
              <var>TGraphic</var> class for use in 
              
              
              
              <var>LoadFromClipboardFormat</var>.</li>
            <li>
              <var>UnRegisterGraphicClass</var> - Removes all references to the specified 
              
              
              
              <var>TGraphic</var> class and all its descendants from the file format and clipboard format internal lists.</li>
            <li>
              <var>Height</var> - The native, unstretched, height of the picture.</li>
            <li>
              <var>Width</var> - The native, unstretched, width of the picture.</li>
            <li>
              <var>Graphic</var> - The 
              
              
              
              <var>TGraphic</var> object contained by the 
              
              
              
              <var>TPicture</var>
            </li>
            <li>
              <var>Bitmap</var> - Returns a bitmap.  If the contents is not already a bitmap, the contents are thrown away and a blank bitmap is returned.</li>
            <li>
              <var>Pixmap</var> - Returns a pixmap.  If the contents is not already a pixmap, the contents are thrown away and a blank pixmap is returned.</li>
            <li>
              <var>PNG</var> - Returns a png.  If the contents is not already a png, the  contents are thrown away and a blank png (
              
              
              
              <var>TPortableNetworkGraphic</var>) is returned.</li>
            <li>
              <var>PNM</var> - Returns a pnm.  If the contents is not already a pnm, the contents are thrown away and a blank pnm (
              
              
              
              <var>TPortableAnyMapGraphic</var>) is returned.</li>
            <li>
              <var>Jpeg</var> - Returns a jpeg. If the contents is not already a jpeg, the contents are thrown away and a blank jpeg (
              
              
              
              <var>TJPegImage</var>) is returned.</li>
          </ul>
        </descr>
      </element>
      <!-- variable Visibility: private -->
      <element name="TPicture.FGraphic">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TPicture.FOnChange">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TPicture.FOnProgress">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TPicture.ForceType">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.ForceType.GraphicType">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TPicture.GetBitmap">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPicture.GetBitmap.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TPicture.GetPNG">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPicture.GetPNG.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TPicture.GetPixmap">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPicture.GetPixmap.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TPicture.GetIcon">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPicture.GetIcon.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TPicture.GetHeight">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPicture.GetHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TPicture.GetWidth">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPicture.GetWidth.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TPicture.ReadData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.ReadData.Stream">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TPicture.SetBitmap">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.SetBitmap.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TPicture.SetPNG">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.SetPNG.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TPicture.SetPixmap">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.SetPixmap.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TPicture.SetIcon">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.SetIcon.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TPicture.SetGraphic">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.SetGraphic.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TPicture.WriteData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.WriteData.Stream">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TPicture.AssignTo">
        <short>
          <var>AssignTo</var> if 
          <var>Dest</var> is of correct (Graphic) type, calls 
          <var>Assign</var> for 
          <var>Dest</var>, otherwise calls inherited 
          <var>AssignTo</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TPersistent.AssignTo">TPersistent.AssignTo</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.AssignTo.Dest">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TPicture.Changed">
        <short>
          <var>Changed</var> - software emulation of a call to the 
          <var>OnChange</var> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.Changed.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#rtl.Classes.TPersistent.DefineProperties" name="TPicture.DefineProperties">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.DefineProperties.Filer">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TPicture.Progress">
        <short>Monitor progress of drawing process</short>
        <seealso>
          <link id="Graphics.Progress"/>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.Progress.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.Progress.Stage">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.Progress.PercentDone">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.Progress.RedrawNow">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.Progress.R">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.Progress.Msg">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.Progress.DoContinue">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TPicture.Create">
        <short>
          <var>Create</var> - constructor for TPicture: performs inherited 
          <var>Create</var> then loads file and clipboard formats</short>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TPicture.Destroy">
        <descr>Any destructor method defined here will <b>override</b> destructors defined in ancestor classes
</descr>
        <short>
          <var>Destroy</var> - destructor for 
          <var>TPicture</var>: frees graphic then performs inherited 
          <var>Destroy</var>
        </short>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Destroy">TPersistent.Destroy</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TPicture.LoadFromFile">
        <short>
          <var>LoadFromFile</var> - Reads a picture from disk</short>
        <descr>
          <var>LoadFromFile</var> - Reads a picture from disk. The 
          
          
          
          
          
          
          
          <var>TGraphic</var> class created is determined by the file extension of the file.</descr>
        <errors>If the file extension is  not recognized an exception is generated</errors>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.LoadFromFile.Filename">
        <short>The name of the file containing the picture, stored as a string</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TPicture.SaveToFile">
        <short>
          <var>SaveToFile</var> - Writes the picture to disk</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.SaveToFile.Filename">
        <short>The name of the file to save the picture, stored as a string</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TPicture.LoadFromClipboardFormat">
        <short>
          <var>LoadFromClipboardFormat</var> - Reads the picture from the handle provided in the given clipboard format</short>
        <descr>
          <var>LoadFromClipboardFormat</var> - ToDo: Reads the picture from the handle provided in the given clipboard format.
</descr>
        <errors>If the format is not supported, an exception is generated
</errors>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.LoadFromClipboardFormat.FormatID">
        <short>The identifier for the clipboard format</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TPicture.LoadFromClipboardFormatID">
        <short>Reads the picture from a clipboard of type <var>ClipboardType</var> using the format <var>FormatID</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.LoadFromClipboardFormatID.ClipboardType">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.LoadFromClipboardFormatID.FormatID">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TPicture.SaveToClipboardFormat">
        <short>
          <var>SaveToClipboardFormats</var> - Allocates a global handle and writes the picture in its native clipboard format</short>
        <descr>
          <var>SaveToClipboardFormats</var> - ToDo: Allocates a global handle and writes the picture in its native clipboard format (CF_BITMAP for bitmaps, CF_METAFILE for metafiles, etc.).  Formats will contain the formats written.  Returns the number of clipboard items written to the array pointed to by Formats and Datas or would be written if either Formats or Datas are  nil.</descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.SaveToClipboardFormat.FormatID">
        <short>Identity of the clipboard format</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TPicture.SupportsClipboardFormat">
        <short>
          <var>SupportsClipboardFormat</var> - Returns true if the given clipboard format  is supported by 
          
          
          
          
          
          
          
          <var>LoadFromClipboardFormat</var>
        </short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPicture.SupportsClipboardFormat.Result">
        <short>Boolean - returns true if format supported</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.SupportsClipboardFormat.FormatID">
        <short>Identity of the clipboard format</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TPicture.Assign">
        <short>
          <var>Assign</var> - if the Source is a valid graphic type, copy the relevant details to the current object, otherwise call inherited 
          <var>Assign</var>
        </short>
        <descr>
          <var>Assign</var> - Copies the contents of the given 
          
          
          
          
          
          
          
          <var>TPicture</var>.  Used most often in  the implementation of TPicture properties.
</descr>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Assign">TPersistent.Assign</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.Assign.Source">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TPicture.RegisterFileFormat">
        <short>
          <var>RegisterFileFormat</var> - Register a new 
          
          
          
          <var>TGraphic</var> class for use in 
          
          
          
          <var>LoadFromFile</var>
        </short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.RegisterFileFormat.AnExtension">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.RegisterFileFormat.ADescription">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.RegisterFileFormat.AGraphicClass">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TPicture.RegisterClipboardFormat">
        <short>
          <var>RegisterClipboardFormat</var> - Registers a new 
          
          
          
          <var>TGraphic</var> class for use in  
          
          
          
          <var>LoadFromClipboardFormat</var>
        </short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.RegisterClipboardFormat.FormatID">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.RegisterClipboardFormat.AGraphicClass">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TPicture.UnregisterGraphicClass">
        <short>
          <var>UnRegisterGraphicClass</var>  - Removes all references to the specified 
          
          
          
          <var>TGraphic</var>
        </short>
        <descr>
          <var>UnRegisterGraphicClass</var>
 - Removes all references to the specified 
          
          
          
          
          
          
          
          <var>TGraphic</var>
  class and all its descendants from the file format and clipboard format internal lists
</descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.UnregisterGraphicClass.AClass">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TPicture.Clear">
        <short>
          <var>Clear</var> - removes the graphic</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TPicture.Bitmap">
        <short>
          <var>Bitmap</var> - Returns a bitmap</short>
        <descr>
          <var>Bitmap</var> - Returns a bitmap.  If the contents is not already a bitmap, the contents are thrown away and a blank bitmap is returned</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TPicture.Pixmap">
        <short>
          <var>Pixmap</var> - Returns a pixmap</short>
        <descr>
          <var>Pixmap</var> - Returns a pixmap.  If the contents is not already a pixmap, the contents are thrown away and a blank pixmap is returned</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TPicture.PNG">
        <short>
          <var>PNG</var> - Returns a png</short>
        <descr>
          <var>PNG</var> - Returns a png.  If the contents is not already a png, the  contents are thrown away and a blank png (
          
          
          
          <var>TPortableNetworkGraphic</var>) is returned
</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TPicture.Icon">
        <short>
          <var>Icon</var> contained within the picture</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TPicture.Graphic">
        <short>
          <var>Graphic</var> - The 
          
          
          
          <var>TGraphic</var> object contained by the 
          
          
          
          <var>TPicture</var>
        </short>
      </element>
      <!-- property Visibility: public -->
      <element name="TPicture.Height">
        <short>
          <var>Height</var> - The native, unstretched, height of the picture</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TPicture.Width">
        <short>
          <var>Width</var> - The native, unstretched, width of the picture</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TPicture.OnChange">
        <short>
          <var>OnChange</var> - Event handler for any change in the picture</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TPicture.OnProgress">
        <short>
          <var>OnProgress</var> - Event handler for monitoring progress in drawing the picture</short>
        <seealso>
          <link id="Graphics.Progress"/>
        </seealso>
      </element>
      <!-- object Visibility: default -->
      <element name="EInvalidGraphic">
        <short>
          <var>EInvalidGraphic</var> - exception handler for an invalid graphic</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="EInvalidGraphicOperation">
        <short>
          <var>EInvalidGraphicOperation</var> - exception handler for invalid graphic operation</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TCanvas">
        <short>
          <var>TCanvas</var> - where most of the drawing is performed</short>
        <descr>
          <var>TCanvas</var> is a class that defines a very large number of drawing methods including methods for pen and colour selection, producing shapes and filling them, setting or clearing individual pixels, and producing graphic text.
</descr>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FAutoRedraw">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FState">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FFont">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FSavedFontHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FPen">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FSavedPenHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FBrush">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FSavedBrushHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FRegion">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FSavedRegionHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FPenPos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FCopyMode">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FOnChange">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FOnChanging">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FTextStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FLock">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FLockCount">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCanvas.BrushChanged">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.BrushChanged.ABrush">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCanvas.FontChanged">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.FontChanged.AFont">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCanvas.PenChanged">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.PenChanged.APen">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCanvas.RegionChanged">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RegionChanged.ARegion">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TCanvas.GetColor">
        <short>
          <var>GetColor</var> - finds the Color of the pixels at x, y and returns the value converted to a FPColor</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.GetColor">TFPCustomCanvas.GetColor</link>
        </seealso>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.GetColor.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TCanvas.GetHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.GetHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TCanvas.GetPenPos">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.GetPenPos.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCanvas.SetAutoRedraw">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetAutoRedraw.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCanvas.SetBrush">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetBrush.value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCanvas.SetColor">
        <short>
          <var>SetColor</var> converts the specified FPColor to a Color and applies it to the pixels at x, y</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.SetColor">TFPCustomCanvas.SetColor</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetColor.c">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCanvas.SetFont">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetFont.value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCanvas.SetPen">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetPen.value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCanvas.SetPenPos">
        <short>
          <var>SetPenPos</var> moves pen to specified position</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.SetPenPos">TFPCustomCanvas.SetPenPos</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetPenPos.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCanvas.SetRegion">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetRegion.Value">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCanvas.GetCanvasClipRect">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.GetCanvasClipRect.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCanvas.GetPixel">
        <short>
          <var>GetPixel</var> - retuns the colour of the pixel at the specified location</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.GetPixel.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.GetPixel.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.GetPixel.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.CreateBrush">
        <short>
          <var>CreateBrush</var> creates necessary handles, sets up local defaults for style, hatching, background colour</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.CreateBrush">TFPCustomCanvas.CreateBrush</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#fcl.FPCanvas.TFPCustomCanvas.CreateFont" name="TCanvas.CreateFont">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.CreateHandle">
        <short>
          <var>CreateHandle</var> - greates a new Handle for the Canvas</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.CreatePen">
        <short>
          <var>CreatePen</var> sets up local handles and defaults for Pen creation, sets initial position of Pen</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.CreatePen">TFPCustomCanvas.CreatePen</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.CreateRegion">
        <short>
          <var>CreateRegion</var> - creates a rectangular region for the Canvas</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DeselectHandles">
        <short>
          <var>DeselectHandles</var> - remove  from group of selected handles</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.PenChanging">
        <short>
          <var>PenChanging</var>
          <var/> - software emulation for call to 
          <var>OnChanging</var> event for Pen</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.PenChanging.APen">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.RealizeAutoRedraw">
        <short>
          <var>RealizeAutoRedraw</var> - implement the AutoDraw feature</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.RequiredState">
        <short>
          <var>RequiredState</var> - the set of Canvas State required (csHandleValid, csFontValid, csPenvalid, csBrushValid, csRegionValid)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RequiredState.ReqState">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.SetHandle">
        <short>
          <var>SetHandle</var> - specify a Handle</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetHandle.NewHandle">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.SetInternalPenPos">
        <short>
          <var>SetInternalPenPos</var> - specify position for the Pen</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetInternalPenPos.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.SetPixel">
        <short>
          <var>SetPixel</var> - specify a colour for the stated pixel</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetPixel.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetPixel.Y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetPixel.Value">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TCanvas.Create">
        <descr>
          <p>
            <var>Create</var> - constructor for 
            <var>TCanvas</var>: calls inherited 
            <var>Create</var> and sets defaults for many properties and actions</p>
          <p>Initialises Font, Pen and Brush, makes event handlers for these, sets up defaults for Alignment, Layout, Clipping and opacity</p>
        </descr>
        <short>
          <var>Create</var> - constructor for 
          <var>TCanvas</var>: calls inherited 
          <var>Create</var> and sets defaults for many properties and actions</short>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.Create">TFPCustomCanvas.Create</link>
        </seealso>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TCanvas.Destroy">
        <descr>
          <var>TCanvas</var> and makes its resources available
</descr>
        <short>
          <var>Destroy</var> - destructor for 
          <var>TCanvas</var>: frees handles and region, calls inherited 
          <var>Destroy</var>, sets font, pen and brush resources to nil</short>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.Destroy">TFPCustomCanvas.Destroy</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Lock">
        <short>
          <var>Lock</var>  the canvas, making it unavailble for drawing</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Unlock">
        <short>
          <var>Unlock</var> or release a previously locked Canvas</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Refresh">
        <short>
          <var>Refresh</var> the drawing of the Canvas</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Changing">
        <short>
          <var>Changing</var> - software emulation of a call to the 
          <var>OnChanging</var> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Changed">
        <short>
          <var>Changed</var> - software emulation of a call to the 
          <var>OnChange</var> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Arc">
        <short>Use <var>Arc</var>   to draw an elliptically curved line with the current Pen</short>
        <descr>Method:   TCanvas.Arc<br/>

Params:   ALeft, ATop, ARight, ABottom, sx, sy, ex, ey<br/>

Returns:  Nothing<br/><br/>

Use Arc to draw an elliptically curved line with the current Pen. The values sx,sy, and ex,ey represent the starting and ending radial-points between which the Arc is drawn.</descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.x">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.width">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.height">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.angle1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.angle2">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Arc">
        <short>Use <var>Arc</var>  to draw an elliptically curved line with the current Pen</short>
        <descr>Method:   TCanvas.Arc<br/>

Params:   ALeft, ATop, ARight, ABottom, angle1, angle2<br/>

Returns:  Nothing<br/><br/>

Use Arc to draw an elliptically curved line with the current Pen.<br/>

The angles angle1 and angle2 are 1/16th of a degree. <br/>

For example, a full  circle equals 5760 (16*360). <br/>

Positive values of <var>Angle</var>
 and <var>AngleLength</var>
 mean counter-clockwise while negative values mean clockwise direction.<br/>

Zero degrees is at the 3 o'clock position.</descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.x">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.width">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.height">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.SX">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.SY">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.EX">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.EY">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.BrushCopy">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.BrushCopy.Dest">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.BrushCopy.InternalImages">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.BrushCopy.Src">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.BrushCopy.TransparentColor">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Chord">
        <descr>
          <p>Params:   x1, y1, x2, y2, StartAngle16Deg, EndAngle16Deg</p>
          <p>Use Chord to draw a filled Chord-shape on the canvas. </p>
          <p>The angles angle1 and angle2 are 1/16th of a degree. For example, a full circle equals 5760(16*360). </p>
          <p>Positive values of Angle and AngleLength mean counter-clockwise while negative values mean clockwise direction. Zero degrees is at the 3 o'clock position.</p>
          <p>Alternatively the starting and ending points may be specified as radial points (sx, sy, ex, ey)</p>
        </descr>
        <short>Draw a filled-chord shape starting and finishing at the specified angular positions on the circumference</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.x">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.Width">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.Height">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.StartAngle16Deg">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.EndAngle16Deg">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Chord">
        <short>
          <var>Chord</var>  draws a filled Chord-shape on the canvas</short>
        <descr>Method:   TCanvas.Chord<br/>



Params:   x1, y1, x2, y2, StartAngle16Deg, EndAngle16Deg<br/>



Returns:  Nothing<br/><br/>



Use <var>Chord</var>


 to draw a filled Chord-shape on the canvas. The angles <var>angle1</var>


 and <var>angle2</var>


 are 1/16th of a degree. For example, a full circle equals 5760(16*360).<br/>



Positive values of <var>Angle</var>


 and <var>AngleLength</var>


 mean counter-clockwise while negative values mean clockwise direction. <br/>



Zero degrees is at the 3 o'clock position.</descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.x">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.Width">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.Height">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.SX">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.SY">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.EX">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.EY">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.CopyRect">
        <short>Copies the rectangle found at <var>Source</var> in <var>SrcCanvas</var> to the destination position <var>Dest</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.CopyRect">TFPCustomCanvas.CopyRect</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.CopyRect.Dest">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.CopyRect.SrcCanvas">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.CopyRect.Source">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Draw">
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.Draw">TFPCustomCanvas.Draw</link>
          <link id="#LCL.Graphics.TCanvas.StretchDraw">TCanvas.StretchDraw</link>
        </seealso>
        <short>
          <var>Draw</var> - copies bounds from 
          <var>SrcGraphic</var>, then calls 
          <var>StretchDraw</var> to perform the drawing</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Draw.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Draw.Y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Draw.SrcGraphic">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.StretchDraw">
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.StretchDraw">TFPCustomCanvas.StretchDraw</link>
          <link id="#LCL.Graphics.TGraphic.Draw">TGraphic.Draw</link>
        </seealso>
        <short>
          <var>StretchDraw</var> - uses the 
          <var>Draw</var> method of the source graphic (
          <var>TGraphic</var>)</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.StretchDraw.DestRect">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.StretchDraw.SrcGraphic">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Ellipse">
        <descr/>
        <short>
          <var>Ellipse</var> draws a filled circle or ellipse on the canvas, using the method for the current interface or widget set</short>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.Ellipse">TFPCustomCanvas.Ellipse</link>
          <link id="#LCL.LCLIntf.Ellipse">LCLIntf.Ellipse</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Ellipse.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Ellipse">
        <short>
          <var>Ellipse</var>  draws a filled circle or ellipse on the canvas</short>
        <descr>Method:   TCanvas.Ellipse<br/>

		      Params:   X1, Y1, X2, Y2<br/>

Returns:  Nothing<br/><br/>
Use <var>Ellipse</var>
 to draw a filled circle or ellipse on the canvas.</descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Ellipse.x1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Ellipse.y1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Ellipse.x2">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Ellipse.y2">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.FillRect">
        <short>
          <var>FillRect</var> - draw a filled rectangle in the specified coordinate space, using the method for the current interface or widget set</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.LCLIntf.FillRect">LCLIntf.FillRect</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.FillRect.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.FillRect">
        <short>
          <var>FillRect</var> - draw a filled rectangle in the specified coordinate space</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.FillRect.X1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.FillRect.Y1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.FillRect.X2">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.FillRect.Y2">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.FloodFill">
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.FloodFill">TFPCustomCanvas.FloodFill</link>
          <link id="#LCL.LCLIntf.FloodFill">LCLIntf.FloodFill</link>
        </seealso>
        <short>
          <var>FloodFill</var> flood-fills an area with the given colour, starting from the specified point; uses the 
          <var>FloodFill</var> method for the current interface or widget set</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.FloodFill.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.FloodFill.Y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.FloodFill.FillColor">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.FloodFill.FillStyle">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Frame3d">
        <short>
          <var>Frame3d</var> - produce a frame with 3-D effect (with bevelled edges etc) in the specified rectangle</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.LCLIntf.Frame3d">LCLIntf.Frame3d</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Frame3d.ARect">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Frame3d.FrameWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Frame3d.Style">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Frame">
        <short>Produce a <var>Frame</var> or border around the specified rectangle with a Pen; uses the <var>Frame</var> method of the current interface or widget set</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.LCLIntf.Frame">LCLIntf.Frame</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Frame.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Frame">
        <short>Produce a <var>Frame</var> or border around the specified rectangle using a Pen</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Frame.X1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Frame.Y1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Frame.X2">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Frame.Y2">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.FrameRect">
        <short>
          <var>FrameRect</var> - produce a border around the specified rectangle with a Brush; uses the 
          <var>FrameRect</var> method of the current interface or widget set</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.LCLIntf.FrameRect">LCLIntf.FrameRect</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.FrameRect.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.FrameRect">
        <short>
          <var>FrameRect</var> - produce a border around the specified rectangle using a Brush</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.FrameRect.X1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.FrameRect.Y1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.FrameRect.X2">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.FrameRect.Y2">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#fcl.FPCanvas.TFPCustomCanvas.Line" name="TCanvas.Line"/>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Line.X1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Line.Y1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Line.X2">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Line.Y2">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#fcl.FPCanvas.TFPCustomCanvas.LineTo" name="TCanvas.LineTo"/>
      <!-- argument Visibility: default -->
      <element name="TCanvas.LineTo.X1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.LineTo.Y1">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#fcl.FPCanvas.TFPCustomCanvas.MoveTo" name="TCanvas.MoveTo"/>
      <!-- argument Visibility: default -->
      <element name="TCanvas.MoveTo.X1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.MoveTo.Y1">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.RadialPie">
        <short>
          <var>RadialPie</var> - draw a filled pie-shaped wedge on the canvas with specified start and end coordinates, and starting and ending angular positions</short>
        <seealso>
          <link id="TCanvas.Pie"/>
        </seealso>
        <short>
          <var>RadialPie</var> - draw a filled pie-shaped wedge on the canvas with specified start and end coordinates, and starting and ending angular positions</short>
        <descr>
          <p>Params:   x1, y1, x2, y2, StartAngle16Deg, EndAngle16Deg: Integer</p>
          <p>Use Pie to draw a filled pie-shaped wedge on the canvas.</p>
          <p>The angles StartAngle16Deg and EndAngle16Deg are 1/16th of a degree. For example, a full circle equals 5760 (16*360).</p>
          <p>Positive values of Angle and AngleLength mean counter-clockwise while negative values mean clockwise direction. Zero degrees is at the 3 o'clock position.</p>
        </descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.x">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.Width">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.Height">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.StartAngle16Deg">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.EndAngle16Deg">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.RadialPie">
        <short>
          <var>RadialPie</var> uses 
          
          
          
          
          
          
          
          <var>Pie</var>    to draw a filled pie-shaped wedge on the canvas</short>
        <descr>Method:   TCanvas.RadialPie<br/>




Params:   x1, y1, x2, y2, StartAngle16Deg, EndAngle16Deg: Integer<br/>




Returns:  Nothing<br/><br/>




Uses <var>Pie</var>



 to draw a filled pie-shaped wedge on the canvas.<br/>




The angles <var>StartAngle16Deg</var>



 and <var>EndAngle16Deg</var>



 are 1/16th of a degree.<br/>




For example, a full circle equals 5760 (16*360).<br/>




Positive values of Angle and AngleLength mean counter-clockwise while negative values mean clockwise direction.<br/>




Zero degrees is at the 3 o'clock position</descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.x">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.Width">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.Height">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.sx">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.sy">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.ex">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.ey">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Pie">
        <short>
          <var>Pie</var>  draws a filled Pie-shaped wedge on the canvas</short>
        <descr>Method:   TCanvas.Pie<br/>

Params:   EllipseX1, EllipseY1, EllipseX2, EllipseY2, StartX, StartY, EndX, EndY<br/>

Returns:  Nothing<br/><br/>

Use <var>Pie</var>
 to draw a filled Pie-shaped wedge on the canvas. The pie is part of an ellipse between the points EllipseX1, EllipseY1, EllipseX2, EllipseY2. The values StartX, StartY and EndX, EndY represent the starting and ending radial-points between which the Bounding-Arc is drawn. <br/>
        </descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Pie.EllipseX1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Pie.EllipseY1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Pie.EllipseX2">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Pie.EllipseY2">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Pie.StartX">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Pie.StartY">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Pie.EndX">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Pie.EndY">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.PolyBezier">
        <short>
          <var>Polybezier</var>    draws cubic Bezier curves</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.PolyBezier.Points">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.PolyBezier.NumPts">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.PolyBezier.Filled">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.PolyBezier.Continuous">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.PolyBezier">
        <short>
          <var>Polybezier</var>    draws cubic Bezier curves</short>
        <descr>Method:  TCanvas.PolyBezier<br/>



Params:  Points, Filled, Continous<br/>



Returns: Boolean<br/><br/>



Use <var>Polybezier</var>


 to draw cubic Bezier curves. <br/>



The first curve is drawn from the first point to the fourth point with the second and third points being the control points. <br/>



If the Continuous flag is TRUE then each subsequent curve requires three more points, using the end-point of the previous Curve as its starting point, the first and second points being used as its control points, and the third point its end-point. <br/><br/>



If the continous flag is set to FALSE, then each subsequent Curve requires 4 additional points, which are used exactly as in the first curve. <br/><br/>



Any additonal points which do not add up to a full bezier(4 for Continuous, 3 otherwise) are ingored. There must be at least 4 points for an drawing to occur. <br/><br/>



If the Filled Flag is set to TRUE then the resulting Poly-Bezier will be drawn as a Polygon.</descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.PolyBezier.Points">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.PolyBezier.Filled">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.PolyBezier.Continuous">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Polygon">
        <short>
          <var>Polygon</var>    draws a closed, many-sided shape on the canvas, using the value   of Pen</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Polygon.Points">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Polygon.Winding">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Polygon.StartIndex">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Polygon.NumPts">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Polygon"/>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Polygon.Points">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Polygon.NumPts">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Polygon.Winding">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Polygon">
        <short>
          <var>Polygon</var>    draws a closed, many-sided shape on the canvas, using the value   of Pen</short>
        <descr>Method:   TCanvas.Polygon<br/>





Params:   Points: array of TPoint; Winding: Boolean = False; StartIndex: Integer = 0; NumPts: Integer = -1<br/>





Returns:  Nothing<br/><br/>





Use <var>Polygon</var>




 to draw a closed, many-sided shape on the canvas, using the value of <var>Pen</var>




. After drawing the complete shape, <var>Polygon</var>




 fills the shape using the value of <var>Brush</var>




.<br/><br/>





The <var>Points</var>




 parameter is an array of points that give the vertices of the polygon.<br/><var>Winding</var>




 determines how the polygon is filled. When <var>Winding</var>




 is True, <var>Polygon</var>





  fills the shape using the <var>Winding</var>




 fill algorithm. <br/>





When <var>Winding</var>




 is False, <var>Polygon</var>




 uses the even-odd (alternative) fill algorithm.<br/><var>StartIndex</var>




 gives the index of the first point in the array to use. All points before this are ignored.<br/><var>NumPts</var>




 indicates the number of points to use, starting at <var>StartIndex</var>




.<br/>





If <var>NumPts</var>




 is -1 (the default), <var>Polygon</var>




 uses all points from <var>StartIndex</var>




 to the end of the array.<br/>





The first point is always connected to the last point.<br/>





To draw a polygon on the canvas, without filling it, use the <var>Polyline</var>




 method,  specifying the first point a second time at the end.</descr>
        <seealso>
          <link id="TCanvas.PolyLine"/>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Polygon.Points">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Polyline">
        <short>
          <var>Polyline</var>    connects a set of points on the canvas</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Polyline.Points">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Polyline.StartIndex">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Polyline.NumPts">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Polyline">
        <short>
          <var>Polyline</var>    connects a set of points on the canvas</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Polyline.Points">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Polyline.NumPts">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Polyline">
        <short>
          <var>Polyline</var>    connects a set of points on the canvas</short>
        <descr>Method:   TCanvas.Polyline<br/>






Params:   Points: array of TPoint; StartIndex: Integer = 0; NumPts: Integer = -1<br/>






Returns:  Nothing<br/><br/>






Use <var>Polyline</var>





 to connect a set of points on the <var>Canvas</var>





. If you specify only two points, <var>Polyline</var>





 draws a single line.<br/>






The <var>Points</var>





 parameter is an array of points to be connected.<br/><var>StartIndex</var>





 identifies the first point in the array to use.<br/><var>NumPts</var>





 indicates the number of points to use. If <var>NumPts</var>





 is -1 (the default), <var>PolyLine</var>





 uses all the points from <var>StartIndex</var>





 to the end of the array.<br/>






Calling the <var>MoveTo</var>





 function with the value of the first point, and then repeatedly calling <var>LineTo</var>





 with all subsequent points will draw the same image on the canvas. However, unlike <var>LineTo</var>





, <var>Polyline</var>





 does not change the value of <var>PenPos</var>





.</descr>
        <seealso>
          <link id="TCanvas.MoveTo"/>
          <link id="TCanvas.LineTo"/>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Polyline.Points">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Rectangle">
        <short>Draws a <var>Rectangle</var> at the specified coordinates, using the <var>Rectangle</var> method for the current interface or widget set</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#FCL.FPCanvas.TFPCustomCanvas.Rectangle">TFPCustomCanvas.Rectangle</link>
          <link id="#LCL.LCLIntf.Rectangle">LCLIntf.Rectangle</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Rectangle.X1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Rectangle.Y1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Rectangle.X2">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Rectangle.Y2">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.Rectangle">
        <short>Draws a <var>Rectangle</var> at the specified coordinates</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Rectangle.Rect">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.RoundRect">
        <short>
          <var>RoundRect</var> - draws a rectangle at the specified position, with corners rounded by the factors RX, RY; uses the 
          <var>RoundRect</var> mathod of the current interface or widget set</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.LCLIntf.RoundRect">LCLIntf.RoundRect</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RoundRect.X1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RoundRect.Y1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RoundRect.X2">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RoundRect.Y2">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RoundRect.RX">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RoundRect.RY">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.RoundRect">
        <short>
          <var>RoundRect</var> - draws a rectangle at the specified position, with corners rounded by the factors RX, RY</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RoundRect.Rect">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RoundRect.RX">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RoundRect.RY">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.TextOut">
        <short>Writes the <var>Text</var> string at the position <var>X, Y</var> on the canvas and leaves the pen at the end of the text; uses the <var>ExtUTF8Out</var> method of the current interface or widget set</short>
        <seealso>
          <link id="#LCL.LCLIntf.ExtUTF8Out">LCLIntf.ExtUTF8Out</link>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.TextOut">TFPCustomCanvas.TextOut</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.TextOut.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.TextOut.Y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.TextOut.Text">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.TextRect">
        <short>
          <var>TextRect</var> - writes the specified text string in the rectangle at specified position, with optionally specified style</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.TextRect.ARect">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.TextRect.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.TextRect.Y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.TextRect.Text">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.TextRect">
        <short>Writes <var>Text</var> string within a specified rectangle, according to predefined <var>Style</var>
        </short>
        <descr>Writes <var>Text</var> string within a specified rectangle, according to predefined <var>Style</var><br/>
The boundaries of the rectangle are specified in <var>ARect</var><br/><var>X, Y</var> specify the starting point for writing the <var>Text</var> within the rectangle <br/><var>TextStyle</var> determines whether the text is justified, centered, word-wrapped etc. If the <var>Style</var> argument is omitted, defaults are assumed</descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.TextRect.ARect">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.TextRect.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.TextRect.Y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.TextRect.Text">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.TextRect.Style">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TCanvas.TextExtent">
        <short>
          <var>TextExtent</var> - returns the total size of the specified text</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.TextExtent.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.TextExtent.Text">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TCanvas.TextHeight">
        <short>
          <var>TextHeight</var> - returns the height of the specified text</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.TextHeight.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.TextHeight.Text">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TCanvas.TextWidth">
        <short>
          <var>TextWidth</var> - returns the width of the specified text</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.TextWidth.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.TextWidth.Text">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TCanvas.HandleAllocated">
        <short>
          <var>HandleAllocated</var> - returns True if a handle has been allocated</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.HandleAllocated.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TCanvas.GetUpdatedHandle">
        <short>
          <var>GetUpdatedHandle</var> - returns the value of the updated Handle</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.GetUpdatedHandle.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.GetUpdatedHandle.ReqState">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCanvas.ClipRect">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCanvas.PenPos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCanvas.Pixels">
        <short>The colour of the <var>Pixels</var> located at the specified position</short>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Pixels.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Pixels.Y">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCanvas.Handle">
        <short>The operating system <var>Handle</var> for this object</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCanvas.TextStyle">
        <short>The <var>TextStyle</var> to be used in this Canvas</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCanvas.LockCount">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TCanvas.AutoRedraw">
        <short>
          <var>AutoRedraw</var> - if True, the Canvas is to be redrawn automatically after each change or update</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TCanvas.Brush">
        <short>The <var>Brush</var> to be used for painting this Canvas</short>
        <descr/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.Brush">TFPCustomCanvas.Brush</link>
        </seealso>
      </element>
      <!-- property Visibility: published -->
      <element name="TCanvas.CopyMode">
        <short>The <var>CopyMode</var> to be used (arbitrary number)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TCanvas.Font">
        <descr/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.Font">TFPCustomCanvas.Font</link>
        </seealso>
        <short>The <var>Font</var> to be used for text in this canvas</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TCanvas.Pen">
        <descr/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.Pen">TFPCustomCanvas.Pen</link>
        </seealso>
        <short>The <var>Pen</var> to be used for writing in this canvas</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TCanvas.Region">
        <short>The <var>Region</var>where the Canvas is located</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TCanvas.Color">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TCanvas.OnChange">
        <short>Event handler for a change in the canvas</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TCanvas.OnChanging">
        <short>Event handler while canvas is changing</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TSharedImage">
        <short>
          <var>TSharedImage</var> -  base class for reference counted images</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSharedImage.FRefCount">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSharedImage.Reference">
        <short>Increase reference count</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSharedImage.Release">
        <short>Decrease reference count</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSharedImage.FreeHandle">
        <short>Release the handle for this image and free its resources</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TSharedImage.RefCount">
        <short>The number of references to this shared image</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TSharedImage.HandleAllocated">
        <short>Has a handle been allocated for this image?</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSharedImage.HandleAllocated.Result">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TBitmapNativeType">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TBitmapNativeType.bnNone">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TBitmapNativeType.bnWinBitmap">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TBitmapNativeType.bnXPixmap">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TBitmapNativeType.bnIcon">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TBitmapNativeTypes">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TBitmapHandleType">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TBitmapHandleType.bmDIB">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TBitmapHandleType.bmDDB">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TBitmapImage">
        <short>The place where the actual image of a bitmap is stored</short>
        <descr>
          <p>Descendant of TSharedImage for TBitmap.</p>
          <var>If a TBitmap is assigned to another TBitmap, only the reference count will be increased and both will share the same TBitmapImage</var>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBitmapImage.FHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBitmapImage.FMaskHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBitmapImage.FPalette">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBitmapImage.FDIBHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBitmapImage.FSaveStream">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBitmapImage.FSaveStreamType">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmapImage.FreeHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmapImage.FreeMaskHandle">
        <short>Release the handle for the bitmap mask</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TBitmapImage.ReleaseHandle">
        <short>Release the bitmap handle</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmapImage.ReleaseHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TBitmapImage.IsEmpty">
        <short>Is the bitmap image empty?</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmapImage.IsEmpty.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TBitmapImage.GetPixelFormat">
        <short>Find the format for the pixels (ie the number of bits per pixel)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmapImage.GetPixelFormat.Result">
        <short/>
      </element>
      <!-- variable Visibility: public -->
      <element name="TBitmapImage.FDIB">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TBitmapImage.Destroy">
        <short>BitmapImage destructor</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TBitmapImage.HandleAllocated">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmapImage.HandleAllocated.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TBitmapImage.GetHandleType">
        <short>Determine the type of the bitmap handle</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmapImage.GetHandleType.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TBitmapImage.SaveStream">
        <short>The stream to which the data are to be saved</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TBitmapImage.SaveStreamType">
        <short>The type of the stream for saving the data</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TBitmapInternalStateFlag">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TBitmapInternalStateFlag.bmisCreatingCanvas">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TBitmapInternalState">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TBitmap">
        <short>
          <var>TBitmap</var> is the data of an image, and can be loaded from a file, stream or resource in .bmp  or .xpm format</short>
        <descr>
          <p>
            <var>TBitmap</var> is the data of an image. The image can be loaded from a file, stream or resource in .bmp (windows bitmap format) or .xpm (XPixMap format)</p>
          <p>The loading routine automatically recognizes the format, so it is also used to load the images from Delphi form streams (e.g. .dfm files) or FreePascal/Lazarus form streams (.lfm)</p>
          <p>When the handle is created, it is up to the interface (gtk, win32, ...) to convert it automatically to the best internal format. That is why the <var>Handle</var> is interface dependent.</p>
          <p>To access the raw data, see <link id="#lcl.IntfGraphics.TLazIntfImage">TLazIntfImage</link>
          </p>
        </descr>
        <seealso>
          <link id="#lcl.IntfGraphics.TLazIntfImage"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBitmap.FCanvas">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBitmap.FImage">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBitmap.FPalette">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBitmap.FPixelFormat">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBitmap.FTransparentColor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBitmap.FTransparentMode">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBitmap.FInternalState">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TBitmap.FreeCanvasContext">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TBitmap.GetCanvas">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetCanvas.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TBitmap.CreateCanvas">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TBitmap.GetMonochrome">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetMonochrome.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TBitmap.SetHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.SetHandle.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TBitmap.SetMaskHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.SetMaskHandle.NewMaskHandle">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TBitmap.GetHandleType">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetHandleType.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TBitmap.SetHandleType">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.SetHandleType.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TBitmap.SetMonochrome">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.SetMonochrome.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TBitmap.SetPixelFormat">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.SetPixelFormat.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TBitmap.UpdatePixelFormat">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.Changed">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.Changed.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.Changing">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.Changing.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.Draw">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.Draw.DestCanvas">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.Draw.DestRect">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TBitmap.GetEmpty">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetEmpty.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TBitmap.GetHeight">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TBitmap.GetPalette">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetPalette.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TBitmap.GetWidth">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TBitmap.GetHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TBitmap.GetMaskHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetMaskHandle.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.HandleNeeded">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.MaskHandleNeeded">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.PaletteNeeded">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.UnshareImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.UnshareImage.CopyContent">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.FreeSaveStream">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.ReadData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.ReadData.Stream">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.SetWidthHeight">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.SetWidthHeight.NewWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.SetWidthHeight.NewHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.SetHeight">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.SetHeight.NewHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.SetPalette">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.SetPalette.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.SetTransparentMode">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.SetTransparentMode.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.SetWidth">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.SetWidth.NewWidth">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.WriteData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.WriteData.Stream">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.StoreOriginalStream">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.StoreOriginalStream.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.StoreOriginalStream.Size">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.WriteStreamWithFPImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.WriteStreamWithFPImage.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.WriteStreamWithFPImage.WriteSize">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.WriteStreamWithFPImage.WriterClass">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.InitFPImageReader">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.InitFPImageReader.ImgReader">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.InitFPImageWriter">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.InitFPImageWriter.ImgWriter">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.FinalizeFPImageReader">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.FinalizeFPImageReader.ImgReader">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.FinalizeFPImageWriter">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.FinalizeFPImageWriter.ImgWriter">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TBitmap.Create">
        <short>
          <var>BitMap</var> constructor</short>
        <descr>
          <var>BitMap</var> constructor. The supplied code can 
          
          
          
          
          
          
          
          <b>override</b> the definition from ancestor classes</descr>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TBitmap.Destroy">
        <short>
          <var>BitMap</var> destructor</short>
        <descr>
          <var>BitMap</var> destructor. The supplied code can 
          
          
          
          
          
          
          
          <b>override</b> the method defined for ancestor classes</descr>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBitmap.Assign">
        <short>
          <var>Assign</var>: find out about the Source of the call.</short>
        <descr>
          <var>Assign</var>: find out about the Source of the call. If the 
          
          
          
          
          
          
          
          <var>BitMap</var> data are already in use, the data are shared; if not, a new 
          
          
          
          
          
          
          
          <var>BitMap</var> is produced</descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.Assign.Source">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBitmap.FreeImage">
        <short>Release (remove) the image, freeing the resources used</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TBitmap.HandleAllocated">
        <short>Is a handle allocated for this bitmap?</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.HandleAllocated.Result">
        <short>Returns TRUE if a handle has been allocated</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TBitmap.MaskHandleAllocated">
        <short>Is a handle allocated for the bitmap mask?</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.MaskHandleAllocated.Result">
        <short>Returns TRUE if a mask handle has been allocated</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TBitmap.PaletteAllocated">
        <short>Has a colour palette been allocated for this bitmap?</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.PaletteAllocated.Result">
        <short>Returns TRUE if a colour palette has been allocated</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBitmap.CreateFromBitmapHandles">
        <short>Create an image in the specified rectangle, using the given bitmap and mask handles</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.CreateFromBitmapHandles.SrcBitmap">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.CreateFromBitmapHandles.SrcMaskBitmap">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.CreateFromBitmapHandles.SrcRect">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBitmap.LoadFromDevice">
        <short>
          <var>LoadFromDevice</var>: obtain 
          
          
          
          
          
          
          
          <var>BitMap</var> data from a device with Handle 
          
          
          
          
          
          
          
          <var>DC</var>
        </short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.LoadFromDevice.DC">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TBitmap.LazarusResourceTypeValid">
        <short>Checks that the Resource Type specified in the string argument is a valid Lazarus type</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.LazarusResourceTypeValid.Result">
        <short>Returns TRUE if a valid resource type is found</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.LazarusResourceTypeValid.ResourceType">
        <short>The target resource type specified as a string</short>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Graphics.TRasterImage.LoadFromStream" name="TBitmap.LoadFromStream"/>
      <!-- argument Visibility: default -->
      <element name="TBitmap.LoadFromStream.Stream">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBitmap.LoadFromLazarusResource">
        <short>
          <var>LoadFromLazarusResource</var>: obtain data from a valid Lazarus Resource Stream</short>
        <descr>
          <var>LoadFromLazarusResource</var>: obtain data from a valid Lazarus Resource Stream
          
          
          
          
          
          
          
          <br/>
Checks for the presence of a valid Lazarus Resource, then uses 
          
          
          
          
          
          
          
          <var>LoadFromStream</var> to acquire the data</descr>
        <seealso>
          <link id="TBitmap.LoadFromStream"/>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.LoadFromLazarusResource.ResName">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBitmap.LoadFromResourceName">
        <short>
          <var>ToDo</var>
        </short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.LoadFromResourceName.Instance">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.LoadFromResourceName.ResName">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBitmap.LoadFromResourceID">
        <short>
          <var>ToDo</var>
        </short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.LoadFromResourceID.Instance">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.LoadFromResourceID.ResID">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBitmap.LoadFromMimeStream">
        <short>
          <var>LoadFromMimeStream</var> - get 
          
          
          
          
          
          
          
          <var>Bitmap </var>data from the specified MIME stream</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.LoadFromMimeStream.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.LoadFromMimeStream.MimeType">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBitmap.GetSupportedSourceMimeTypes">
        <short>Gets a list of the supported MIME types for the source file</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.GetSupportedSourceMimeTypes.List">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TBitmap.GetDefaultMimeType">
        <short>Finds the default MIME type</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetDefaultMimeType.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TGraphic.GetFileExtensions" name="TBitmap.GetFileExtensions">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetFileExtensions.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBitmap.LoadFromXPMFile">
        <short>
          <var>LoadFromXPMFile</var>: obtain data from file in native 
          
          
          
          
          
          
          
          <var>PixMap</var> format</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.LoadFromXPMFile.Filename">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBitmap.Mask">
        <short>Masks the bitmap using a transparent colour</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.Mask.ATransparentColor">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBitmap.SaveToStream">
        <short>Saves bitmap data to a stream</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.SaveToStream.Stream">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBitmap.ReadStream">
        <short>Reads data from a stream</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.ReadStream.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.ReadStream.UseSize">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.ReadStream.Size">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBitmap.WriteStream">
        <short>Writes data to a stream</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.WriteStream.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.WriteStream.WriteSize">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TBitmap.ReleaseHandle">
        <short>Release the bitmap handle, effectively freeing resources</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.ReleaseHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TBitmap.ReleasePalette">
        <short>Release the current palette</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.ReleasePalette.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TBitmap.GetFPReaderForFileExt">
        <short>Get the appropriate FPReader for the given file extension</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetFPReaderForFileExt.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.GetFPReaderForFileExt.FileExtension">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TBitmap.GetFPWriterForFileExt">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetFPWriterForFileExt.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.GetFPWriterForFileExt.FileExtension">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TBitmap.GetDefaultFPReader">
        <short>Get the default FPReader</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetDefaultFPReader.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TBitmap.GetDefaultFPWriter">
        <short>Get the default FPWriter</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetDefaultFPWriter.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBitmap.ReadStreamWithFPImage">
        <short>Read Bitmap data from stream using the FPImage reader</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.ReadStreamWithFPImage.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.ReadStreamWithFPImage.UseSize">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.ReadStreamWithFPImage.Size">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.ReadStreamWithFPImage.ReaderClass">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBitmap.WriteNativeStream">
        <short>Write bitmap data to a native stream</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.WriteNativeStream.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.WriteNativeStream.WriteSize">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.WriteNativeStream.SaveStreamType">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TBitmap.CreateIntfImage">
        <short>Create an interface image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.CreateIntfImage.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TBitmap.Canvas">
        <short>The canvas on which this bitmap is drawn</short>
        <descr>
          <p>The Canvas is where all the drawing and painting is performed.</p>
          <p>The properties are described in <link id="Controls.TCanvas">TCanvas</link>
          </p>
        </descr>
        <seealso>
          <link id="Graphics.TCanvas"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TBitmap.Handle">
        <short>The operating system Handle ssociated with this bitmap</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TBitmap.HandleType">
        <short>The type of system handle</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TBitmap.MaskHandle">
        <short>The system handle associated with the bitmap mask</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TBitmap.Monochrome">
        <short>Whether using monochrome display</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TBitmap.PixelFormat">
        <short>PixelFormat - number of bits per pixel</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TBitmap.TransparentColor">
        <short>The transparent colour used for masks etc</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TBitmap.TransparentMode">
        <short>The mode used for transparency</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TPixmap">
        <short>
          <var>PixMap</var>  - a class derived from  
          
          
          
          <var>TBitMap</var> , with wrapper to deal specifically with PixMaps (ie using 'XPM' format)</short>
        <descr>
          <var>PixMap</var>
  - Checks that specified resources (PixMap image, File for storage, Stream for writing) are of correct type and format, organises saving and writing
</descr>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TGraphic.LazarusResourceTypeValid" name="TPixmap.LazarusResourceTypeValid"/>
      <!-- function result Visibility: default -->
      <element name="TPixmap.LazarusResourceTypeValid.Result">
        <short>Returns True if resource type is 'XPM'</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPixmap.LazarusResourceTypeValid.ResourceType">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TPixmap.WriteStream">
        <short>
          <var>WriteStream</var> - writes PixMap data to specified stream</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPixmap.WriteStream.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPixmap.WriteStream.WriteSize">
        <short>
          <var>True</var> if size of data in stream has been specified</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TPixmap.GetDefaultFPReader">
        <short>
          <var>GetDefaultFPReader</var> - obtains the correct tool</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPixmap.GetDefaultFPReader.Result">
        <short>Returns the correct tool for reading</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TPixmap.GetDefaultFPWriter">
        <short>
          <var>GetDefaultFPWriter</var> -  obtains the correct tool</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPixmap.GetDefaultFPWriter.Result">
        <short>Returns the correct tool for writing</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TFPImageBitmap">
        <short>A class of Bitmap using the FPImage reader and writer (ie customised for FreePascal)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TGraphic.GetFileExtensions" name="TFPImageBitmap.GetFileExtensions">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFPImageBitmap.GetFileExtensions.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TFPImageBitmap.IsFileExtensionSupported">
        <short>
          <var>IsFileExtensionSupported</var> - returns True if the given file extension is supported?</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFPImageBitmap.IsFileExtensionSupported.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.IsFileExtensionSupported.FileExtension">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TFPImageBitmap.GetFPReaderForFileExt">
        <short>Get the FPReader tool appropriate to the given file extension</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFPImageBitmap.GetFPReaderForFileExt.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.GetFPReaderForFileExt.FileExtension">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TFPImageBitmap.GetFPWriterForFileExt">
        <short>Get the FPWriter tool appropriate for the given file extension</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFPImageBitmap.GetFPWriterForFileExt.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.GetFPWriterForFileExt.FileExtension">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TFPImageBitmap.GetDefaultFPReader">
        <short>Get the default FPReader, if no extension-specific tool</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFPImageBitmap.GetDefaultFPReader.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TFPImageBitmap.GetDefaultFPWriter">
        <short>Get the default FPWriter, if no extension-specific tool</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFPImageBitmap.GetDefaultFPWriter.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TGraphic.LazarusResourceTypeValid" name="TFPImageBitmap.LazarusResourceTypeValid">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFPImageBitmap.LazarusResourceTypeValid.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.LazarusResourceTypeValid.ResourceType">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TFPImageBitmap.ReadStream">
        <short>Read the data from a Stream</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Graphics.TRasterImage.ReadStream">TRasterImage.ReadStream</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.ReadStream.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.ReadStream.UseSize">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.ReadStream.Size">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TFPImageBitmap.WriteStream">
        <short>Write the data to a stream</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Graphics.TRasterImage.WriteStream">TRasterImage.WriteStream</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.WriteStream.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.WriteStream.WriteSize">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TFPImageBitmap.GetDefaultMimeType">
        <short>Get the default MIME type for this bitmap</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFPImageBitmap.GetDefaultMimeType.Result">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TPortableNetworkGraphic">
        <short>
          <var>TPortableNetworkGraphic</var> - a PNG image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TGraphic.GetFileExtensions" name="TPortableNetworkGraphic.GetFileExtensions">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPortableNetworkGraphic.GetFileExtensions.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TPortableNetworkGraphic.GetDefaultFPReader">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPortableNetworkGraphic.GetDefaultFPReader.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TPortableNetworkGraphic.GetDefaultFPWriter">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPortableNetworkGraphic.GetDefaultFPWriter.Result">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TIcon">
        <short>
          <var>TIcon</var>  - icons, small images typically associated with applications, controls, etc.</short>
        <descr>
          <p>Icons can be loaded from .ICO files, or from Lazarus resources.</p>
          <p>An icon resource typically contains several versions of the same image, in multiple resolutions and color depths. </p>
          <p>When loading, the largest/most colourful image is loaded as the <var>Bitmap</var> property, and so can be handled as any other bitmap.</p>
        </descr>
        <errors>Writing to icon files is not (yet) implemented.</errors>
      </element>
      <!-- variable Visibility: private -->
      <element name="TIcon.FBitmaps">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TIcon.ReadData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TIcon.ReadData.Stream">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TIcon.InitFPImageReader">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TIcon.InitFPImageReader.ImgReader">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TIcon.GetFileExtensions">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TIcon.GetFileExtensions.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TIcon.Bitmaps">
        <short>
          <var>Bitmaps</var> - the list of alternative bitmaps (of various sizes)</short>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TIcon.Destroy">
        <short>
          <var>TIcon</var> destructor</short>
        <descr>
          <var>TIcon</var> destructor. Method can 
          
          
          
          
          
          
          
          <b>override</b> the destructor defined in ancestor classes</descr>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TIcon.AddBitmap">
        <short>Add a bitmap to the current list</short>
        <descr>Note that Ownership passes to <var>TIcon</var>
        </descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TIcon.AddBitmap.Bitmap">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="GraphicFilter">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="GraphicFilter.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="GraphicFilter.GraphicClass">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="GraphicExtension">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="GraphicExtension.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="GraphicExtension.GraphicClass">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="GraphicFileMask">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="GraphicFileMask.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="GraphicFileMask.GraphicClass">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="GetGraphicClassForFileExtension">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="GetGraphicClassForFileExtension.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="GetGraphicClassForFileExtension.FileExt">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="GetFPImageReaderForFileExtension">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="GetFPImageReaderForFileExtension.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="GetFPImageReaderForFileExtension.FileExt">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="GetFPImageWriterForFileExtension">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="GetFPImageWriterForFileExtension.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="GetFPImageWriterForFileExtension.FileExt">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TGetColorStringProc">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGetColorStringProc.s">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="ColorToIdent">
        <short>ColorToIdent - given a Color value, find its name (<var>Ident</var>) in the look-up table of <var>Colors</var>
        </short>
      </element>
      <!-- function result Visibility: default -->
      <element name="ColorToIdent.Result">
        <short>Returns True if there is a valid entry in the <var>Colors</var> look-up table</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="ColorToIdent.Color">
        <short>the <var>Color</var> value to be sought in the look-up table</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="ColorToIdent.Ident">
        <short>
          <var>Ident </var>- the name of the supplied 
          
          
          <var>Color</var> as found in the look-up table of 
          
          
          <var>Colors</var>
        </short>
      </element>
      <!-- function Visibility: default -->
      <element name="IdentToColor">
        <short>
          <var>IdentToColor</var> - given a colour identifier (name) returns the colour value</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="IdentToColor.Result">
        <short>Returns True if <var>Ident</var> is part of a valid entry in the look-up table of <var>Colors</var>
        </short>
      </element>
      <!-- argument Visibility: default -->
      <element name="IdentToColor.Ident">
        <short>
          <var>Ident</var> - the suppied name for the required 
          
          
          <var>Color</var>
        </short>
      </element>
      <!-- argument Visibility: default -->
      <element name="IdentToColor.Color">
        <short>The <var>Color</var> returned from the look-up table, with the name supplied in <var>Ident</var>
        </short>
      </element>
      <!-- function Visibility: default -->
      <element name="SysColorToSysColorIndex">
        <short>
          <var>SysColorToSysColorIndex</var> - if 
          
          <var>Color</var> is one of the system colours, returns the 
          
          <var>Index</var> of the system colour</short>
        <errors>If <var>Color</var> is not a system color, returns -1</errors>
      </element>
      <!-- function result Visibility: default -->
      <element name="SysColorToSysColorIndex.Result">
        <short>Returns the Index value of the Color if it is a system colour, otherwise returns -1</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="SysColorToSysColorIndex.Color">
        <short>The <var>Color</var> for processing</short>
      </element>
      <!-- function Visibility: default -->
      <element name="ColorToRGB">
        <short>
          <var>ColorToRGB</var> - given a 
          
          
          <var>Color</var> value, converts into 
          
          
          <var>RGB</var>
        </short>
      </element>
      <!-- function result Visibility: default -->
      <element name="ColorToRGB.Result">
        <short>Returns the original <var>Color</var> transformed to <var>RGB</var>
        </short>
      </element>
      <!-- argument Visibility: default -->
      <element name="ColorToRGB.Color">
        <short>The original <var>Color</var> for processing</short>
      </element>
      <!-- function Visibility: default -->
      <element name="ColorToString">
        <short>
          <var>ColorToString</var> - given a colour value, returns a corresponding colour name like 'Green'</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="ColorToString.Result">
        <short>Returns the name of the colour, expressed as a string (like 'Green')</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="ColorToString.Color">
        <short>The <var>Color </var>value for processing</short>
      </element>
      <!-- function Visibility: default -->
      <element name="StringToColor">
        <short>
          <var>StringToColor</var> - given a colour name like 'Blue', returns the corresponding colour value</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="StringToColor.Result">
        <short>Returns the colour corresponding to the name in String <var>S</var>
        </short>
      </element>
      <!-- argument Visibility: default -->
      <element name="StringToColor.S">
        <short>
          <var>S </var>- the name of the required colour, expressed as a string</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="GetColorValues">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="GetColorValues.Proc">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="Blue">
        <short>Finds the <var>Blue</var> component of the supplied colour</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="Blue.Result">
        <short>Returns the Blue component of the colour specified in RGB</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="Blue.rgb">
        <short>The colour for processing, expressed as a RGB value</short>
      </element>
      <!-- function Visibility: default -->
      <element name="Green">
        <short>Finds the <var>Green</var> component of the supplied colour</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="Green.Result">
        <short>Returns the Green component of the colour specified in RGB</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="Green.rgb">
        <short>The colour for processing, expressed as RGB</short>
      </element>
      <!-- function Visibility: default -->
      <element name="Red">
        <short>Finds the <var>Red</var> component of the supplied colour</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="Red.Result">
        <short>Returns the Red component of the colour specified in <var>RGB</var>
        </short>
      </element>
      <!-- argument Visibility: default -->
      <element name="Red.rgb">
        <short>The colour for processing, expressed as RGB</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="RedGreenBlue">
        <short>
          <var>RedGreenBlue</var> - decomposes a composite colour into its component Red, Green and Blue values</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="RedGreenBlue.rgb">
        <short>The colour for processing, expressed as RGB</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="RedGreenBlue.Red">
        <short>The  <var>Red </var>component of the colour defined in <var>RGB</var>
        </short>
      </element>
      <!-- argument Visibility: default -->
      <element name="RedGreenBlue.Green">
        <short>The  <var>Green</var>component of the colour defined in <var>RGB</var>
        </short>
      </element>
      <!-- argument Visibility: default -->
      <element name="RedGreenBlue.Blue">
        <short>The  <var>Blue </var>component of the colour defined in <var>RGB</var>
        </short>
      </element>
      <!-- function Visibility: default -->
      <element name="FPColorToTColor">
        <short>
          <var>FPColorToTColor</var> - converts a colour specified as a 
          
          
          
          <var>FPColor </var>to a colour of type
          
          
          
          <var>TColor</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="FPColorToTColor.Result">
        <short>Returns the colour specified in <var>FPColor</var> as a colour of type <var>TColor</var>
        </short>
      </element>
      <!-- argument Visibility: default -->
      <element name="FPColorToTColor.FPColor">
        <short>The colour for processing, expressed as a <var>FPColor</var>
        </short>
      </element>
      <!-- function Visibility: default -->
      <element name="TColorToFPColor">
        <short>
          <var>TColorToFPColor</var> - converts a colour of type 
          
          
          
          <var>TColor </var>to one specified as a 
          
          
          
          <var>FPColor</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TColorToFPColor.Result">
        <short>Returns the colour specified as a FPColor</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TColorToFPColor.c">
        <short>
          <var>c</var> - the supplied colour specified as type 
          
          
          <var>TColor</var>
        </short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="GetCharsetValues">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="GetCharsetValues.Proc">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="CharsetToIdent">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="CharsetToIdent.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="CharsetToIdent.Charset">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="CharsetToIdent.Ident">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="IdentToCharset">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="IdentToCharset.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="IdentToCharset.Ident">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="IdentToCharset.Charset">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="GetDefFontCharSet">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="GetDefFontCharSet.Result">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="IsFontNameXLogicalFontDesc">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="IsFontNameXLogicalFontDesc.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="IsFontNameXLogicalFontDesc.LongFontName">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="XLFDNameToLogFont">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="XLFDNameToLogFont.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="XLFDNameToLogFont.XLFDName">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="ExtractXLFDItem">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="ExtractXLFDItem.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="ExtractXLFDItem.XLFDName">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="ExtractXLFDItem.Index">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="ExtractFamilyFromXLFDName">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="ExtractFamilyFromXLFDName.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="ExtractFamilyFromXLFDName.XLFDName">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="ClearXLFDItem">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="ClearXLFDItem.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="ClearXLFDItem.LongFontName">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="ClearXLFDItem.Index">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="ClearXLFDHeight">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="ClearXLFDHeight.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="ClearXLFDHeight.LongFontName">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="ClearXLFDPitch">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="ClearXLFDPitch.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="ClearXLFDPitch.LongFontName">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="ClearXLFDStyle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="ClearXLFDStyle.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="ClearXLFDStyle.LongFontName">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="XLFDHeightIsSet">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="XLFDHeightIsSet.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="XLFDHeightIsSet.LongFontName">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TOnLoadGraphicFromClipboardFormat">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TOnLoadGraphicFromClipboardFormat.Dest">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TOnLoadGraphicFromClipboardFormat.ClipboardType">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TOnLoadGraphicFromClipboardFormat.FormatID">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TOnSaveGraphicToClipboardFormat">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TOnSaveGraphicToClipboardFormat.Src">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TOnSaveGraphicToClipboardFormat.ClipboardType">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TOnSaveGraphicToClipboardFormat.FormatID">
        <short/>
      </element>
      <!-- variable Visibility: default -->
      <element name="OnLoadGraphicFromClipboardFormat">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="OnSaveGraphicToClipboardFormat">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: default -->
      <element name="TestStreamBitmapNativeType">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TestStreamBitmapNativeType.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TestStreamBitmapNativeType.AStream">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="TestStreamIsBMP">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TestStreamIsBMP.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TestStreamIsBMP.AStream">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="TestStreamIsXPM">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TestStreamIsXPM.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TestStreamIsXPM.AStream">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="TestStreamIsIcon">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TestStreamIsIcon.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TestStreamIsIcon.AStream">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="XPMToPPChar">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="XPMToPPChar.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="XPMToPPChar.XPM">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="LazResourceXPMToPPChar">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="LazResourceXPMToPPChar.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="LazResourceXPMToPPChar.ResourceName">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="ReadXPMFromStream">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="ReadXPMFromStream.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="ReadXPMFromStream.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="ReadXPMFromStream.Size">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="ReadXPMSize">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="ReadXPMSize.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="ReadXPMSize.XPM">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="ReadXPMSize.Width">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="ReadXPMSize.Height">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="ReadXPMSize.ColorCount">
        <short/>
      </element>
      <!-- variable Visibility: default -->
      <element name="ScreenInfo">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="FontResourceCache">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="PenResourceCache">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="BrushResourceCache">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FontCharsets">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="Register">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TGraphic.LazarusResourceTypeValid">
        <short>Check that the Resource specified for reading or writing is a valid type - result True if it is</short>
      </element>
      <element name="TGraphic.LazarusResourceTypeValid.AResourceType">
        <short>The Resource type which is to be checked</short>
      </element>
      <element name="TGraphic.LoadFromResourceName">
        <short>Load the graphic data from a resource identified by the name <var>ResName</var> with the Handle '<var>Instance</var>'</short>
      </element>
      <element name="TGraphic.LoadFromResourceID">
        <short>Load graphic data from a resource identified by the integer identifier <var>ResID</var>
        </short>
      </element>
      <element name="TPicture.LoadFromStreamWithFileExt">
        <short>Loads picture from a named data stream with a specified file extension</short>
      </element>
      <element name="TPicture.FindGraphicClassWithFileExt">
        <short>Finds a graphic class with the named file extension <var>Ext</var>, returning an exception if not found</short>
      </element>
      <element name="TPicture.Jpeg">
        <short>
          <var>Jpeg</var>  - returns a JPEG image</short>
        <descr>
          <p>
            <var>Jpeg</var>  - returns a JPEG image</p>
          <p>If the contents is not already a JPEG image, the contents are thrown away and a blank JPEG is returned</p>
        </descr>
      </element>
      <element name="TPicture.PNM">
        <short>
          <var>PNM </var>- a 
          
          
          
          <b>PortableAnyMapGraphic </b>image</short>
        <descr>
          <p>
            <var>PNM </var>- a 
            
            
            
            <b>PortableAnyMapGraphic </b>image</p>
          <p>Reads a PNM image. If it is not a valid PNM image, the contents are thrown away and a blank PNM is generated</p>
        </descr>
      </element>
      <element name="TJPEGImage">
        <short>
          <var>TJPEGImage</var> - a class for handling images stored in JPEG (compressed) format</short>
        <descr>
          <p>
            <b>JPEG</b> images are very commonly used for storing digital photographs. They can represent detailed colour photos using a high degree of compression, resulting in very efficient storage, though with some loss of quality. </p>
          <p>The properties <var>CompressionQuality</var> (an integer between 1 and 100, with 100 representing the best quality) and <var>Performance</var> (an enumerated variable with two states: <var>BestQuality</var> or <var>BestSpeed</var> ie compression) can be used to determine the balance between efficiency of storage and quality of picture.</p>
        </descr>
      </element>
      <element name="TJPEGImage.InitFPImageReader">
        <short>Initialise the FreePascal Image reader for this image type</short>
      </element>
      <element name="TJPEGImage.FinalizeFPImageReader">
        <short>Finalise the FreePascal Image reader</short>
      </element>
      <element name="TJPEGImage.InitFPImageWriter">
        <short>Initialise the FreePascal Image Writer for this image class</short>
      </element>
      <element name="TJPEGImage.CompressionQuality">
        <short>Determine the compression quality for this image</short>
        <descr>
          <p>Extreme compression can lead to loss of quality at the expense of a small file size</p>
          <p>Allowed range is 1..100 </p>
          <p>100 = best quality, 25 = pretty awful</p>
        </descr>
      </element>
      <element name="TJPEGImage.GrayScale">
        <short>Is this a grayscale image?</short>
      </element>
      <element name="TJPEGImage.ProgressiveEncoding">
        <short>Is progressive encoding used for this JPEG?</short>
      </element>
      <element name="TJPEGImage.Performance">
        <short>Set for best quality or best speed</short>
      </element>
      <element name="TBitmap.LoadFromIntfImage">
        <short>
          <var>LoadFromIntfImage</var> - gets 
          
          
          
          
          
          
          
          <var>Bitmap</var> data from an interface image</short>
      </element>
      <element name="TBitmap.GetResourceType">
        <short>Finds the type of resource for the bitmap</short>
      </element>
      <element name="TBitmap.SetHandles">
        <short>Sets handles for the bitmap and its mask</short>
      </element>
      <element name="TBitmap.ReleaseMaskHandle">
        <short>Release the bitmap mask handle</short>
      </element>
      <element name="TBitmap.CanReadGraphicStreams">
        <short>Determine whether this instance of the class can read graphic streams</short>
      </element>
      <element name="TBitmapImage.FreePalette">
        <short>Free the colour palette used for this bitmap</short>
      </element>
      <element name="TBitmapImage.ReleaseMaskHandle">
        <short>Release the handle for the bitmap mask</short>
      </element>
      <element name="TBitmapImage.ReleasePalette">
        <short>Reklease the handle for the colour palette</short>
      </element>
      <element name="TBitmapImage.BitmapCanvas">
        <short>The canvas for the bitmap (ie the actual contents of the picture)</short>
      </element>
      <element name="TBitmapImage.SaveStreamClass">
        <short>The class of stream for saving data</short>
      </element>
      <element name="TJPEGImage.Create">
        <short>
          <var>Create</var> - constructor for TJPEGImage: performs inherited 
          <var>Create</var> then initialises local variables for performance, quality and encoding</short>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
          <link id="#LCL.Graphics.TCustomBitmap.Create">TCustomBitmap.Create</link>
        </seealso>
      </element>
      <element link="#LCL.Graphics.TGraphic.GetFileExtensions" name="TJPEGImage.GetFileExtensions"/>
      <element name="TJPEGImage.GetDefaultFPReader"/>
      <element name="TJPEGImage.GetDefaultFPWriter"/>
      <topic name="Progress">
        <short>Monitoring the progress of drawing a complicated Graphic</short>
        <descr>
          <p>
            <var>TProgressEvent</var> is a generic progress notification event which may be used by 
            
            
            
            
            
            
            <var>TGraphic</var> classes with computationally intensive (slow) operations, such as loading, storing, or transforming image data.</p>
          <table>
            <caption>Event params:
</caption>
            <tr>
              <td>Stage</td>
              <td>Indicates whether this call to the <var>OnProgress</var> event is to prepare for, process, or clean up after a graphic operation.  If <var>OnProgress</var> is called at all, the first call for a graphic operation will be with <var>Stage = psStarting</var>, to allow the <var>OnProgress</var> event handler to allocate whatever resources it needs to process subsequent progress notifications.  After <var>Stage = psStarting</var>, you are guaranteed that  <var>OnProgress</var> will be called again with 
<var>Stage = psEnding</var> to allow you to free those resources, even if the graphic operation is aborted by an exception.  Zero or more calls to  <var>OnProgress </var>with <var>Stage = psRunning</var> may occur between the <var>psStarting</var> and  <var>psEnding</var> calls.</td>
            </tr>
            <tr>
              <td>PercentDone</td>
              <td>The ratio of work done to work remaining, on a scale of 0 to 100.  Values may repeat or even regress (get smaller) in successive calls.  <var>PercentDone</var> is usually only a guess, and the guess may be dramatically altered as new information is discovered in decoding the image. The value of this property could usefully be passed to a ProgressBar to show the user how drawing is progressing</td>
            </tr>
            <tr>
              <td>RedrawNow</td>
              <td>Indicates whether the graphic can be/should be redrawn immediately.  Useful for showing successive approximations of an image as data is available instead of waiting for all the data to arrive before drawing anything.  Since there is no message loop activity during graphic operations, you should call 
  <var>Update</var> to force a control to be redrawn immediately in the 
  <var>OnProgress </var>event handler. Redrawing a graphic when 
  RedrawNow = False could corrupt the image and/or cause exceptions.</td>
            </tr>
            <tr>
              <td>Rect</td>
              <td>Area of image that has changed and needs to be redrawn.</td>
            </tr>
            <tr>
              <td>Msg</td>
              <td>Optional text describing in one or two words what the graphic class is currently working on.  Ex:  "Loading" "Storing" "Reducing colors".  The 
  <var>Msg</var> string can also be empty. 
  <var>Msg</var> strings should be resourced for translation,  should not contain trailing periods, and should be used only for display purposes.  (Do not use the construct: if Msg = 'Loading' then...)</td>
            </tr>
          </table>
        </descr>
      </topic>
      <element name="RGBToColor">
        <short>
          <var>RGBToColor</var> - assembles the supplied values for Red, Green and Blue into a composite colour</short>
      </element>
      <element name="LoadCursorFromLazarusResource">
        <short>
          <var>LoadCursorFromLazarusResource</var> - loads a  named cursor handle from the Lazarus Resource (.LRS)</short>
      </element>
      <element name="CreateBitmapFromLazarusResource">
        <short>
          <var>CreateBitmapFromLazarusResource</var> - creates a bitmap image using data read into a stream from a Lazarus Resource (.LRS)</short>
      </element>
      <element name="InvertColor">
        <short>
          <var>InvertColor</var> - returns the complementary colour to the supplied value - helps to produce a 'negative' image</short>
      </element>
      <element name="DecColor">
        <short>
          <var>DecColor</var> - decrease the component RGBs of a colour by the quantity specified (usually results in a darker colour overall)</short>
      </element>
      <!-- variable Visibility: default -->
      <element name="TTextStyle.RightToLeft">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="psSolid">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="psDash">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="psDot">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="psDashDot">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="psDashDotDot">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="psClear">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="psInsideframe">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="pmBlack">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="pmWhite">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="pmNop">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="pmNot">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="pmCopy">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="pmNotCopy">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="pmMergePenNot">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="pmMaskPenNot">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="pmMergeNotPen">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="pmMaskNotPen">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="pmMerge">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="pmNotMerge">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="pmMask">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="pmNotMask">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="pmXor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="pmNotXor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bsSolid">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bsClear">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bsHorizontal">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bsVertical">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bsFDiagonal">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bsBDiagonal">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bsCross">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bsDiagCross">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clMoneyGreen">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clSkyBlue">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="clMedGray">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- class Visibility: default -->
      <element name="TCustomBitmap">
        <short>
          <var>TCustomBitMap </var>- the base class for 
          
          
          <var>TBitmap</var>
        </short>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TCustomBitmapClass">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- class Visibility: default -->
      <element name="TPortableAnyMapGraphic">
        <short>
          <var>TPortableAnyMapGraphic</var> - a PAM graphic image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FCanUTF8Valid">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FIsMonoSpace">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FIsMonoSpaceValid">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFont.FReference">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TFont.FreeReference">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TFont.GetCanUTF8">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFont.GetCanUTF8.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TFont.GetIsMonoSpace">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFont.GetIsMonoSpace.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TFont.GetReference">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFont.GetReference.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TFont.ReferenceNeeded">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFont.DoAllocateResources">
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCanvasHelper.DoAllocateResources">TFPCanvasHelper.DoAllocateResources</link>
        </seealso>
        <short>
          <var>DoAllocateResources</var> - calls inherited method then calls 
          <var>GetReference</var>
        </short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFont.DoCopyProps">
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCanvasHelper.DoCopyProps">TFPCanvasHelper.DoCopyProps</link>
        </seealso>
        <short>
          <var>DoCopyProps</var> - calls inherited method; if 
          <var>From</var> argument is another Font, copies specified properties directly</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.DoCopyProps.From">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFont.DoDeAllocateResources">
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCanvasHelper.DoDeAllocateResources">TFPCanvasHelper.DoDeAllocateResources</link>
        </seealso>
        <short>
          <var>DoDeAllocateResources</var> - frees references then calls inherited method</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.SetColor.NewColor">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.SetColor.NewFPColor">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFont.SetFlags">
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCanvasHelper.SetFlags">TFPCanvasHelper.SetFlags</link>
        </seealso>
        <short>
          <var>SetFlags</var> - if the passed argument 
          <var>AValue</var> for the 
          <var>Index</var> is the same, returns unchanged; otherwise, calls inherited method and sets style flags as appropriate</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.SetFlags.Index">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.SetFlags.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFont.SetFPColor">
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCanvasHelper.SetFPColor">TFPCanvasHelper.SetFPColor</link>
        </seealso>
        <short>
          <var>SetFPColor</var> converts TFPColor to TColor</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.SetFPColor.AValue">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TFont.IsEqual">
        <short>
          <var>IsEqual</var> - returns True if this Font is the same as the specified Font</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFont.IsEqual.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFont.IsEqual.AFont">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TFont.IsMonoSpace">
        <short>
          <var>IsMonoSpace</var> - returns True if this is a MonoSpace Font</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TFont.SetDefault">
        <short>
          <var>SetDefault</var> - method for setting the default Font</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TFont.Reference">
        <short>
          <var>Reference</var> - References made to this Font</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TPen.FReference">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TPen.FreeReference">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TPen.GetReference">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPen.GetReference.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TPen.ReferenceNeeded">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#fcl.FPCanvas.TFPCanvasHelper.DoAllocateResources" name="TPen.DoAllocateResources">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#fcl.FPCanvas.TFPCanvasHelper.DoDeAllocateResources" name="TPen.DoDeAllocateResources">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#fcl.FPCanvas.TFPCanvasHelper.DoCopyProps" name="TPen.DoCopyProps">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPen.DoCopyProps.From">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPen.SetColor.NewColor">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPen.SetColor.NewFPColor">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#fcl.FPCanvas.TFPCanvasHelper.SetFPColor" name="TPen.SetFPColor">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPen.SetFPColor.AValue">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TPen.Reference">
        <short>A <var>Reference</var> made to this Pen</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBrush.FReference">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBrush.FInternalUpdateIndex">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TBrush.FreeReference">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TBrush.GetReference">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBrush.GetReference.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TBrush.ReferenceNeeded">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TBrush.DoChange">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBrush.DoChange.Msg">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBrush.DoAllocateResources">
        <short>
          <var>DoAllocateResources</var> - calls inherited method then calls 
          <var>GetReference</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCanvasHelper.DoAllocateResources">TFPCanvasHelper.DoAllocateResources</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBrush.DoDeAllocateResources">
        <short>
          <var>DoDeAllocateResources</var> - frees reference then calls inherited method</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCanvasHelper.DoDeAllocateResources">TFPCanvasHelper.DoDeAllocateResources</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBrush.DoCopyProps">
        <short>
          <var>DoCopyProps</var> - if the 
          <var>From</var>argument is another 
          <var>Brush</var>, frees reference before calling inherited method, then sets the 
          <var>Changed</var> property</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCanvasHelper.DoCopyProps">TFPCanvasHelper.DoCopyProps</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBrush.DoCopyProps.From">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBrush.SetColor.NewColor">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBrush.SetColor.NewFPColor">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#fcl.FPCanvas.TFPCanvasHelper.SetFPColor" name="TBrush.SetFPColor">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBrush.SetFPColor.AValue">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TBrush.Reference">
        <short>A <var>Reference</var> made to the current Brush</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TRegion.FreeReference">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TRegion.GetReference">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRegion.GetReference.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TRegion.ReferenceNeeded">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TRegion.Reference">
        <short>A <var>Reference</var> to the current Region</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TGraphic.LazarusResourceTypeValid.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.LoadFromResourceName.Instance">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.LoadFromResourceName.ResName">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.LoadFromResourceID.Instance">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphic.LoadFromResourceID.ResID">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TGraphic.GetResourceType">
        <short>
          <var>GetResourceType</var> - returns the type of a resource to be used in the graphic</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TGraphic.GetResourceType.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TPicture.GetJpeg">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPicture.GetJpeg.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TPicture.GetPNM">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPicture.GetPNM.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TPicture.SetJpeg">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.SetJpeg.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TPicture.SetPNM">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.SetPNM.AValue">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.LoadFromStreamWithFileExt.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.LoadFromStreamWithFileExt.FileExt">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TPicture.LoadFromLazarusResource">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.LoadFromLazarusResource.AName">
        <short/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPicture.FindGraphicClassWithFileExt.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.FindGraphicClassWithFileExt.Ext">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPicture.FindGraphicClassWithFileExt.ExceptionOnNotFound">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TGradientDirection">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TGradientDirection.gdVertical">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TGradientDirection.gdHorizontal">
        <short/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCanvas.FSavedHandleStates">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCanvas.SetLazFont">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetLazFont.value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCanvas.SetLazPen">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetLazPen.value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCanvas.SetLazBrush">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetLazBrush.value">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCanvas.DoCreateDefaultFont">
        <short>
          <var>DoCreateDefaultFont</var> - calls 
          <var>TFont.Create</var> to create a default fomt</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoCreateDefaultFont">TFPCustomCanvas.DoCreateDefaultFont</link>
          <link id="#LCL.Graphics.TFont.Create">TFont.Create</link>
        </seealso>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.DoCreateDefaultFont.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCanvas.DoCreateDefaultPen">
        <short>
          <var>DoCreateDefaultPen</var> - calls 
          <var>TPen.Create</var> to create a default pen</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoCreateDefaultPen">TFPCustomCanvas.DoCreateDefaultPen</link>
          <link id="#LCL.Graphics.TPen.Create">TPen.Create</link>
        </seealso>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.DoCreateDefaultPen.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCanvas.DoCreateDefaultBrush">
        <short>
          <var>DoCreateDefaultBrush</var> - calls 
          <var>TBrush.Create</var> to create a default brush</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoCreateDefaultBrush">TFPCustomCanvas.DoCreateDefaultBrush</link>
          <link id="#LCL.Graphics.TBrush.Create">TBrush.Create</link>
        </seealso>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.DoCreateDefaultBrush.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetColor.x">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetColor.y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetColor.Value">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.GetColor.x">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.GetColor.y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.SetHeight">
        <short>
          <var>SetHeight</var> - should never be called for Canvas: raises an exception if it is called</short>
        <descr/>
        <errors>If called, raises an exception:
'TCanvas.SetHeight not allowed for LCL canvas'</errors>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.SetHeight">TFPCustomCanvas.SetHeight</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetHeight.AValue">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCanvas.GetHeight">
        <short>
          <var>GetHeight</var> - if a handle has been allocated, returns the height from the device size</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.GetHeight">TFPCustomCanvas.GetHeight</link>
        </seealso>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.GetHeight.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.SetWidth">
        <short>
          <var>SetWidth</var> - should never be called; raises an exception if it is called</short>
        <descr/>
        <errors>Raises an exception:
'TCanvas.SetWidth not allowed for LCL canvas'</errors>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.SetWidth">TFPCustomCanvas.SetWidth</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetWidth.AValue">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCanvas.GetWidth">
        <short>
          <var>GetWidth</var> - if a handle has been allocated, returns the width from the device size</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.GetWidth">TFPCustomCanvas.GetWidth</link>
        </seealso>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.GetWidth.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.SetPenPos.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoLockCanvas">
        <short>
          <var>DoLockCanvas</var> - enters critical locking section then calls inherited method</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoLockCanvas">TFPCustomCanvas.DoLockCanvas</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoUnlockCanvas">
        <short>
          <var>DoUnlockCanvas</var> - leaves the critical locking section then calls inherited method</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoUnlockCanvas">TFPCustomCanvas.DoUnlockCanvas</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoTextOut">
        <short>
          <var>DoTextOut</var> calls 
          <var>TextOut</var> for the specified coordinates and string</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoTextOut">TFPCustomCanvas.DoTextOut</link>
          <link id="#LCL.Graphics.TCanvas.TextOut">TCanvas.TextOut</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoTextOut.x">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoTextOut.y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoTextOut.Text">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoGetTextSize">
        <short>
          <var>DoGetTextSize</var> calls 
          <var>TextExtent</var> to find width and height of specified text string</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoGetTextSize">TFPCustomCanvas.DoGetTextSize</link>
          <link id="#LCL.Graphics.TCanvas.TextExtent">TCanvas.TextExtent</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoGetTextSize.Text">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoGetTextSize.w">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoGetTextSize.h">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCanvas.DoGetTextHeight">
        <short>
          <var>DoGetTextHeight</var> calls 
          <var>TextHeight</var> to return the height of the text</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoGetTextHeight">TFPCustomCanvas.DoGetTextHeight</link>
          <link id="#LCL.Graphics.TCanvas.TextHeight">TCanvas.TextHeight</link>
        </seealso>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.DoGetTextHeight.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoGetTextHeight.Text">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCanvas.DoGetTextWidth">
        <short>
          <var>DoGetTextWidth</var> calls 
          <var>TextWidth</var> to return the width of the given text string</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoGetTextWidth">TFPCustomCanvas.DoGetTextWidth</link>
          <link id="#LCL.Graphics.TCanvas.TextWidth">TCanvas.TextWidth</link>
        </seealso>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.DoGetTextWidth.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoGetTextWidth.Text">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoRectangle">
        <short>
          <var>DoRectangle</var> calls 
          <var>Frame</var> to draw a rectangle in the given bounds</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoRectangle">TFPCustomCanvas.DoRectangle</link>
          <link id="#LCL.Graphics.TCanvas.Frame">TCanvas.Frame</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoRectangle.Bounds">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoRectangleFill">
        <short>
          <var>DoRectangleFill</var> calls 
          <var>FillRect</var> to draw a filled rectangle with the given bounds</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoRectangleFill">TFPCustomCanvas.DoRectangleFill</link>
          <link id="#LCL.Graphics.TCanvas.FillRect">TCanvas.FillRect</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoRectangleFill.Bounds">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoRectangleAndFill">
        <short>
          <var>DoRectangleAndFill</var> - calls 
          <var>Rectangle</var> to draw a rectangle and fill it</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoRectangleAndFill">TFPCustomCanvas.DoRectangleAndFill</link>
          <link id="#LCL.Graphics.TCanvas.Rectangle">TCanvas.Rectangle</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoRectangleAndFill.Bounds">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoEllipse">
        <short>
          <var>DoEllipse</var> draws an 
          <var>Arc</var> of 360 degrees within given 
          <var>Bounds</var>, making an ellipse</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoEllipse">TFPCustomCanvas.DoEllipse</link>
          <link id="#LCL.Graphics.TCanvas.Arc">TCanvas.Arc</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoEllipse.Bounds">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoEllipseFill">
        <short>
          <var>DoEllipseFill</var> calls 
          <var>Ellipse</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoEllipseFill">TFPCustomCanvas.DoEllipseFill</link>
          <link id="#LCL.Graphics.TCanvas.Ellipse">TCanvas.Ellipse</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoEllipseFill.Bounds">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoEllipseAndFill">
        <short>
          <var>DoEllipseAndFill</var> - calls inherited 
          <var>DoEllipseAndFill</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoEllipseAndFill">TFPCustomCanvas.DoEllipseAndFill</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoEllipseAndFill.Bounds">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoPolygon">
        <short>
          <var>DoPolygon</var> calls 
          <var>PolyLine</var> to draw a series of lines through the points</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoPolygon">TFPCustomCanvas.DoPolygon</link>
          <link id="#LCL.Graphics.TCanvas.PolyLine">TCanvas.PolyLine</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoPolygon.Points">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoPolygonFill">
        <short>
          <var>DoPolygonFill</var> calls 
          <var>Polygon</var> for the suppied points</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoPolygonFill">TFPCustomCanvas.DoPolygonFill</link>
          <link id="#LCL.Graphics.TCanvas.Polygon">TCanvas.Polygon</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoPolygonFill.Points">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoPolygonAndFill">
        <short>
          <var>DoPolygonAndFill</var> calls inherited method</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoPolygonAndFill">TFPCustomCanvas.DoPolygonAndFill</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoPolygonAndFill.Points">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoPolyline">
        <short>
          <var>DoPolyline</var> calls 
          <var>PolyLine</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoPolyline">TFPCustomCanvas.DoPolyline</link>
          <link id="#LCL.Graphics.TCanvas.PolyLine">TCanvas.PolyLine</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoPolyline.Points">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoFloodFill">
        <short>
          <var>DoFloodFill</var> calls 
          <var>FloodFill</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoFloodFill">TFPCustomCanvas.DoFloodFill</link>
          <link id="#LCL.Graphics.TCanvas.FloodFill">TCanvas.FloodFill</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoFloodFill.x">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoFloodFill.y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoMoveTo">
        <short>
          <var>DoMoveTo</var> calls 
          <var>MoveTo</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoMoveTo">TFPCustomCanvas.DoMoveTo</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoMoveTo.x">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoMoveTo.y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoLineTo">
        <short>
          <var>DoLineTo</var> calls 
          <var>LineTo</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoLineTo">TFPCustomCanvas.DoLineTo</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoLineTo.x">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoLineTo.y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoLine">
        <short>
          <var>DoLine</var> calls 
          <var>Line</var> to draw from x1, y1 to x2, y2</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoLine">TFPCustomCanvas.DoLine</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoLine.x1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoLine.y1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoLine.x2">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoLine.y2">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoCopyRect">
        <short>
          <var>DoCopyRect</var> checks that 
          <var>SrcCanvas</var> is of correct type then copies coordinates and calls 
          <var>CopyRect</var>
        </short>
        <descr/>
        <errors>If <var>SrcCanvas</var> is not of type <var>TCanvas</var> then writes a warning to the debug output that copying is not supported
        </errors>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoCopyRect">TFPCustomCanvas.DoCopyRect</link>
          <link id="#LCL.Graphics.TCanvas.CopyRect">TCanvas.CopyRect</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoCopyRect.x">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoCopyRect.y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoCopyRect.SrcCanvas">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoCopyRect.SourceRect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.DoDraw">
        <short>
          <var>DoDraw</var> checks that 
          <var>Image</var> is of the right type, makes a local copy, creates the necessary handles and bitmaps for drawing</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.DoDraw">TFPCustomCanvas.DoDraw</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoDraw.x">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoDraw.y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DoDraw.Image">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.CheckHelper">
        <short>
          <var>CheckHelper</var> - ignored by current class</short>
        <descr/>
        <errors>Writes a message to debug output that the call is ignored</errors>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.CheckHelper">TFPCustomCanvas.CheckHelper</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.CheckHelper.AHelper">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCanvas.GetClipRect">
        <short>
          <var>GetClipRect</var> - if an error is encountered in finding the Clipping Rectangle dimensions, sets some defaults anyway</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.GetClipRect">TFPCustomCanvas.GetClipRect</link>
        </seealso>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCanvas.GetClipRect.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.FontChanging">
        <short>
          <var>FontChanging</var>
          <var/> - software emulation for call to 
          <var>OnChanging</var> event for Font</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.FontChanging.APen">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.BrushChanging">
        <short>
          <var>BrushChanging</var>
          <var/> - software emulation for call to 
          <var>OnChanging</var> event for Brush</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.BrushChanging.APen">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.RegionChanging">
        <short>
          <var>RegionChanging</var>
          <var/> - software emulation for call to 
          <var>OnChanging</var> event for Region</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RegionChanging.APen">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCanvas.FreeHandle">
        <short>
          <var>FreeHandle</var> - release a Handle</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.SaveHandleState">
        <short>
          <var>SaveHandleState</var> - stores the state of the Handle</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.RestoreHandleState">
        <short>
          <var>RestoreHandleState</var> - retrieves the saved state of the Handle</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.ALeft">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.ATop">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.ARight">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Arc.ABottom">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.x1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.y1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.x2">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Chord.y2">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.DrawFocusRect">
        <short>
          <var>DrawFocusRect</var> - draws a focused rectangle at the specified position</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.DrawFocusRect.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCanvas.GradientFill">
        <short>
          <var>GradientFill</var> - fill the specified rectangle with the specified colours in a gradient with the specified direction</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.GradientFill.ARect">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.GradientFill.AStart">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.GradientFill.AStop">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.GradientFill.ADirection">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Line.p1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Line.p2">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Line.Points">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.x1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.y1">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.x2">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.RadialPie.y2">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCanvas.Rectangle.ARect">
        <short/>
      </element>
      <!-- property Visibility: published -->
      <element name="TCanvas.Height">
        <descr/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.Height">TFPCustomCanvas.Height</link>
        </seealso>
        <short>The <var>Height</var> of the canvas</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TCanvas.Width">
        <descr/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.Width">TFPCustomCanvas.Width</link>
        </seealso>
        <short>The <var>Width</var> of the Canvas</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TBitmapNativeType.bnCursor">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TBitmapNativeType.bnDIB">
        <short/>
      </element>
      <!-- class Visibility: default -->
      <element name="TCustomBitmapImage">
        <short>
          <var>TCustomBitmapImage</var> - the base type for 
          
          
          <var>TBitmapImage</var>
        </short>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomBitmapImage.FHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomBitmapImage.FMaskHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomBitmapImage.FPalette">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomBitmapImage.FDIBHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomBitmapImage.FBitmapCanvas">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomBitmapImage.FSaveStream">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomBitmapImage.FSaveStreamClass">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomBitmapImage.FSaveStreamType">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmapImage.FreeHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmapImage.FreeMaskHandle">
        <short>Release the handle for the bitmap mask</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmapImage.FreePalette">
        <short>Free the colour palette used for this bitmap</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomBitmapImage.ReleaseHandle">
        <short>Release the bitmap handle</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmapImage.ReleaseHandle.Result">
        <short>Returns True if bitmap handle is correctly released</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomBitmapImage.ReleaseMaskHandle">
        <short>Release the handle for the bitmap mask</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmapImage.ReleaseMaskHandle.Result">
        <short>Returns True is mask handle was correctly released</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomBitmapImage.ReleasePalette">
        <short>Release the handle for the colour palette</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmapImage.ReleasePalette.Result">
        <short>Returns True if palette was correctly released</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomBitmapImage.IsEmpty">
        <short>Is the bitmap image empty?</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmapImage.IsEmpty.Result">
        <short>Returns True if bitmap is empty</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomBitmapImage.GetPixelFormat">
        <short>Find the format for the pixels (ie the number of bits per pixel)</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmapImage.GetPixelFormat.Result">
        <short/>
      </element>
      <!-- variable Visibility: public -->
      <element name="TCustomBitmapImage.FDIB">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TCustomBitmapImage.Destroy">
        <short>BitmapImage destructor</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TCustomBitmapImage.HandleAllocated">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmapImage.HandleAllocated.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TCustomBitmapImage.GetHandleType">
        <short>Determine the type of the bitmap handle</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmapImage.GetHandleType.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomBitmapImage.BitmapCanvas">
        <short>The canvas for the bitmap (ie the actual contents of the picture)</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomBitmapImage.SaveStream">
        <short>The stream to which the data are to be saved</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomBitmapImage.SaveStreamType">
        <short>The type of the stream for saving the data</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomBitmapImage.SaveStreamClass">
        <short>The class of stream for saving data</short>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomBitmap.FCanvas">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomBitmap.FImage">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomBitmap.FPixelFormat">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomBitmap.FTransparentColor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomBitmap.FTransparentMode">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomBitmap.FInternalState">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomBitmap.FreeCanvasContext">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TCustomBitmap.GetCanvas">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetCanvas.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomBitmap.CreateCanvas">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomBitmap.CreateMask">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.CreateMask.AColor">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TCustomBitmap.GetMonochrome">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetMonochrome.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="#LCL.Graphics.TRasterImage.SetHandle" name="TCustomBitmap.SetHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetHandle.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomBitmap.SetMaskHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetMaskHandle.NewMaskHandle">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TCustomBitmap.GetHandleType">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetHandleType.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomBitmap.SetHandleType">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetHandleType.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomBitmap.SetMonochrome">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetMonochrome.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="#LCL.Graphics.TRasterImage.SetPixelFormat" name="TCustomBitmap.SetPixelFormat">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetPixelFormat.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomBitmap.SetTransparentColor">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetTransparentColor.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomBitmap.UpdatePixelFormat">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.Changed" name="TCustomBitmap.Changed">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.Changed.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.Changing">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.Changing.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.ChangingAll">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.ChangingAll.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.Draw">
        <short>Draw the bitmap on the specified Canvas at the specified coordinates</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.Draw.DestCanvas">
        <short>The canvas on which the bitmap is to be drawn</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.Draw.DestRect">
        <short>The rectangular coordinates where the canvas containing the bitmap is located</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomBitmap.GetEmpty">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetEmpty.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomBitmap.GetHeight">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TGraphic.GetPalette" name="TCustomBitmap.GetPalette">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetPalette.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomBitmap.GetWidth">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomBitmap.GetHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.GetMaskHandle" name="TCustomBitmap.GetMaskHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetMaskHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomBitmap.GetTransparent">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetTransparent.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomBitmap.GetBitmapNativeType">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetBitmapNativeType.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.HandleNeeded" name="TCustomBitmap.HandleNeeded">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.MaskHandleNeeded" name="TCustomBitmap.MaskHandleNeeded">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.PaletteNeeded" name="TCustomBitmap.PaletteNeeded">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.UnshareImage" name="TCustomBitmap.UnshareImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.UnshareImage.CopyContent">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.FreeSaveStream">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.ReadData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.ReadData.Stream">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.SetWidthHeight">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetWidthHeight.NewWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetWidthHeight.NewHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.SetHeight">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetHeight.NewHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.SetPalette">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetPalette.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.SetTransparentMode">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetTransparentMode.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.SetWidth">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetWidth.NewWidth">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.WriteData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.WriteData.Stream">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.StoreOriginalStream">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.StoreOriginalStream.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.StoreOriginalStream.Size">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.WriteStreamWithFPImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.WriteStreamWithFPImage.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.WriteStreamWithFPImage.WriteSize">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.WriteStreamWithFPImage.WriterClass">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.InitFPImageReader">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.InitFPImageReader.IntfImg">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.InitFPImageReader.ImgReader">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.InitFPImageWriter">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.InitFPImageWriter.IntfImg">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.InitFPImageWriter.ImgWriter">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.FinalizeFPImageReader">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.FinalizeFPImageReader.ImgReader">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.FinalizeFPImageWriter">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.FinalizeFPImageWriter.ImgWriter">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TCustomBitmap.Create">
        <descr>
          <var>BitMap</var> constructor. The supplied code can 
          
          
          <b>override</b> the definition from ancestor classes
</descr>
        <short>
          <var>Create</var> - constructor for 
          <var>TCustomBitmap</var>: performs inherited 
          <var>Create</var> and initialises pixel format</short>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TCustomBitmap.Destroy">
        <descr>
          <var>BitMap</var> destructor. The supplied code can

          
          
          <b>override</b> the method defined for ancestor classes
</descr>
        <short>
          <var>Destroy</var> - destructor for 
          <var>TCustomBitmap</var>: frees any Mask handles, then performs inherited 
          <var>Destroy</var>
        </short>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Destroy">TPersistent.Destroy</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomBitmap.Assign">
        <short>
          <var>Assign</var>: find out about the 
          
          
          <var>Source</var> of the call.</short>
        <descr>
          <p>
            <var>Assign</var>: find out about the 
            
            
            <var>Source</var> of the call.</p>
          <p>If the   <var>BitMap</var> data are already in use, the data are shared; if not, a new  <var>BitMap</var> is produced
</p>
        </descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.Assign.Source">
        <short>The <var>Source</var> control (usually a Bitmap) for the <var>Assign</var> procedure</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomBitmap.FreeImage">
        <short>Releases all the resources used for the image that is being discarded</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TCustomBitmap.HandleAllocated">
        <short>Is a handle allocated for this bitmap?</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.HandleAllocated.Result">
        <short>Returns True if a handle is allocated</short>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TRasterImage.MaskHandleAllocated" name="TCustomBitmap.MaskHandleAllocated"/>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.MaskHandleAllocated.Result">
        <short>Returns True is a mask handle has been allocated</short>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TRasterImage.PaletteAllocated" name="TCustomBitmap.PaletteAllocated"/>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.PaletteAllocated.Result">
        <short>Returns True if a palette has been allocated</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomBitmap.CreateFromBitmapHandles">
        <short>Create an image in the specified rectangle, using the given bitmap and mask handles</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.CreateFromBitmapHandles.ABitmap">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.CreateFromBitmapHandles.AMask">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.CreateFromBitmapHandles.ARect">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TGraphic.LazarusResourceTypeValid" name="TCustomBitmap.LazarusResourceTypeValid"/>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.LazarusResourceTypeValid.Result">
        <short>Returns TRUE if a valid resource type is found</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.LazarusResourceTypeValid.ResourceType">
        <short>The target resource type specified as a string</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomBitmap.LoadFromDevice">
        <short>Load a bitmap from the nominated Device</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.LoadFromDevice.DC">
        <short>The handle for the device from which the bitmap is to be loaded</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomBitmap.LoadFromStream">
        <short>Load a bitmap from a stream</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.LoadFromStream.Stream">
        <short>The stream from which the bitmap is to be loaded</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomBitmap.LoadFromMimeStream">
        <short>Load a bitmap from a MIME type stream</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.LoadFromMimeStream.Stream">
        <short>The stream from which the bitmap is to be loaded</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.LoadFromMimeStream.MimeType">
        <short>The MIME type of the stream from which the bitmap is to be loaded</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomBitmap.LoadFromIntfImage">
        <short>Load a bitmap from a Lazarus interface image</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.LoadFromIntfImage.IntfImage">
        <short>The Lazarus interface image from which the bitmap is to be loaded</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomBitmap.LoadFromXPMFile">
        <short>Load a bitmap from a XPM file (pixmap)</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.LoadFromXPMFile.Filename">
        <short>The name of the file from which the bitmap is to be loaded</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomBitmap.SaveToStream">
        <short>Saves bitmap data to a stream</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SaveToStream.Stream">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomBitmap.GetSupportedSourceMimeTypes">
        <short>Gets a list of the supported MIME types for the source file</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.GetSupportedSourceMimeTypes.List">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TCustomBitmap.GetDefaultMimeType">
        <short>Finds the default MIME type</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetDefaultMimeType.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TGraphic.GetResourceType" name="TCustomBitmap.GetResourceType"/>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetResourceType.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TCustomBitmap.GetFileExtensions">
        <short>Finds the available file extensions</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetFileExtensions.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomBitmap.Mask">
        <short>Masks the bitmap using a transparent colour</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.Mask.ATransparentColor">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Graphics.TRasterImage.SetHandles" name="TCustomBitmap.SetHandles"/>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetHandles.ABitmap">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetHandles.AMask">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomBitmap.ReadStream">
        <short>Reads data from a stream</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.ReadStream.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.ReadStream.UseSize">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.ReadStream.Size">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomBitmap.WriteStream">
        <short>Writes data to a stream</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.WriteStream.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.WriteStream.WriteSize">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TCustomBitmap.ReleaseHandle">
        <short>Release the bitmap handle, effectively freeing resources</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.ReleaseHandle.Result">
        <short>Returns True if handle has been correctly released</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TCustomBitmap.ReleaseMaskHandle">
        <short>Release the bitmap mask handle</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.ReleaseMaskHandle.Result">
        <short>Returns True if the Mask handle has been correctly released</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TCustomBitmap.ReleasePalette">
        <short>Release the current palette</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.ReleasePalette.Result">
        <short>Returns True if the palette has been correclty released</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TCustomBitmap.GetFPReaderForFileExt">
        <short>Get the appropriate FPReader for the given file extension</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetFPReaderForFileExt.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.GetFPReaderForFileExt.FileExtension">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TCustomBitmap.GetFPWriterForFileExt">
        <short>Get the appropriate FPWriter for the given file extension</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetFPWriterForFileExt.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.GetFPWriterForFileExt.FileExtension">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TCustomBitmap.GetDefaultFPReader">
        <short>Get the default FPReader</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetDefaultFPReader.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TCustomBitmap.GetDefaultFPWriter">
        <short>Get the default FPWriter</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetDefaultFPWriter.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomBitmap.ReadStreamWithFPImage">
        <short>Read Bitmap data from stream using the FPImage reader</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.ReadStreamWithFPImage.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.ReadStreamWithFPImage.UseSize">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.ReadStreamWithFPImage.Size">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.ReadStreamWithFPImage.ReaderClass">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomBitmap.WriteNativeStream">
        <short>Write bitmap data to a native stream</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.WriteNativeStream.Stream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.WriteNativeStream.WriteSize">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.WriteNativeStream.SaveStreamType">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomBitmap.CreateIntfImage">
        <short>Create an interface image</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.CreateIntfImage.IntfImage">
        <short/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.CreateIntfImage.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TCustomBitmap.CanReadGraphicStreams"/>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.CanReadGraphicStreams.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.CanReadGraphicStreams.AClass">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomBitmap.Canvas">
        <short>The <var>Canvas</var> on which this bitmap is drawn</short>
        <descr>
          <p>The Canvas is where all the drawing and painting is performed.</p>
          <p>The properties are described in <link id="Controls.TCanvas">TCanvas</link>
          </p>
        </descr>
        <seealso>
          <link id="Graphics.TCanvas"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomBitmap.Handle">
        <short>The operating system Handle ssociated with this bitmap</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomBitmap.HandleType">
        <short>The type of system handle</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomBitmap.MaskHandle">
        <short>The system handle associated with the bitmap mask</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomBitmap.Monochrome">
        <short>Whether using monochrome display</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomBitmap.PixelFormat">
        <short>
          <var>PixelFormat </var>- number of bits per pixel</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomBitmap.TransparentColor">
        <short>The transparent colour used for masks etc</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomBitmap.TransparentMode">
        <short>The mode used for transparency</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TPixmap.GetBitmapNativeType">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPixmap.GetBitmapNativeType.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TFPImageBitmap.GetBitmapNativeType">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFPImageBitmap.GetBitmapNativeType.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TPortableNetworkGraphic.InitFPImageWriter">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPortableNetworkGraphic.InitFPImageWriter.IntfImg">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPortableNetworkGraphic.InitFPImageWriter.ImgWriter">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TGraphic.GetFileExtensions" name="TPortableAnyMapGraphic.GetFileExtensions">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPortableAnyMapGraphic.GetFileExtensions.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TPortableAnyMapGraphic.GetDefaultFPReader">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPortableAnyMapGraphic.GetDefaultFPReader.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TPortableAnyMapGraphic.GetDefaultFPWriter">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPortableAnyMapGraphic.GetDefaultFPWriter.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TIcon.GetBitmapNativeType">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TIcon.GetBitmapNativeType.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TIcon.InitFPImageReader.IntfImg">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TIcon.LazarusResourceTypeValid">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TIcon.LazarusResourceTypeValid.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TIcon.LazarusResourceTypeValid.ResourceType">
        <short/>
      </element>
      <!-- class Visibility: default -->
      <element name="TCursorImage">
        <short>
          <var>TCursorImage</var> - an Icon to be used to represent a cursor</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCursorImage.FHotSpot">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCursorImage.FCursorHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCursorImage.FOwnHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCursorImage.GetBitmapNativeType">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCursorImage.GetBitmapNativeType.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCursorImage.GetCursorHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCursorImage.GetCursorHandle.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCursorImage.CursorHandleNeeded">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TCursorImage.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TCursorImage.Destroy">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TGraphic.GetFileExtensions" name="TCursorImage.GetFileExtensions">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCursorImage.GetFileExtensions.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TGraphic.LazarusResourceTypeValid" name="TCursorImage.LazarusResourceTypeValid">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCursorImage.LazarusResourceTypeValid.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCursorImage.LazarusResourceTypeValid.ResourceType">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TCursorImage.ReleaseCursorHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCursorImage.ReleaseCursorHandle.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCursorImage.HotSpot">
        <short>
          <var>HotSpot</var> - the coordinates of the point to which the cursor refers, and which represents the 'active' position on the current form or canvas</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCursorImage.CursorHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TJPEGQualityRange">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TJPEGPerformance">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TJPEGImage.FGrayScale">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TJPEGImage.FPerformance">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TJPEGImage.FProgressiveEncoding">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TJPEGImage.FQuality">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TJPEGImage.InitFPImageReader.IntfImg">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TJPEGImage.InitFPImageReader.ImgReader">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TJPEGImage.FinalizeFPImageReader.ImgReader">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TJPEGImage.InitFPImageWriter.IntfImg">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TJPEGImage.InitFPImageWriter.ImgWriter">
        <short/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TJPEGImage.GetFileExtensions.Result">
        <short/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TJPEGImage.GetDefaultFPReader.Result">
        <short/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TJPEGImage.GetDefaultFPWriter.Result">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="IdentEntry">
        <short>
          <var>IdentEntry</var> - checks that a given Entry exists in a Map of  colour names</short>
        <descr>
          <p>
            <var>IdentEntry</var> - checks that a given Entry exists in a Map of  colour names
</p>
          <p>A list of system <var>Colors</var> is specified as a look-up table of indices (Entry) and names (MapEntry)</p>
          <p>This function checks that the value in 
          
          <var>Entry</var> is within the permitted range, and returns the data pair 
          
          <var>Value</var>, 
          
          <var>Name</var> of the corresponding colour in 
          
          <var>MapEntry</var>.
</p>
          <p>If <var>Entry</var> is out of range the Result is False</p>
        </descr>
        <errors>If <var>Entry</var> is out of the range [0..High(Colours)] the Result is returned as False
</errors>
      </element>
      <!-- function result Visibility: default -->
      <element name="IdentEntry.Result">
        <short>True if <var>Entry</var> was a valid index into the Colour look-up table</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="IdentEntry.Entry">
        <short>
          <var>Entry</var> - a numeric index into the table of colours</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="IdentEntry.MapEntry">
        <short>
          <var>MapEntry</var> - the record of 
          
          
          <var>Value</var>, 
          
          
          <var>Name</var> returned from the look-up table of 
          
          
          <var>Colors</var>
        </short>
      </element>
      <!-- function result Visibility: default -->
      <element name="InvertColor.Result">
        <short>Returns the inverse of the original colour (ie a 'negative' effect)</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="InvertColor.AColor">
        <short>
          <var>AColor</var> - the original colour for processing</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="DecColor.Result">
        <short>Returns a copy of the original colour, decremented by a specified amount</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="DecColor.AColor">
        <short>
          <var>AColor</var> - the original colour for processing</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="DecColor.AQuantity">
        <short>
          <var>AQuantity</var> - the amount by which the colour is to be changed</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="RGBToColor.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="RGBToColor.R">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="RGBToColor.G">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="RGBToColor.B">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="FontNameToPangoFontDescStr">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="FontNameToPangoFontDescStr.LongFontName">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="FontNameToPangoFontDescStr.aFamily">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="FontNameToPangoFontDescStr.aStyle">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="FontNameToPangoFontDescStr.aSize">
        <short/>
      </element>
      <!-- variable Visibility: default -->
      <element name="OnLoadSaveClipBrdGraphicValid">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: default -->
      <element name="TestStreamIsCursor">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TestStreamIsCursor.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TestStreamIsCursor.AStream">
        <short/>
      </element>
      <!-- function result Visibility: default -->
      <element name="LoadCursorFromLazarusResource.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="LoadCursorFromLazarusResource.ACursorName">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="LoadBitmapFromLazarusResource">
        <short>Deprecated - technically a bitmap is created, not loaded</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="LoadBitmapFromLazarusResource.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="LoadBitmapFromLazarusResource.ResourceName">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="LoadBitmapFromLazarusResourceHandle">
        <short>Deprecated - technically a bitmap is created, not loaded</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="LoadBitmapFromLazarusResourceHandle.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="LoadBitmapFromLazarusResourceHandle.Handle">
        <short/>
      </element>
      <!-- function result Visibility: default -->
      <element name="CreateBitmapFromLazarusResource.Result">
        <short>Returns a Bitmap of type <var>TCustomBitMap</var><var/>
        </short>
      </element>
      <!-- argument Visibility: default -->
      <element name="CreateBitmapFromLazarusResource.AName">
        <short>
          <var>AName</var> - name of the bitmap to be created</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="CreateBitmapFromLazarusResource.AMinimumClass">
        <short>
          <var>AMinimumClass</var> - optional specifier for class of resource</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="CreateBitmapFromLazarusResource.AHandle">
        <short>
          <var>AHandle</var> - optional handle supplied for resource</short>
      </element>
      <!-- function Visibility: default -->
      <element name="DbgS">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="DbgS.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="DbgS.Style">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="UpdateHandleObjects">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TCustomBitmap.CanReadGraphicStreams">
        <short>Determine whether this instance of the class can read graphic streams</short>
      </element>
      <element name="TCustomBitmap.CanReadGraphicStreams.AClass">
        <short>Class of image processor to be used for reading the bitmap</short>
      </element>
      <element name="TCustomBitmap.CanReadGraphicStreams.Result">
        <short>Returns True if the supplied class is capable of reading graphic streams</short>
      </element>
      <!-- class Visibility: default -->
      <element name="EGraphicException">
        <short>
          <var>EGraphicException</var> - exception handler for error in graphics</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- class Visibility: default -->
      <element name="TSharedRasterImage">
        <short>
          <var>TSharedRasterImage</var> - a reference counted raster image (may be shared between several controls)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSharedRasterImage.FHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSharedRasterImage.FBitmapCanvas">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSharedRasterImage.FSaveStream">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TSharedImage.FreeHandle" name="TSharedRasterImage.FreeHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TSharedRasterImage.ReleaseHandle">
        <short>
          <var>ReleaseHandle</var> - returns the identity of the handle that has just been released</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSharedRasterImage.ReleaseHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TSharedRasterImage.IsEmpty">
        <short>
          <var>IsEmpty</var> - checks if there is actually an image at the reference, and returns True if there is not</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSharedRasterImage.IsEmpty.Result">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element link="#rtl.System.TObject.Create" name="TSharedRasterImage.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TSharedRasterImage.CreateDefaultHandle">
        <short>
          <var>CreateDefaultHandle</var> - virtual abstract method for creating a default handle for the shared raster image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSharedRasterImage.CreateDefaultHandle.AWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSharedRasterImage.CreateDefaultHandle.AHeight">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSharedRasterImage.CreateDefaultHandle.ABPP">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element link="#rtl.System.TObject.Destroy" name="TSharedRasterImage.Destroy">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TSharedImage.HandleAllocated" name="TSharedRasterImage.HandleAllocated">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSharedRasterImage.HandleAllocated.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSharedRasterImage.BitmapCanvas">
        <short>
          <var>BitmapCanvas</var> - the canvas to be used for painting this bitmap</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSharedRasterImage.SaveStream">
        <short>
          <var>SaveStream</var> - the memory stream to be used for saving this image</short>
        <descr/>
        <seealso/>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TSharedRasterImageClass">
        <short>
          <var>TSharedRasterImageClass</var> - class of 
          <var>TSharedRasterImage</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- class Visibility: default -->
      <element name="TRasterImage">
        <short>
          <var>TRasterImage</var> - base class for a number of graphic controls, including 
          <var>TCustomBitmap</var> and 
          <var>TCustomIcon</var>, which use a raster of dots to display graphic information</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TRasterImage.FCanvas">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TRasterImage.FSharedImage">
        <short>
          <var>FSharedImage</var> - local variable for storing a shared raster image</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TRasterImage.FTransparentColor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TRasterImage.FTransparentMode">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TRasterImage.FInternalState">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TRasterImage.CreateCanvas">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TRasterImage.CreateMask">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.CreateMask.AColor">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TRasterImage.FreeCanvasContext">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TRasterImage.GetCanvas">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.GetCanvas.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TRasterImage.SetTransparentColor">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.SetTransparentColor.AValue">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TRasterImage.CanShareImage">
        <short>
          <var>CanShareImage</var> - returns True if specified class of image can be shared</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.CanShareImage.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.CanShareImage.AClass">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRasterImage.Changed">
        <short>
          <var>Changed</var> - method to call when properties have changed</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Graphics.TGraphic.Changed">TGraphic.Changed</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.Changed.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRasterImage.Changing">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.Changing.Sender">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TRasterImage.CreateDefaultBitmapHandle">
        <short>
          <var>CreateDefaultBitmapHandle</var> - returns a bitmap handle matching the description 
          <var>ADesc</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.CreateDefaultBitmapHandle.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.CreateDefaultBitmapHandle.ADesc">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TGraphic.Draw" name="TRasterImage.Draw">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.Draw.DestCanvas">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.Draw.DestRect">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TGraphic.GetEmpty" name="TRasterImage.GetEmpty">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.GetEmpty.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TRasterImage.GetHandle">
        <short>
          <var>GetHandle</var> - returns the Handle for the Image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.GetHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TRasterImage.GetBitmapHandle">
        <short>
          <var>GetBitmapHandle</var> - returns a Birmap Handle for the Image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.GetBitmapHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TRasterImage.GetMaskHandle">
        <short>
          <var>GetMaskHandle</var> - returns a bitmap handle for the Mask</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.GetMaskHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TGraphic.GetMimeType" name="TRasterImage.GetMimeType">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.GetMimeType.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TRasterImage.GetPixelFormat">
        <short>
          <var>GetPixelFormat</var> - returns the pixel format for the Image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.GetPixelFormat.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TRasterImage.GetRawImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.GetRawImage.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TRasterImage.GetRawImageDescription">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.GetRawImageDescription.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TGraphic.GetTransparent" name="TRasterImage.GetTransparent">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.GetTransparent.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TRasterImage.GetSharedImageClass">
        <short>
          <var>GetSharedImageClass</var> - returns the class of Shared Raster Image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.GetSharedImageClass.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TGraphic.GetHeight" name="TRasterImage.GetHeight">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.GetHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TGraphic.GetWidth" name="TRasterImage.GetWidth">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.GetWidth.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRasterImage.BitmapHandleNeeded">
        <short>
          <var>BitmapHandleNeeded</var> - method to signal that a bitmap handle is requires</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRasterImage.HandleNeeded">
        <short>
          <var>HandleNeeded</var> - method to signal that a handle is required</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRasterImage.MaskHandleNeeded">
        <short>
          <var>MaskHandleNeeded</var> - method to signal that a handle is required for the Mask</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRasterImage.PaletteNeeded">
        <short>
          <var>PaletteNeeded</var> - method to signal that a Palette is required</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TRasterImage.InternalReleaseBitmapHandle">
        <short>
          <var>InternalReleaseBitmapHandle</var> - releases Bitmap Handle and returns its value</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.InternalReleaseBitmapHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TRasterImage.InternalReleaseMaskHandle">
        <short>
          <var>InternalReleaseMaskHandle</var> - releases Mask Handle and returns its value</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.InternalReleaseMaskHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TRasterImage.InternalReleasePalette">
        <short>
          <var>InternalReleasePalette</var> - releases Palette Handle and returns its value</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.InternalReleasePalette.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRasterImage.SetBitmapHandle">
        <short>
          <var>SetBitmapHandle</var> - specifies a handle for Bitmap</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.SetBitmapHandle.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRasterImage.SetMaskHandle">
        <short>
          <var>SetMaskHandle</var> - specifies a Handle for the Mask</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.SetMaskHandle.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRasterImage.UnshareImage">
        <short>
          <var>UnshareImage</var> - stops an image from being shared: if 
          <var>CopyContent</var> is True, the Image gets copied</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.UnshareImage.CopyContent">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TRasterImage.UpdateHandles">
        <short>
          <var>UpdateHandles</var> -  called when handles are created from rawimage (true when handle changed)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.UpdateHandles.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.UpdateHandles.ABitmap">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.UpdateHandles.AMask">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRasterImage.SaveStreamNeeded">
        <short>
          <var>SaveStreamNeeded</var> - method to signal that a stream for saving is required</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRasterImage.FreeSaveStream">
        <short>
          <var>FreeSaveStream</var> - method to release a stream previously used for saving</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TGraphic.ReadData" name="TRasterImage.ReadData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.ReadData.Stream">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRasterImage.ReadStream">
        <short>
          <var>ReadStream</var> - loads imagedata into rawimage, this method shouldn't call changed()</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.ReadStream.AStream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.ReadStream.ASize">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRasterImage.SetSize">
        <short>
          <var>SetSize</var> - specifies height and width of Image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.SetSize.AWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.SetSize.AHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRasterImage.SetHandle">
        <short>
          <var>SetHandle</var> - specifies Handle for Image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.SetHandle.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TGraphic.SetHeight" name="TRasterImage.SetHeight">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.SetHeight.AHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TGraphic.SetWidth" name="TRasterImage.SetWidth">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.SetWidth.AWidth">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRasterImage.SetTransparentMode">
        <short>
          <var>SetTransparentMode</var> - specifies which transparent mode to use</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.SetTransparentMode.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRasterImage.SetPixelFormat">
        <short>
          <var>SetPixelFormat</var> - specifies the format for Pixels in this Image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.SetPixelFormat.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TGraphic.WriteData" name="TRasterImage.WriteData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.WriteData.Stream">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TRasterImage.WriteStream">
        <short>
          <var>WriteStream</var> - specifies which stream to be used for writing</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.WriteStream.AStream">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element link="#LCL.Graphics.TGraphic.Create" name="TRasterImage.Create">
        <short/>
        <descr/>
        <errors/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TRasterImage.Destroy">
        <short>
          <var>Destroy</var> - destructor for 
          <var>TRasterImage</var>: frees canvas, releases image then calls inherited 
          <var>Destroy</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Destroy">TPersistent.Destroy</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TRasterImage.Assign">
        <short>
          <var>Assign</var> - copies details from Source according to data type</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Graphics.TGraphic.Assign">TGraphic.Assign</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.Assign.Source">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Graphics.TGraphic.Clear" name="TRasterImage.Clear">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TRasterImage.FreeImage">
        <short>
          <var>FreeImage</var> - method for freeing or detaching image from the Raster</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TRasterImage.BitmapHandleAllocated">
        <short>
          <var>BitmapHandleAllocated</var> - returns True if a handle has been allocated for the Bitmap</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.BitmapHandleAllocated.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TRasterImage.MaskHandleAllocated">
        <short>
          <var>MaskHandleAllocated</var> - returns True if a handle has been allocated for the Mask</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.MaskHandleAllocated.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TRasterImage.PaletteAllocated">
        <short>
          <var>PaletteAllocated</var> - returns True if a Palette has been allocated</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.PaletteAllocated.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TRasterImage.LoadFromBitmapHandles">
        <short>
          <var>LoadFromBitmapHandles</var> - loads the data from the Bitmap and Mask specified by their handles</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.LoadFromBitmapHandles.ABitmap">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.LoadFromBitmapHandles.AMask">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.LoadFromBitmapHandles.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TRasterImage.LoadFromDevice">
        <short>
          <var>LoadFromDevice</var> - loads data from the device specified by its handle DC</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.LoadFromDevice.DC">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TRasterImage.LoadFromStream">
        <short>
          <var>LoadFromStream</var> - loads data for the image from a specified data stream, optionally supplying its size</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.LoadFromStream.AStream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.LoadFromStream.ASize">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TRasterImage.LoadFromMimeStream">
        <short>
          <var>LoadFromMimeStream</var> - loads data for the image from a specified MIME stream</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Graphics.TGraphic.LoadFromMimeStream">TGraphic.LoadFromMimeStream</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.LoadFromMimeStream.AStream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.LoadFromMimeStream.AMimeType">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TRasterImage.LoadFromIntfImage">
        <short>
          <var>LoadFromIntfImage</var> - loads image data from an Interface stream</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.LoadFromIntfImage.IntfImage">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TRasterImage.SaveToStream">
        <descr>
          <var>SaveToStream</var> - write graphic data to a stream
</descr>
        <errors/>
        <seealso>
          <link id="#LCL.Graphics.TGraphic.SaveToStream">TGraphic.SaveToStream</link>
        </seealso>
        <short>
          <var>SaveToStream</var> - write graphic data to a stream, with many error checks</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.SaveToStream.AStream">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TRasterImage.GetSupportedSourceMimeTypes">
        <short>
          <var>GetSupportedSourceMimeTypes</var> calls inherited method and allows addition of extra types not specified there</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Graphics.TGraphic.GetSupportedSourceMimeTypes">TGraphic.GetSupportedSourceMimeTypes</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.GetSupportedSourceMimeTypes.List">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TRasterImage.Mask">
        <short>The <var>Mask</var> to be used with the Image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.Mask.ATransparentColor">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TRasterImage.SetHandles">
        <short>
          <var>SetHandles</var> - allows the user to specify handles</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.SetHandles.ABitmap">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TRasterImage.SetHandles.AMask">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TRasterImage.ReleaseBitmapHandle">
        <short>
          <var>ReleaseBitmapHandle</var> - releases the handle used by the Bitmap</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.ReleaseBitmapHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TRasterImage.ReleaseMaskHandle">
        <short>
          <var>ReleaseMaskHandle</var> - releases the Handle used for the Mask</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.ReleaseMaskHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TRasterImage.ReleasePalette">
        <short>
          <var>ReleasePalette</var> - release the Handle used for the Palettte</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.ReleasePalette.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TRasterImage.CreateIntfImage">
        <short>
          <var>CreateIntfImage</var> - creates an image on the Interface</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.CreateIntfImage.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TRasterImage.Canvas">
        <short>The <var>Canvas</var> on which this raster image is to be painted</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TRasterImage.HandleAllocated">
        <short>
          <var>HandleAllocated</var> - if True, an Operating System handle has been allocated</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TRasterImage.HandleAllocated.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TRasterImage.BitmapHandle">
        <short>
          <var>BitmapHandle</var> - the Handle that has been allocated for the Bitmap</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TRasterImage.MaskHandle">
        <short>
          <var>MaskHandle</var> - the handle that has been allocated for the Bitmap Mask</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TRasterImage.PixelFormat">
        <short>
          <var>PixelFormat</var> - the format of the Pixels in this Image</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TRasterImage.TransparentColor">
        <short>
          <var>TransparentColor</var> - the colour used in transparent mode</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TRasterImage.TransparentMode">
        <short>In <var>TransparentMode</var> it is possible to see the underlying objects through the current image</short>
        <descr/>
        <seealso/>
      </element>
      <!-- class Visibility: default -->
      <element name="TSharedCustomBitmap">
        <short>
          <var>TSharedCustomBitmap</var> - a reference counted base  class for TSharedBitmap, TSharedPixmap, TSharedJPEGImage, TSharedPortableNetworkGraphic and TSharedPortableAnyMapGraphic</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSharedCustomBitmap.FHandleType">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSharedCustomBitmap.FImage">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSharedCustomBitmap.FHasMask">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSharedCustomBitmap.FPalette">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TSharedCustomBitmap.GetHeight">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSharedCustomBitmap.GetHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TSharedCustomBitmap.GetWidth">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSharedCustomBitmap.GetWidth.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSharedCustomBitmap.FreeHandle">
        <short>
          <var>FreeHandle</var> frees Palette then calls inherited 
          <var>FreeHandle</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Graphics.TSharedImage.FreeHandle">TSharedImage.FreeHandle</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSharedCustomBitmap.FreePalette">
        <short>
          <var>FreePalette</var> - release the Palette</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSharedCustomBitmap.FreeImage">
        <short>
          <var>FreeImage</var> - release the Image from the Bitmap</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TSharedCustomBitmap.ReleasePalette">
        <short>
          <var>ReleasePalette</var> - returns the Handle of the released Palette</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSharedCustomBitmap.ReleasePalette.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TSharedCustomBitmap.GetPixelFormat">
        <short>
          <var>GetPixelFormat</var> - returns the format for the Pixels in this Bitmap</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSharedCustomBitmap.GetPixelFormat.Result">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TSharedCustomBitmap.Create">
        <short>
          <var>Create</var> - constructor for 
          <var>TSharedCustomBitmap</var>: calls inherited 
          <var>Create</var> and initialises the image</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TSharedCustomBitmap.Destroy">
        <short>
          <var>Destroy</var> - destructor for 
          <var>TSharedCustomBitmap</var>: frees stream, handle and image, then calls inherited 
          <var>Destroy</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.System.TObject.Destroy">TObject.Destroy</link>
        </seealso>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TSharedImage.HandleAllocated" name="TSharedCustomBitmap.HandleAllocated">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSharedCustomBitmap.HandleAllocated.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TSharedCustomBitmap.ImageAllocated">
        <short>
          <var>ImageAllocated</var> - returns True if an image has been allocated</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSharedCustomBitmap.ImageAllocated.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSharedCustomBitmap.HandleType">
        <short>
          <var>HandleType</var> the type of Bitmap Handle that has been allocated</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSharedCustomBitmap.Height">
        <short>The <var>Height</var> of the Bitmap</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSharedCustomBitmap.Width">
        <short>The <var>Width</var> of the Bitmap</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomBitmap.FMaskHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomBitmap.SetBitmapHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetBitmapHandle.AValue">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetHandleType.AValue">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.CanShareImage" name="TCustomBitmap.CanShareImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.CanShareImage.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.CanShareImage.AClass">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.CreateDefaultBitmapHandle" name="TCustomBitmap.CreateDefaultBitmapHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.CreateDefaultBitmapHandle.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.CreateDefaultBitmapHandle.ADesc">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.GetBitmapHandle" name="TCustomBitmap.GetBitmapHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetBitmapHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.GetPixelFormat" name="TCustomBitmap.GetPixelFormat">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetPixelFormat.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomBitmap.GetRawImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetRawImage.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomBitmap.GetRawImageDescription">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.GetRawImageDescription.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.InternalReleaseBitmapHandle" name="TCustomBitmap.InternalReleaseBitmapHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.InternalReleaseBitmapHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.InternalReleaseMaskHandle" name="TCustomBitmap.InternalReleaseMaskHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.InternalReleaseMaskHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.InternalReleasePalette" name="TCustomBitmap.InternalReleasePalette">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.InternalReleasePalette.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomBitmap.RawimageNeeded">
        <short>
          <var>RawimageNeeded</var> - method to signal that a raw image is required; if 
          <var>ADescOnly</var> is True, only a descriptor is required</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.RawimageNeeded.ADescOnly">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetHandle.AValue">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.UpdateHandles" name="TCustomBitmap.UpdateHandles">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.UpdateHandles.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.UpdateHandles.ABitmap">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.UpdateHandles.AMask">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TRasterImage.BitmapHandleAllocated" name="TCustomBitmap.BitmapHandleAllocated">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomBitmap.BitmapHandleAllocated.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomBitmap.SetSize">
        <short>
          <var>SetSize</var> - allows the user to specify the size of the Bitmap</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Graphics.TRasterImage.SetSize">TRasterImage.SetSize</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetSize.AWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomBitmap.SetSize.AHeight">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TGraphic.GetMimeType" name="TFPImageBitmap.GetMimeType">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFPImageBitmap.GetMimeType.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TFPImageBitmap.GetReaderClass">
        <short>
          <var>GetReaderClass</var> - returns the class of reader for acquiring data from a stream</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFPImageBitmap.GetReaderClass.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TFPImageBitmap.GetWriterClass">
        <short>
          <var>GetWriterClass</var> - returns the class of writer for storing data to a stream</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TFPImageBitmap.GetWriterClass.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFPImageBitmap.InitializeReader">
        <short>
          <var>InitializeReader</var> - starts up the specified reader to read th especified Image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.InitializeReader.AImage">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.InitializeReader.AReader">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFPImageBitmap.InitializeWriter">
        <short>
          <var>InitializeWriter</var> - starts up the specified writer to store the specified Image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.InitializeWriter.AImage">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.InitializeWriter.AWriter">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFPImageBitmap.FinalizeReader">
        <short>
          <var>FinalizeReader</var> - ends the Image reading process</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.FinalizeReader.AReader">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TFPImageBitmap.FinalizeWriter">
        <short>
          <var>FinalizeWriter</var> - ends the Image writing process</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.FinalizeWriter.AWriter">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.ReadStream.AStream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.ReadStream.ASize">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TFPImageBitmap.WriteStream.AStream">
        <short/>
      </element>
      <!-- class Visibility: default -->
      <element name="TSharedBitmap">
        <short>
          <var>TSharedBitmap</var> - a reference counted Bitmap graphic</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TFPImageBitmap.InitializeReader" name="TBitmap.InitializeReader">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.InitializeReader.AImage">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.InitializeReader.AReader">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TFPImageBitmap.InitializeWriter" name="TBitmap.InitializeWriter">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.InitializeWriter.AImage">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.InitializeWriter.AWriter">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBitmap.FinalizeReader">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBitmap.FinalizeReader.AReader">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TFPImageBitmap.GetReaderClass" name="TBitmap.GetReaderClass">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetReaderClass.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TFPImageBitmap.GetWriterClass" name="TBitmap.GetWriterClass">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetWriterClass.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.GetSharedImageClass" name="TBitmap.GetSharedImageClass">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TBitmap.GetSharedImageClass.Result">
        <short/>
      </element>
      <!-- class Visibility: default -->
      <element name="TSharedPixmap">
        <short>
          <var>TSharedPixmap</var> - a reference counted Pixmap graphic</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TFPImageBitmap.GetReaderClass" name="TPixmap.GetReaderClass">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPixmap.GetReaderClass.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TFPImageBitmap.GetWriterClass" name="TPixmap.GetWriterClass">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPixmap.GetWriterClass.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.GetSharedImageClass" name="TPixmap.GetSharedImageClass">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPixmap.GetSharedImageClass.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TGraphic.GetFileExtensions" name="TPixmap.GetFileExtensions">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPixmap.GetFileExtensions.Result">
        <short/>
      </element>
      <!-- class Visibility: default -->
      <element name="TSharedPortableNetworkGraphic">
        <short>
          <var>TSharedPortableNetworkGraphic</var> - a reference counted PNG Image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TFPImageBitmap.GetReaderClass" name="TPortableNetworkGraphic.GetReaderClass">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPortableNetworkGraphic.GetReaderClass.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TFPImageBitmap.GetWriterClass" name="TPortableNetworkGraphic.GetWriterClass">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPortableNetworkGraphic.GetWriterClass.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TFPImageBitmap.InitializeWriter" name="TPortableNetworkGraphic.InitializeWriter">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPortableNetworkGraphic.InitializeWriter.AImage">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TPortableNetworkGraphic.InitializeWriter.AWriter">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.GetSharedImageClass" name="TPortableNetworkGraphic.GetSharedImageClass">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPortableNetworkGraphic.GetSharedImageClass.Result">
        <short/>
      </element>
      <!-- class Visibility: default -->
      <element name="TSharedPortableAnyMapGraphic">
        <short>
          <var>TSharedPortableAnyMapGraphic</var> - a reference counted shared PAMG</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TFPImageBitmap.GetReaderClass" name="TPortableAnyMapGraphic.GetReaderClass">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPortableAnyMapGraphic.GetReaderClass.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TFPImageBitmap.GetWriterClass" name="TPortableAnyMapGraphic.GetWriterClass">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPortableAnyMapGraphic.GetWriterClass.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.GetSharedImageClass" name="TPortableAnyMapGraphic.GetSharedImageClass">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TPortableAnyMapGraphic.GetSharedImageClass.Result">
        <short/>
      </element>
      <!-- class Visibility: default -->
      <element name="TIconImage">
        <short>
          <var>TIconImage</var> - a primitive Icon class with handles for the Bitmap, Mask and Palette</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TIconImageClass">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- class Visibility: default -->
      <element name="TSharedIcon">
        <short>
          <var>TSharedIcon</var> - a reference counted shared Icon</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSharedIcon.FImages">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TSharedImage.FreeHandle" name="TSharedIcon.FreeHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TSharedIcon.GetImagesClass">
        <short>
          <var>GetImagesClass</var> - finds which class of icon images is being referenced</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSharedIcon.GetImagesClass.Result">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TSharedIcon.Create">
        <short>
          <var>Create</var> - constructor for 
          <var>TSharedIcon</var>: performs inherited 
          <var>Create</var> then creates a list of images</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TSharedIcon.Destroy">
        <short>
          <var>Destroy</var> - destructor for 
          <var>TSharedIcon</var>: frees the list of images and performs inherited 
          <var>Destroy</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.System.TObject.Destroy">TObject.Destroy</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TSharedIcon.Clear">
        <short>
          <var>Clear</var> - remove the icon and free its resources</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TSharedIcon.Delete">
        <short>
          <var>Delete</var> - remove the icon with specified index</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSharedIcon.Delete.Aindex">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TSharedIcon.GetIndex">
        <short>
          <var>GetIndex</var> - returns the Index of an image with specified pixel format, height and width</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSharedIcon.GetIndex.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSharedIcon.GetIndex.AFormat">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSharedIcon.GetIndex.AHeight">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSharedIcon.GetIndex.AWidth">
        <short/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TIconImage.FHeight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TIconImage.FPixelFormat">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TIconImage.FWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TIconImage.FImage">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TIconImage.FHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TIconImage.FMaskHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TIconImage.FPalette">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TIconImage.GetPalette">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TIconImage.GetPalette.Result">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TIconImage.Create">
        <short>
          <var>Create</var> - Specifies a Raw image to be used, then used Inherited Create</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TIconImage.Create.AFormat">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TIconImage.Create.AHeight">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TIconImage.Create.AWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TIconImage.Create.AImage">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element link="#rtl.System.TObject.Destroy" name="TIconImage.Destroy">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TIconImage.ReleaseHandle">
        <short>
          <var>ReleaseHandle</var> - returns Bitmap handle to Operating system</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TIconImage.ReleaseHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TIconImage.ReleaseMaskHandle">
        <short>
          <var>ReleaseMaskHandle</var> - returns mask Bitmap handle to operating system</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TIconImage.ReleaseMaskHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TIconImage.ReleasePalette">
        <short>
          <var>ReleasePalette</var> - returns Palette handle to operating system</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TIconImage.ReleasePalette.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TIconImage.UpdateHandles">
        <short>
          <var>UpdateHandles</var> - returns True when Bitmap and Mask handles have been updated</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TIconImage.UpdateHandles.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TIconImage.UpdateHandles.ABitmap">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TIconImage.UpdateHandles.AMask">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TIconImage.Height">
        <short>The <var>Height</var> of the Icon</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TIconImage.Width">
        <short>The <var>Width</var> of the Icon</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TIconImage.PixelFormat">
        <short>
          <var>PixelFormat</var> - the format of the Pixels in the Image</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TIconImage.Handle">
        <short>
          <var>Handle</var> - for the Bitmap</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TIconImage.MaskHandle">
        <short>
          <var>MaskHandle</var> - Bitmap handle for the Mask</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TIconImage.Palette">
        <short>Handle for the <var>Palette</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- class Visibility: default -->
      <element name="TCustomIcon">
        <short>
          <var>TCustomIcon</var> - base class for TIcon</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomIcon.FCurrent">
        <short>
          <var>FCurrent</var> - local variable to hold current sequence number</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TCustomIcon.GetCount">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.GetCount.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomIcon.SetCurrent">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.SetCurrent.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.MaskHandleNeeded" name="TCustomIcon.MaskHandleNeeded">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.PaletteNeeded" name="TCustomIcon.PaletteNeeded">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomIcon.GetIndex">
        <short>
          <var>GetIndex</var> - returns the Index value of the Icon with specified format and size (.icn files can contain several versions of image)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.GetIndex.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.GetIndex.AFormat">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.GetIndex.AHeight">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.GetIndex.AWidth">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.GetBitmapHandle" name="TCustomIcon.GetBitmapHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.GetBitmapHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.GetMaskHandle" name="TCustomIcon.GetMaskHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.GetMaskHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TGraphic.GetPalette" name="TCustomIcon.GetPalette">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.GetPalette.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.GetPixelFormat" name="TCustomIcon.GetPixelFormat">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.GetPixelFormat.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomIcon.GetRawImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.GetRawImage.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomIcon.GetRawImageDescription">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.GetRawImageDescription.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.GetSharedImageClass" name="TCustomIcon.GetSharedImageClass">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.GetSharedImageClass.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.HandleNeeded" name="TCustomIcon.HandleNeeded">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.InternalReleaseBitmapHandle" name="TCustomIcon.InternalReleaseBitmapHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.InternalReleaseBitmapHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.InternalReleaseMaskHandle" name="TCustomIcon.InternalReleaseMaskHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.InternalReleaseMaskHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.InternalReleasePalette" name="TCustomIcon.InternalReleasePalette">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.InternalReleasePalette.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TGraphic.ReadData" name="TCustomIcon.ReadData">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.ReadData.Stream">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.ReadStream" name="TCustomIcon.ReadStream">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.ReadStream.AStream">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.ReadStream.ASize">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.SetPixelFormat" name="TCustomIcon.SetPixelFormat">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.SetPixelFormat.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.UnshareImage" name="TCustomIcon.UnshareImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.UnshareImage.CopyContent">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomIcon.UpdateCurrentView">
        <short>
          <var>UpdateCurrentView</var> - updates the current appearance of the Icon</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.UpdateHandles" name="TCustomIcon.UpdateHandles">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.UpdateHandles.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.UpdateHandles.ABitmap">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.UpdateHandles.AMask">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.WriteStream" name="TCustomIcon.WriteStream">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.WriteStream.AStream">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element link="#LCL.Graphics.TGraphic.Create" name="TCustomIcon.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomIcon.Add">
        <short>
          <var>Add</var> - an Icon formatted as 
          <var>AFormat</var>, with specified 
          <var>Height</var> and 
          <var>Width</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.Add.AFormat">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.Add.AHeight">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.Add.AWidth">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomIcon.Assign">
        <short>
          <var>Assign</var> checks if Source is correct data type, then copies image data</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Assign">TPersistent.Assign</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.Assign.Source">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomIcon.Clear">
        <short>
          <var>Clear</var> the Icon and release its resources</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Graphics.TGraphic.Clear">TGraphic.Clear</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomIcon.Delete">
        <short>
          <var>Delete</var> the indexed Icon</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.Delete.Aindex">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomIcon.Remove">
        <short>
          <var>Remove</var> the Icon specified by 
          <var>AFormat</var>, 
          <var>AHeight</var> and 
          <var>AWidth</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.Remove.AFormat">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.Remove.AHeight">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.Remove.AWidth">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomIcon.GetDescription">
        <short>
          <var>GetDescription</var> - find the description for the Icon</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.GetDescription.Aindex">
        <short>
          <var>Aindex</var> - the Index value for the Icon</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.GetDescription.AFormat">
        <short>
          <var>AFormat</var> - the Pixel Format for the Icon</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.GetDescription.AHeight">
        <short>
          <var>AHeight</var> - the height of the Icon</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.GetDescription.AWidth">
        <short>
          <var>AWidth</var> - the width of the Icon</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomIcon.SetSize">
        <short>
          <var>SetSize</var> - write the size (width, height) of the Icon</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Graphics.TRasterImage.SetSize">TRasterImage.SetSize</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.SetSize.AWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.SetSize.AHeight">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TCustomIcon.GetFileExtensions">
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Graphics.TGraphic.GetFileExtensions">TGraphic.GetFileExtensions</link>
        </seealso>
        <short>
          <var>GetFileExtensions</var> returns valid file extensions, in this case 'ico'</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.GetFileExtensions.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TGraphic.LazarusResourceTypeValid" name="TCustomIcon.LazarusResourceTypeValid">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.LazarusResourceTypeValid.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.LazarusResourceTypeValid.ResourceType">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TRasterImage.BitmapHandleAllocated" name="TCustomIcon.BitmapHandleAllocated">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.BitmapHandleAllocated.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TRasterImage.MaskHandleAllocated" name="TCustomIcon.MaskHandleAllocated">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.MaskHandleAllocated.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Graphics.TRasterImage.PaletteAllocated" name="TCustomIcon.PaletteAllocated">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCustomIcon.PaletteAllocated.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Graphics.TRasterImage.SetHandles" name="TCustomIcon.SetHandles">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.SetHandles.ABitmap">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomIcon.SetHandles.AMask">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomIcon.Current">
        <short>
          <var>Current</var> - the sequence number of the current Icon</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomIcon.Count">
        <short>
          <var>Count</var> - the number of references to this Icon</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TIcon.GetIconHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TIcon.GetIconHandle.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TIcon.SetIconHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TIcon.SetIconHandle.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.HandleNeeded" name="TIcon.HandleNeeded">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TIcon.ReleaseHandle">
        <short>
          <var>ReleaseHandle</var> - frees the handle that was iused for the Icon</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TIcon.ReleaseHandle.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TIcon.Handle">
        <short>The Operating System <var>Handle</var> used for the Icon</short>
        <descr/>
        <seealso/>
      </element>
      <!-- class Visibility: default -->
      <element name="TSharedCursorImage">
        <short>
          <var>TSharedCursorImage</var> - a reference counted shared image to be used for cursors</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TSharedImage.FreeHandle" name="TSharedCursorImage.FreeHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TSharedIcon.GetImagesClass" name="TSharedCursorImage.GetImagesClass">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSharedCursorImage.GetImagesClass.Result">
        <short/>
      </element>
      <!-- class Visibility: default -->
      <element name="TCursorImageImage">
        <short>
          <var>TCursorImageImage</var> - the image for a cursor, stored as an Icon</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCursorImageImage.FHotSpot">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCursorImageImage.HotSpot">
        <short>
          <var>HotSpot</var> - the coordinates of the point to which the cursor refers, and which represents the 'active' position on the current form or canvas</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TCursorImage.GetHotSpot">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCursorImage.GetHotSpot.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCursorImage.SetCursorHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCursorImage.SetCursorHandle.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.HandleNeeded" name="TCursorImage.HandleNeeded">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.GetSharedImageClass" name="TCursorImage.GetSharedImageClass">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCursorImage.GetSharedImageClass.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TCursorImage.ReleaseHandle">
        <short>
          <var>ReleaseHandle</var> - free the handle used for the cursor Image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TCursorImage.ReleaseHandle.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCursorImage.Handle">
        <short>The Operating System <var>Handle</var> allocated for this cursor</short>
        <descr/>
        <seealso/>
      </element>
      <!-- class Visibility: default -->
      <element name="TSharedJpegImage">
        <short>
          <var>TSharedJpegImage</var> - a reference counted shared image of type JPEG</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TFPImageBitmap.InitializeReader" name="TJPEGImage.InitializeReader">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TJPEGImage.InitializeReader.AImage">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TJPEGImage.InitializeReader.AReader">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TFPImageBitmap.InitializeWriter" name="TJPEGImage.InitializeWriter">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TJPEGImage.InitializeWriter.AImage">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TJPEGImage.InitializeWriter.AWriter">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TFPImageBitmap.FinalizeReader" name="TJPEGImage.FinalizeReader">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TJPEGImage.FinalizeReader.AReader">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TFPImageBitmap.GetReaderClass" name="TJPEGImage.GetReaderClass">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TJPEGImage.GetReaderClass.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TFPImageBitmap.GetWriterClass" name="TJPEGImage.GetWriterClass">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TJPEGImage.GetWriterClass.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Graphics.TRasterImage.GetSharedImageClass" name="TJPEGImage.GetSharedImageClass">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TJPEGImage.GetSharedImageClass.Result">
        <short/>
      </element>
      <element name="TSharedIcon.Add">
        <short>
          <var>Add</var> a reference to the shared icon</short>
      </element>
      <element name="TSharedIcon.Count">
        <short>
          <var>Count</var> - returns the number of references to the shared icon</short>
      </element>
      <element name="TRasterImage.BeginUpdate">
        <short>
          <var>BeginUpdate</var> - start the update process</short>
        <descr>
          <var>BeginUpdate</var> - start the update process; by default the boolean argument 
          <var>ACanvasOnly</var> is False, ie more than just the Canvas is to be updated
</descr>
      </element>
      <element name="TRasterImage.EndUpdate">
        <short>
          <var>EndUpdate</var> - finishes the update process</short>
        <descr>
          <var>EndUpdate</var> - finishes the update process. By default the boolean argument 
          <var>AStreamIsValid</var> is False, ie no stream is valid at the end of the process.
be carefull with this, modify only within a begin/endupdate</descr>
      </element>
      <element name="TRasterImage.GetSize">
        <short>
          <var>GetSize</var> - finds the size of the Image</short>
      </element>
      <element name="TRasterImage.Masked">
        <short>
          <var>Masked</var> - returns True if a Mask is being applied</short>
      </element>
      <element name="TRasterImage.RawImage">
        <short>
          <var>RawImage</var> - allows the user to access the Raw Image: CAUTION!</short>
        <descr>
          <var>RawImage</var> - allows the user to access the Raw Image: CAUTION! Modify only within a begin/endupdate.</descr>
      </element>
      <element name="TSharedCustomBitmap.PixelFormat">
        <short>
          <var>PixelFormat</var> - the format for the Pixels in this Bitmap</short>
      </element>
      <element link="#LCL.Graphics.TGraphic.Clear" name="TCustomBitmap.Clear"/>
      <element name="TIconImage.RawImageNeeded">
        <short>
          <var>RawImageNeeded</var> - if 
          <var>ADescOnly</var> is True (descriptor only), then we need a Raw Image</short>
      </element>
      <element name="TCustomIcon.AssignImage">
        <short>
          <var>AssignImage</var> - copies information from the source image to the current one</short>
      </element>
      <element name="TCustomIcon.GetBestIndexForSize">
        <short>
          <var>GetBestIndexForSize</var> - returns the best estimate of the index value for size</short>
      </element>
      <element name="TRasterImage.GetMasked">
        <short>
          <var>GetMasked</var> - returns True if the Image is Masked</short>
      </element>
      <element name="TRasterImage.GetRawImagePtr">
        <short>
          <var>GetRawImagePtr</var> - returns a pointer to the Raw Image</short>
      </element>
      <element name="TRasterImage.GetRawImageDescriptionPtr">
        <short>
          <var>GetRawImageDescriptionPtr</var> - returns a pointer to a raw image description</short>
      </element>
      <element name="TRasterImage.SetMasked">
        <short>
          <var>SetMasked</var> - specifies if the image is to be masked</short>
      </element>
      <element link="#LCL.Graphics.TGraphic.SetTransparent" name="TRasterImage.SetTransparent"/>
      <element name="TRasterImage.RequestTransparentColor">
        <short>
          <var>RequestTransparentColor</var> - returns a color to be used for transparent Images</short>
      </element>
      <element link="#LCL.Graphics.TSharedRasterImage.IsEmpty" name="TSharedCustomBitmap.IsEmpty"/>
      <element name="TCustomBitmap.FPixelFormatNeedsUpdate"/>
      <element name="TCustomBitmap.FreeMaskHandle">
        <short>
          <var>FreeMaskHandle</var> - method to release Mask handle</short>
      </element>
      <element link="#LCL.Graphics.TRasterImage.GetRawImagePtr" name="TCustomBitmap.GetRawImagePtr"/>
      <element link="#LCL.Graphics.TRasterImage.GetRawImageDescriptionPtr" name="TCustomBitmap.GetRawImageDescriptionPtr"/>
      <element link="#LCL.Graphics.TSharedRasterImage.IsEmpty" name="TSharedIcon.IsEmpty"/>
      <element name="TCustomIcon.FRequestedSize">
        <short>
          <var>FRequestedSize</var> - local variable to hold requested size of Icon</short>
      </element>
      <element link="#LCL.Graphics.TRasterImage.CanShareImage" name="TCustomIcon.CanShareImage"/>
      <element name="TCustomIcon.CheckRequestedSize">
        <short>
          <var>CheckRequestedSize</var> - method to ensure correct size requested</short>
      </element>
      <element name="TCustomIcon.GetDefaultSize">
        <short>
          <var>GetDefaultSize</var> - returns default size for Icon</short>
      </element>
      <element link="#LCL.Graphics.TRasterImage.GetMasked" name="TCustomIcon.GetMasked"/>
      <element link="#LCL.Graphics.TRasterImage.GetRawImagePtr" name="TCustomIcon.GetRawImagePtr"/>
      <element link="#LCL.Graphics.TRasterImage.GetRawImageDescriptionPtr" name="TCustomIcon.GetRawImageDescriptionPtr"/>
      <element link="#LCL.Graphics.TGraphic.GetTransparent" name="TCustomIcon.GetTransparent"/>
      <element name="TCustomIcon.GetTypeID">
        <short>
          <var>GetTypeID</var> - returns Identifier for type of Icon</short>
      </element>
      <element link="#LCL.Graphics.TRasterImage.SetMasked" name="TCustomIcon.SetMasked"/>
      <element link="#LCL.Graphics.TRasterImage.SetTransparent" name="TCustomIcon.SetTransparent"/>
      <element link="#LCL.Graphics.TCustomIcon.GetTypeID" name="TIcon.GetTypeID"/>
      <element link="#LCL.Graphics.TCustomIcon.GetDefaultSize" name="TCursorImage.GetDefaultSize"/>
      <element link="#LCL.Graphics.TCustomIcon.GetTypeID" name="TCursorImage.GetTypeID"/>
      <element link="#LCL.Graphics.TRasterImage.GetSharedImageClass" name="TIcnsIcon.GetSharedImageClass"/>
      <element name="TFPImageBitmapClass">
        <short>
          <var>TFPImageBitmapClass</var> - class of 
          <var>TFPImageBitmap</var>
        </short>
      </element>
      <element link="#LCL.LCLResCache.TResourceCache.CompareDescriptors" name="TPenHandleCache.CompareDescriptors"/>
      <element name="TPenHandleCache.FindPen">
        <short>
          <var>FindPen</var> - returns a 
          <var>ResourceCacheItem</var> corresponding to the nominated Handle</short>
      </element>
      <element name="TPenHandleCache.FindPenDesc">
        <short>
          <var>FindPenDesc</var> - returns a descriptor for the given pen and pattern</short>
      </element>
      <element name="TPenHandleCache.Add">
        <short>
          <var>Add</var> - returns a cache descriptor corresponding to the pen that has been added to the cache</short>
      </element>
      <element name="TPen.SetEndCap">
        <short>
          <var>SetEndCap</var> - specified the type of end cap to be used for the pen, if it is a geometric pen</short>
      </element>
      <element name="TPen.SetJoinStyle">
        <short>
          <var>SetJoinStyle</var> - specifies the style to be used by the geometric pen when lines join (at corners etc)</short>
      </element>
      <element name="TPen.GetPattern">
        <short>
          <var>GetPattern</var> - returns the pattern for the pen</short>
      </element>
      <element name="TPen.SetPattern">
        <short>
          <var>SetPattern</var> - specifies the pattern for the pen</short>
      </element>
      <element name="TPen.Cosmetic">
        <short>Whether the Pen is <var>Cosmetic</var>, ie non-geometric</short>
        <descr>Pens can be Cosmetic and Geomeric. Cosmetic pens are always 1 pixel wide, while geometric pens can have any width. But width of geometric pens are defined in world units and thus depends on transforms (scaling, rotation, shear, reflection) applied to canvas. Operations with cosmetic pens are faster.</descr>
      </element>
      <element name="TPen.EndCap">
        <short>The sort of <var>EndCap</var> used on the Pen</short>
        <descr>The end cap can be: Round, Square and Flat. When end caps are round - last points are drawn round, when end caps are square - last points are drawn square. When end caps are flat - last points are not drawn at all.</descr>
      </element>
      <element name="TPen.JoinStyle">
        <short>
          <var>JoinStyle</var> - the style of joint where two lines meet or cross</short>
        <descr>The join style can be: Round, Bevel and Miter. When style is Round then line joins are round. When style is Bevel then line joins are beveled. When style is Miter then line joins are mitered.</descr>
      </element>
      <element name="TPenHandleCacheDescriptor">
        <short>
          <var>TPenHandleCacheDescriptor</var> - a cache descriptor for Pen Handles</short>
      </element>
      <element name="TPenHandleCacheDescriptor.ExtPen">
        <short>
          <var>ExtPen</var> - an external pen</short>
      </element>
      <element name="TPenHandleCacheDescriptor.Pattern">
        <short>The <var>Pattern</var> for this pen</short>
      </element>
      <element name="TCanvas.AntialiasingMode">
        <short>
          <var>AntialiasingMode</var> - anti-aliasing on, off or don't care</short>
      </element>
      <element name="TCanvas.RealizeAntialiasing">
        <short>
          <var>RealizeAntialiasing</var> - implement the Anti-aliasing feature</short>
      </element>
      <element name="TFont.GetOrientation">
        <short>
          <var>GetOrientation </var>- Returns the orientation for the font</short>
      </element>
      <element name="TFont.FontData">
        <short>
          <var>FontData</var> - the data describing the font</short>
      </element>
      <element name="TFont.Orientation">
        <short>The <var>Orientation</var> (wheteher horizontal or vertical etc) of the current font</short>
      </element>
      <element name="TCanvas.SetClipRect"/>
      <element name="TCanvas.GetClipping">
        <short>
          <var>GetClipping</var> returns True if clipping is being performed</short>
      </element>
      <element name="TCanvas.SetClipping">
        <short>
          <var>SetClipping</var> specifies (via boolean argument) whether clipping is to be performed</short>
      </element>
      <element name="TCanvas.TryLock">
        <short>
          <var>TryLock</var> - examines the Lock state, and performs Lock if necessary</short>
      </element>
    </module>
    <!-- Graphics -->
  </package>
</fpdoc-descriptions>
