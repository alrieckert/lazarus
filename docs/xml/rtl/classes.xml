<?xml version="1.0"?>
<fpdoc-descriptions>
  <package name="rtl">
    <module name="classes">
      <element name="TRTLCriticalSection">
        <short>A class for managing multiple threads</short>
        <descr>This class is not yet implemented.</descr>
      </element>
      <element name="HRSRC">
        <short>Type to manage resources</short>
        <descr>This type is provided for Delphi compatibilty, it is used for resource
streams.
</descr>
      </element>
      <element name="PStringItem">
        <short>Pointer to a <link id="TStringItem"/> record.
</short>
      </element>
      <element name="TStringItem">
        <short>The <var>TStringItem</var> is used to store the string and object items in a 
<link id="TStringList"/> string list instance. It should never be used
directly.
</short>
        <seealso>
          <link id="TStringList"/>
        </seealso>
      </element>
      <element name="TStringItem.FString">
        <short>Contains the string.
</short>
      </element>
      <element name="TStringItem.FObject">
        <short>Contains the object, if any.
</short>
      </element>
      <element name="THandle">
        <short>Type to manage streams.</short>
        <descr>This type is used as the handle for <link id="THandleStream">THandleStream</link> stream descendents</descr>
      </element>
      <element name="TComponentName">
        <short>Special type for component names.</short>
        <descr>Names of components are of type <var>TComponentName</var>. By
specifying a different type, the Object inspector can handle this property
differently than a standard string property. 
</descr>
      </element>
      <element name="IUnknown">
        <short>
          <var>IUnknown</var> Interface</short>
        <descr>IUknown is not yet implemented since interfaces are not yet supported
by FPC.
</descr>
      </element>
      <element name="TGUID">
        <short>Special type for GUID's.</short>
        <descr>FPC doesn't support GUID yet.
</descr>
      </element>
      <element name="HMODULE">
        <short>Special type for handling modules.</short>
        <descr>FPC doesn't support modules yet, so this is a dummy type.
</descr>
      </element>
      <element name="TPoint">
        <short>A record holding an X,Y coordinate pair</short>
        <descr>
          <p>This record typically describes a position in screen or client coordinates. The origin (0,0) typically is the upper left corner of the screen or of a control, the positive axes go to the bottom and right.
</p>
          <p>
            <var>X</var> represents the horizontal X-Coordinate of the point.

            <var>Y</var> represents the vertical Y-Coordinate of the point.
</p>
        </descr>
        <seealso>
          <link id="Point"/>
          <link id="TRect"/>
        </seealso>
      </element>
      <element name="TSmallPoint">
        <short>Type to describe point in a small plane.</short>
        <descr>Same as <link id="TPoint"/>, only the X and Y ranges are limited to 
2-byte integers instead of 4-byte integers.
</descr>
      </element>
      <element name="TRect">
        <short>Descibes a rectangle</short>
        <descr>
          <var>TRect</var> describes a rectangle in space with its upper-left (in
(
          <var>Top</var>,
          <var>Left&gt;</var>)) and lower-right (in (
          <var>Bottom</var>
,
          <var>Right</var>)) corners.
</descr>
      </element>
      <element name="MaxListSize">
        <short>Maximum number of elemens in list.
</short>
        <descr>This constant sets the maximum number of elements in a <link id="TList"/>.
</descr>
      </element>
      <element name="scShift">
        <short>Indicates Shift key in a keyboard shortcut.
</short>
      </element>
      <element name="scCtrl">
        <short>indicates CTRL key in a keyboard shortcut.
</short>
      </element>
      <element name="scAlt">
        <short>Indicates ALT key in a keyboard shortcut.
</short>
      </element>
      <element name="scNone">
        <short>Indicates no special key is presed in a keyboard shortcut.
</short>
      </element>
      <element name="soFromBeginning">
        <short>
          <link id="TStream.Seek">Seek</link> starts relative to the stream origin.
</short>
      </element>
      <element name="soFromCurrent">
        <short>
          <link id="TStream.Seek">Seek</link> starts relative to the current position in
the stream.
</short>
      </element>
      <element name="soFromEnd">
        <short>
          <link id="TStream.Seek">Seek</link> starts relative to the stream end.
</short>
      </element>
      <element name="fmCreate">
        <short>
          <link id="TFileStream.Create"/> creates a new file if needed.
</short>
      </element>
      <element name="fmOpenRead">
        <short>
          <link id="TFileStream.Create"/> opens a file with read-only access.
</short>
      </element>
      <element name="fmOpenWrite">
        <short>
          <link id="TFileStream.Create"/> opens a file with write-only access.
</short>
      </element>
      <element name="fmOpenReadWrite">
        <short>
          <link id="TFileStream.Create"/> opens a file with read-write access.
</short>
      </element>
      <element name="toEof">
        <short>Value returned by <link id="TParser.Token"/> when the end of the input stream was reached.
</short>
        <seealso>
          <link id="TParser.Token"/>
        </seealso>
      </element>
      <element name="toSymbol">
        <short>Value returned by <link id="TParser.Token"/> when a symbol was found in the input stream.
</short>
        <seealso>
          <link id="TParser.CheckTokenSymbol"/>
          <link id="TParser.Token"/>
          <link id="TParser.TokenComponentIdent"/>
          <link id="TParser.TokenSymbolIs"/>
        </seealso>
      </element>
      <element name="toString">
        <short>Value  returned by <link id="TParser.Token"/> when a string was found in the
input stream.
</short>
        <seealso>
          <link id="TParser.Token"/>
          <link id="TParser.TokenString"/>
        </seealso>
      </element>
      <element name="toInteger">
        <short>Value returned by <link id="TParser.Token"/> when an integer was found in the 
input stream.
</short>
        <seealso>
          <link id="TParser.Token"/>
          <link id="TParser.TokenInt"/>
        </seealso>
      </element>
      <element name="toFloat">
        <short>Value returned by <link id="TParser.Token"/> when a floating point value was found in the 
input stream.
</short>
        <seealso>
          <link id="TParser.FloatType"/>
          <link id="TParser.Token"/>
          <link id="TParser.TokenFloat"/>
        </seealso>
      </element>
      <element name="toWString">
        <short>Value  returned by <link id="TParser.Token"/> when a widestring was found in the
input stream.
</short>
        <seealso>
          <link id="TParser.Token"/>
          <link id="TParser.TokenWideString"/>
        </seealso>
      </element>
      <element name="FilerSignature">
        <short>Constant that is found at the start of a binary stream containing a 
streamed component.
</short>
      </element>
      <element name="TAlignment">
        <short>Type to specify text alignment in controls that display text.</short>
        <descr>
          <p>The <var>TAlignment</var> type is used to specify the alignment of
the text in controls that display a text. 
</p>
        </descr>
      </element>
      <element name="TAlignment.taLeftJustify">
        <short>Text is displayed aligned to the left
</short>
      </element>
      <element name="TAlignment.taCenter">
        <short>Text is displayed centered.
</short>
      </element>
      <element name="TAlignment.taRightJustify">
        <short>Text is displayed aligned to the right.
</short>
      </element>
      <element name="TShiftState">
        <short>Indicates what special keys were pressed in combination with a normal key
</short>
        <descr>
          <p>This type is used when describing a shortcut key or when describing what
special keys are pressed on a keyboard when a key event is generated.
</p>
          <p>The set contains the special keys that can be used in combination with a
'normal' key.
</p>
        </descr>
      </element>
      <element name="TShiftState.ssShift">
        <short>Either left or right shift key</short>
      </element>
      <element name="TShiftState.ssAlt">
        <short>Either left or right ALT key</short>
      </element>
      <element name="TShiftState.ssCTRL">
        <short>Either left or right CTRL key</short>
      </element>
      <element name="TShiftState.ssLeft">
        <short>Either left or right shift key</short>
      </element>
      <element name="TShiftState.ssRight">
        <short/>
      </element>
      <element name="TShiftState.ssMiddle">
        <short/>
      </element>
      <element name="TShiftState.ssDouble">
        <short/>
      </element>
      <element name="TShiftState.ssMeta">
        <short>The META key</short>
      </element>
      <element name="TShiftState.ssSuper">
        <short/>
      </element>
      <element name="TShiftState.ssHyper">
        <short/>
      </element>
      <element name="TShiftState.ssAltGr">
        <short>The AltGr (right Alt) key</short>
      </element>
      <element name="TShiftState.ssCaps">
        <short>The CapsLock key</short>
      </element>
      <element name="TShiftState.ssNum">
        <short>The NumLock key</short>
      </element>
      <element name="TShiftState.ssScroll">
        <short>The ScrollLock key</short>
      </element>
      <element name="TNotifyEvent">
        <short>Standard event handler type.
</short>
        <descr>Most event handlers are implemented as a property of type
<var>TNotifyEvent</var>. When this is set to a certain method of a class, 
when the event occurs, the method will be called, and the class that generated 
the event will pass itself along as the <var>Sender</var> argument.
</descr>
        <seealso>
          <link id="THelpEvent"/>
          <link id="TGetStrProc"/>
        </seealso>
      </element>
      <element name="THelpEvent">
        <short>Special event for display of online help.
</short>
        <descr>This event is used for display of online help. 
</descr>
        <seealso>
          <link id="TNotifyEvent"/>
          <link id="TGetStrProc"/>
        </seealso>
      </element>
      <element name="TGetStrProc">
        <short>Event for retrieving string values.
</short>
        <descr>This event is used as a callback to retrieve string values. It is used,
among other things, to pass along string properties in property editors.
</descr>
        <seealso>
          <link id="THelpEvent"/>
          <link id="TNotifyEvent"/>
        </seealso>
      </element>
      <element name="EStreamError">
        <short>Exception raised when an error occurs during read or write operations on a
stream.
</short>
        <descr>
          <p>An <var>EStreamError</var> is raised when an error occurs during reading
from or writng to a stream: Possible causes are 
</p>
          <ol>
            <li>Not enough data is available in the stream.</li>
            <li>Trying to seek beyond the beginning or end of the stream.</li>
            <li>Trying to set the capacity of a memory stream and no memory is
available.</li>
            <li>Trying to write to a read-only stream, such as a resource stream.</li>
            <li>Trying to read from a write-only stream.</li>
          </ol>
        </descr>
        <seealso>
          <link id="EFCreateError"/>
        </seealso>
      </element>
      <element name="EFCreateError">
        <short>Exception raised when an error occurred during creation of a <link id="TFileStream"/>
stream.
</short>
        <descr>When the operating system reports an error during creation of a new file in 
the <link id="TFileStream.Create">Filestream Constructor</link>, a
<var>EFCreateError</var> is raised.
</descr>
        <seealso>
          <link id="EStreamError"/>
          <link id="EFOpenError"/>
        </seealso>
      </element>
      <element name="EFOpenError">
        <short>Exception raised when an error occurred during creation of a <link id="TFileStream"/>
        </short>
        <descr>When the operating system reports an error during the opening of a file in 
the <link id="TFileStream.Create">Filestream Constructor</link>, a
<var>EFOpenError</var> is raised.
</descr>
        <seealso>
          <link id="EStreamError"/>
          <link id="EFCreateError"/>
        </seealso>
      </element>
      <element name="EFilerError">
        <short>Exception raised by the component streaming system if an error occurs.
</short>
        <descr>This class serves as an ancestor class for exceptions that are raised 
when an error occurs during component streaming.

A <var>EFilerError</var> exception is raised when a class is registered
twice.
</descr>
        <seealso>
          <link id="EStreamError"/>
          <link id="EReadError"/>
        </seealso>
      </element>
      <element name="EReadError">
        <short>Exception raised if an error occurs while reading from a stream.
</short>
        <descr>
          <p>If an error occurs when reading from a stream, a <var>EReadError</var>
exception is raised. Possible causes for this are:</p>
          <ol>
            <li>Not enough data is available when reading from a stream</li>
            <li>The stream containing a component's data contains invalid data.
this will occurr only when reading a component from a stream.</li>
          </ol>
        </descr>
        <seealso>
          <link id="EFilerError"/>
          <link id="EWriteError"/>
        </seealso>
      </element>
      <element name="EWriteError">
        <short>Exception raised when an error occurs during writing to a stream.
</short>
        <descr>
          <p>If an error occurs when writing to a stream, a <var>EWriteError</var>
exception is raised. Possible causes for this are:
</p>
          <ol>
            <li>The stream doesn't allow writing.</li>
            <li>An error occurred when writing a property to a stream.</li>
          </ol>
        </descr>
        <seealso>
          <link id="EFilerError"/>
          <link id="EReadError"/>
        </seealso>
      </element>
      <element name="EClassNotFound">
        <short>Exception raised when an unknown class is referenced in a streamed
component.
</short>
        <descr>When the streaming system needs to create a component, it looks for the
class pointer (VMT) in the list of registered classes by its name. If this
name is not found, then an <var>EClassNotFound</var> is raised.
</descr>
        <seealso>
          <link id="EFilerError"/>
        </seealso>
      </element>
      <element name="EMethodNotFound">
        <short>This exception is no longer used.
</short>
        <descr>This exception is no longer used in the streaming system. This error is
replaced by a <link id="EReadError"/>.
</descr>
        <seealso>
          <link id="EFilerError"/>
          <link id="EReadError"/>
        </seealso>
      </element>
      <element name="EInvalidImage">
        <short>Exception raised when the resource header needed for streaming of a
component is invalid.
</short>
        <descr>This exception is not used by Free Pascal but is provided for Delphi
compatibility.
</descr>
      </element>
      <element name="EResNotFound">
        <short>Exception raised when a resource, needed to initialize a component, is not found.
</short>
        <descr>This exception is not used by Free Pascal but is provided for Delphi
compatibility.
</descr>
      </element>
      <element name="EListError">
        <short>Exception raised when an error occurs in lists handling.
</short>
        <descr>
          <p>If an error occurs in one of the <link id="TList"/> or <link id="TStrings"/> 
methods, then a <var>EListError</var> exception is raised. This can occur in
one of the following cases:
</p>
          <ol>
            <li>There is not enough memory to expand the list.</li>
            <li>The list tried to grow beyond its maximal capacity.</li>
            <li>An attempt was made to reduce the capacity of the list below the
current element count.</li>
            <li>An attempt was made to set the list count to a negative value.</li>
            <li>A non-existent element of the list was referenced. (i.e. the list index
was out of bounds)</li>
            <li>An attempt was made to move an item to a position outside the list's
bounds.</li>
          </ol>
        </descr>
        <seealso>
          <link id="TList"/>,

          <link id="TStrings"/>
        </seealso>
      </element>
      <element name="EBitsError">
        <short>Exception raised when an error occurs in a method of <link id="TBits"/>.
</short>
        <descr>When an index of a bit in a <link id="TBits"/> is out of the valid range 
(<var>0</var> to <var>Count-1</var>) then a <var>EBitsError</var> exception 
is raised.
</descr>
      </element>
      <element name="EStringListError">
        <short>Exception raised when an error occurs in a method of <link id="TStrings"/>.
</short>
        <descr>
          <p>When an error occurs in one of the methods of <link id="TStrings"/> then
an <var>EStringListError</var> is raised. This can have one of the following
causes:
</p>
          <ol>
            <li>There is not enough memory to expand the list.</li>
            <li>The list tried to grow beyond its maximal capacity.</li>
            <li>A non-existent element of the list was referenced. (i.e. the list index
was out of bounds)</li>
            <li>An attempt was made to add a duplicate entry to a <link id="TStringList"/> when <link id="TStringList.AllowDuplicates"/> is
<var>False</var>.</li>
          </ol>
        </descr>
        <seealso>
          <link id="TStrings"/>
          <link id="TStringList"/>
        </seealso>
      </element>
      <element name="EComponentError">
        <short>Exception raised when an error occurs in the component registration
routines.
</short>
        <descr>
          <p>When an error occurs during the registration of a component, or when naming
a component, then a <var>EComponentError</var> is raised. Possible causes
are:
</p>
          <ol>
            <li>An name with an illegal character was assigned to a component.</li>
            <li>A component with the same name and owner already exists.</li>
            <li>The component registration system isn't set up properly.</li>
          </ol>
        </descr>
        <seealso>
          <link id="TComponent"/>
          <link id="TComponent.Name"/>
        </seealso>
      </element>
      <element name="EParserError">
        <short>Exception raised when an error occurs during the parsing of streams.
</short>
        <descr>When an error occurs during the parsing of a stream, an <var>EParserError</var>
is raised. Usually this indicates that an invalid token was found on the
input stream, or the token read from the stream wasn't the expected token.
</descr>
        <seealso>
          <link id="TParser"/>
        </seealso>
      </element>
      <element name="EOutOfResources">
        <short>Exception raised when the system is out of resources.
</short>
        <descr>This exception is not used in Free Pascal, it is defined for Delphi
compatibiliy purposes only.
</descr>
      </element>
      <element name="EInvalidOperation">
        <short>Exception raised when an invalid operation is performed. Obsolete.
</short>
        <descr>This exception is not used in Free Pascal, it is defined for Delphi
compatibiliy purposes only.
</descr>
      </element>
      <element name="TList">
        <short>Class to manage collections of pointers.</short>
        <descr>
          <p>
            <var>TList</var> is a class that can be used to manage collections of
pointers. It introduces methods and properties to store the pointers, search
in the list of pointers, sort them. It manages its memory by itself, no
intervention for that is needed. It has an event notification mechanism
which allows to notify of list changes. This slows down some of

            <var>TList</var> mechanisms, and if no notification is used,

            <link id="TFPList"/> may be used instead.
</p>
          <p>To manage collections of strings, it is better to use a <link id="TStrings"/> descendent such as <link id="TStringList"/>. To manage
general objects, a <link id="TCollection"/> class exists, from which a
descendent can be made to manage collections of various kinds.
</p>
        </descr>
        <seealso>
          <link id="TStrings"/>
          <link id="TCollection"/>
        </seealso>
      </element>
      <element name="TList.Create">
        <short>Class to manage collections of pointers.</short>
        <descr>
          <p>
            <var>TList.Create</var> creates a new instance of 
            <var>TList</var>. 
It clears the list and prepares it for use.
</p>
        </descr>
        <seealso>
          <link id="TList"/>
          <link id="TList.Destroy"/>
        </seealso>
      </element>
      <element name="TList.Destroy">
        <short>Destroys the list and releases the memory used to store the list elements.
</short>
        <descr>
          <var>Destroy</var> destroys the list and releases the memory used to store 
the list elements. The elements themselves are in no way touched, i.e. any
meomory they point to must be explicitly released before calling the
destructor.
</descr>
      </element>
      <element name="TList.Add">
        <short>Adds a new pointer to the list.
</short>
        <descr>
          <p>
            <var>Add</var> adds a new pointer to the list after the last pointer (i.e.
at position 
            <var>Count</var>, thus increasing the item count with 1. 
If the list is at full capacity, the capacity of the list is expanded, 
using the 
            <link id="TList.Grow">Grow</link> method.
</p>
          <p>To insert a pointer at a certain position in the list, use the <link id="TList.Insert">Insert</link> method instead.
</p>
        </descr>
        <seealso>
          <link id="TList.Delete">Delete</link>
          <link id="TList.Grow">Grow</link>
          <link id="TList.Insert">Insert</link>
        </seealso>
      </element>
      <element name="TList.Clear">
        <short>Clears the pointer list.
</short>
        <descr>
          <var>Clear</var> removes all pointers from the list, and sets the capacity to
0, thus freeing any memory allocated to maintain the list.
</descr>
        <seealso>
          <link id="TList.Destroy">Destroy</link>
        </seealso>
      </element>
      <element name="TList.Delete">
        <short>Removes a pointer from the list.
</short>
        <descr>
          <p>
            <var>Delete</var> removes the pointer at position 
            <var>Index</var> from the
list, shifting all following pointers one position up (or to the left).
</p>
          <p>The memory the pointer is pointing to is <i>not</i> deallocated. 
</p>
        </descr>
      </element>
      <element name="TList.Error">
        <short>Raises an <link id="EListError"/> exception.
</short>
        <descr>
          <var>Error</var> raises an 
          <link id="EListError"/> exception, with a message
formatted with 
          <var>Msg</var> and 
          <var>Data</var>.
</descr>
      </element>
      <element name="TList.Exchange">
        <short>Exchanges two pointers in the list.
</short>
        <descr>
          <var>Exchange</var> exchanges the pointers at positions 
          <var>Index1</var>
and 
          <var>Index2</var>. Both pointers must be withing the current range of
the list, or an 
          <link id="EListError"/> exception will be raised.
</descr>
      </element>
      <element name="TList.Expand">
        <short>Increases the capacity of the list if needed.
</short>
        <descr>
          <p>
            <var>Expand</var> increases the capacity of the list if the current element
count matches the current list capacity.
</p>
          <p>The capacity is increased according to the following algorithm:
</p>
          <ol>
            <li>If the capacity is less than 3, the capacity is increased with 4.</li>
            <li>If the capacity is larger than 3 and less than 8, the capacity is increased with 8.</li>
            <li>If the capacity is larger than 8, the capacity is increased with 16.</li>
          </ol>
          <p>The return value is <var>Self</var>.
</p>
        </descr>
        <seealso>
          <link id="TList.Capacity">Capacity</link>
          <!-- <link id="Tlist.SetCapacity"> -->
        </seealso>
      </element>
      <element name="TList.First">
        <short>Returns the first non-nil pointer in the list.
</short>
        <descr>
          <p>
            <var>First</var> returns the value of the first non-nil pointer in the
list.
</p>
          <p>If there are no pointers in the list or all pointers equal
<var>Nil</var>, then <var>Nil</var> is returned.
</p>
        </descr>
        <seealso>
          <link id="TList.Last">Last</link>
        </seealso>
      </element>
      <element name="TList.IndexOf">
        <short>Returns the index of a given pointer.
</short>
        <descr>
          <p>
            <var>IndexOf</var> searches for the pointer 
            <var>Item</var> in the list
of pointers, and returns the index of the pointer, if found. 
</p>
          <p>If no pointer with the value <var>Item</var> was found, -1 is returned.
</p>
        </descr>
      </element>
      <element name="TList.Insert">
        <short>Inserts a new pointer in the list at a given position.
</short>
        <descr>
          <p>
            <var>Insert</var> inserts pointer 
            <var>Item</var> at position

            <var>Index</var> in the list. All pointers starting from 
            <var>Index</var>
are shifted to the right.
</p>
          <p>If <var>Index</var> is not a valid position, then a <link id="EListError"/>
exception is raised.
</p>
        </descr>
        <seealso>
          <link id="TList.Add">Add</link>
          <link id="Tlist.Delete">Delete</link>
        </seealso>
      </element>
      <element name="TList.Insert.Item">
        <short>Pointer to be inserted.</short>
      </element>
      <element name="TList.Insert.Index">
        <short>Position where to insert</short>
      </element>
      <element name="TList.Last">
        <short>Returns the last non-nil pointer in the list.
</short>
        <descr>
          <p>
            <var>Last</var> returns the value of the last non-nil pointer in the
list.
</p>
          <p>If there are no pointers in the list or all pointers equal
<var>Nil</var>, then <var>Nil</var> is returned.
</p>
        </descr>
        <seealso>
          <link id="TList.First">First</link>
        </seealso>
      </element>
      <element name="TList.Move">
        <short>Moves a pointer from one position in the list to another.
</short>
        <descr>
          <p>
            <var>Move</var> moves the pointer at position 
            <var>CurIndex</var>
to position 
            <var>NewIndex</var>. This is done by storing the value 
at position 
            <var>CurIndex</var>, deleting the pointer at position

            <var>CurIndex</var>, and reinserting the value at position

            <var>NewIndex</var>
          </p>
          <p>If <var>CurIndex</var> or <var>Newindex</var> are not inside the valid
range of indices, an <link id="EListError"/> exception is raised.
</p>
        </descr>
        <seealso>
          <link id="TList.Exchange">Exchange</link>
        </seealso>
      </element>
      <element name="TList.Remove">
        <short>Removes a value from the list.
</short>
        <descr>
          <var>Remove</var> searches 
          <var>Item</var> in the list, and, if it finds it,
deletes the item from the list. Only the first occurrence of 
          <var>Item</var>
is removed.
</descr>
        <seealso>
          <link id="TList.Delete">Delete</link>
          <link id="TList.IndexOf">IndexOf</link>
          <link id="Tlist.Insert">Insert</link>
        </seealso>
      </element>
      <element name="TList.Pack">
        <short>Removes <var>Nil</var> pointers from the list and frees unused memory.
</short>
        <descr>
          <var>Pack</var> removes all 
          <var>nil</var> pointers from the list. 
The capacity of the list is then set to the number of pointers in the list.

This method can be used to free unused memory if the list has grown to
very large sizes and has a lot of unneeded nil pointers in it.
</descr>
        <seealso>
          <link id="TList.Clear"/>
        </seealso>
      </element>
      <element name="TList.Sort">
        <short>Sorts the pointers in the list.
</short>
        <descr>
          <p>
            <var>Sort&gt;</var> sorts the pointers in the list. Two pointers are compared
by passing them to the 
            <var>Compare</var> function. The result of this
function determines how the pointers will be sorted:
</p>
          <ul>
            <li>If the result of this function is negative, the first pointer is 
assumed to be 'less' than the second and will be moved before the second 
in the list.</li>
            <li>If the function result is positive, the first pointer is assumed to
be 'greater than' the second and will be moved after the second in the
list.</li>
            <li>if the function result is zero, the pointers are assumed to be 'equal'
and no moving will take place. </li>
          </ul>
          <p>The sort is done using a quicksort algorithm.
</p>
        </descr>
      </element>
      <element name="TList.Capacity">
        <short>Current capacity (i.e. number of pointers that can be stored) of the list.
</short>
        <descr>
          <p>
            <var>Capacity</var> contains the number of pointers the list can store
before it starts to grow. 
</p>
          <p>If a new pointer is added to the list using <link id="TList.Add">add</link>
or <link id="TList.Insert">insert</link>, and there is not enough memory to
store the new pointer, then the list will try to allocate more memory to
store the new pointer. Since this is a time consuming operation, it is
important that this operation be performed as little as possible. If
it is known how many pointers there will be before filling the list, it is
a good idea to set the capacity first before filling. This ensures that the
list doesn't need to grow, and will speed up filling the list.
</p>
        </descr>
        <seealso>
          <link id="TList.SetCapacity">SetCapacity</link>
          <link id="TList.Count">Count</link>
        </seealso>
      </element>
      <element name="Tlist.Count">
        <short>Current number of pointers in the list.
</short>
        <descr>
          <var>Count</var> is the current number of (possibly 
          <var>Nil</var>) pointers
in the list. Since the list is zero-based, the index of the largest pointer
is 
          <var>Count-1</var>.
</descr>
        <link id="TList.Capacity">Capacity</link>
      </element>
      <element name="TList.Items">
        <short>Provides access to the pointers in the list. 
</short>
        <descr>
          <p>
            <var>Items</var> is used to access the pointers in the list. It is the
default property of the 
            <var>TList</var> class, so it can be omitted. 
</p>
          <p>The list is zero-based, so Index must be in the range <var>0</var> to 
<var>Count-1</var>.
</p>
        </descr>
      </element>
      <element name="TList.List">
        <short>Memory array where pointers are stored.
</short>
        <descr>
          <var>List</var> points to the memory space where the pointers are stored.
This can be used to quickly copy the list of pinters to another location.
</descr>
      </element>
      <element name="TFPList">
        <short>Class to manage collections of pointers.</short>
        <descr>
          <p>
            <var>TFPList</var> is a class that can be used to manage collections of
pointers. It introduces methods and properties to store the pointers, search
in the list of pointers, sort them. It manages its memory by itself, no
intervention for that is needed. Contrary to 
            <link id="TList"/>,

            <var>TFPList</var> has no notification mechanism. If no notification
mechanism is used, it is better to use 
            <var>TFPList</var> instead of

            <var>TList</var>, as the performance of 
            <var>TFPList</var> is much higher.
</p>
          <p>To manage collections of strings, it is better to use a <link id="TStrings"/> descendent such as <link id="TStringList"/>. To manage
general objects, a <link id="TCollection"/> class exists, from which a
descendent can be made to manage collections of various kinds.
</p>
        </descr>
        <seealso>
          <link id="TStrings"/>
          <link id="TCollection"/>
        </seealso>
      </element>
      <element name="TFPList.Assign">
        <short>Assign performs the given operation on the list.</short>
        <descr>
          <var>Assign</var> can be used to merge or assign lists It is an extended
version of the usual 
          <var>TPersistent.Assign</var> mechanism. The arguments

          <var>ListA</var> and 
          <var>ListB</var> are used as sources of pointers to 
add or remove elements from the current list, depending on the operation 

          <var>AOperation</var>. The available operations are documented in the 

          <link id="TListAssignOp"/> type.
</descr>
        <seealso>
          <link id="TFPList.Add"/>
          <link id="TFPList.Clear"/>
        </seealso>
      </element>
      <element name="TFPList.Extract">
        <short>Remove the first occurrence of a pointer from the list.</short>
        <descr>
          <var>Extract</var> searches for the first occurrence of 
          <var>Item</var> in
the list and deletes it from the list. If 
          <var>Item</var> was found, it's 
value is returned. If 
          <var>Item</var> was not found, 
          <var>Nil</var> is returned.
</descr>
        <seealso>
          <link id="TFPList.Delete"/>
        </seealso>
      </element>
      <element name="TFPList.Destroy">
        <short>Destroys the list and releases the memory used to store the list elements.
</short>
        <descr>
          <var>Destroy</var> destroys the list and releases the memory used to store 
the list elements. The elements themselves are in no way touched, i.e. any
meomory they point to must be explicitly released before calling the
destructor.
</descr>
      </element>
      <element name="TFPList.Add">
        <short>Adds a new pointer to the list.
</short>
        <descr>
          <p>
            <var>Add</var> adds a new pointer to the list after the last pointer (i.e.
at position 
            <var>Count</var>, thus increasing the item count with 1. 
If the list is at full capacity, the capacity of the list is expanded, 
using the 
            <link id="TFPList.Grow">Grow</link> method.
</p>
          <p>To insert a pointer at a certain position in the list, use the <link id="TFPList.Insert">Insert</link> method instead.
</p>
        </descr>
        <seealso>
          <link id="TFPList.Delete">Delete</link>
          <link id="TFPList.Grow">Grow</link>
          <link id="TFPList.Insert">Insert</link>
        </seealso>
      </element>
      <element name="TFPList.Clear">
        <short>Clears the pointer list.
</short>
        <descr>
          <var>Clear</var> removes all pointers from the list, and sets the capacity to
0, thus freeing any memory allocated to maintain the list.
</descr>
        <seealso>
          <link id="TFPList.Destroy">Destroy</link>
        </seealso>
      </element>
      <element name="TFPList.Delete">
        <short>Removes a pointer from the list.
</short>
        <descr>
          <p>
            <var>Delete</var> removes the pointer at position 
            <var>Index</var> from the
list, shifting all following pointers one position up (or to the left).
</p>
          <p>The memory the pointer is pointing to is <i>not</i> deallocated. 
</p>
        </descr>
      </element>
      <element name="TFPList.Error">
        <short>Raises an <link id="EListError"/> exception.
</short>
        <descr>
          <var>Error</var> raises an 
          <link id="EListError"/> exception, with a message
formatted with 
          <var>Msg</var> and 
          <var>Data</var>.
</descr>
      </element>
      <element name="TFPList.Exchange">
        <short>Exchanges two pointers in the list.
</short>
        <descr>
          <var>Exchange</var> exchanges the pointers at positions 
          <var>Index1</var>
and 
          <var>Index2</var>. Both pointers must be withing the current range of
the list, or an 
          <link id="EListError"/> exception will be raised.
</descr>
      </element>
      <element name="TFPList.Expand">
        <short>Increases the capacity of the list if needed.
</short>
        <descr>
          <p>
            <var>Expand</var> increases the capacity of the list if the current element
count matches the current list capacity.
</p>
          <p>The capacity is increased according to the following algorithm:
</p>
          <ol>
            <li>If the capacity is less than 3, the capacity is increased with 4.</li>
            <li>If the capacity is larger than 3 and less than 8, the capacity is increased with 8.</li>
            <li>If the capacity is larger than 8, the capacity is increased with 16.</li>
          </ol>
          <p>The return value is <var>Self</var>.
</p>
        </descr>
        <seealso>
          <link id="TFPList.Capacity">Capacity</link>
          <!-- <link id="TFPList.SetCapacity"> -->
        </seealso>
      </element>
      <element name="TFPList.First">
        <short>Returns the first non-nil pointer in the list.
</short>
        <descr>
          <p>
            <var>First</var> returns the value of the first non-nil pointer in the
list.
</p>
          <p>If there are no pointers in the list or all pointers equal
<var>Nil</var>, then <var>Nil</var> is returned.
</p>
        </descr>
        <seealso>
          <link id="TFPList.Last">Last</link>
        </seealso>
      </element>
      <element name="TFPList.IndexOf">
        <short>Returns the index of a given pointer.
</short>
        <descr>
          <p>
            <var>IndexOf</var> searches for the pointer 
            <var>Item</var> in the list
of pointers, and returns the index of the pointer, if found. 
</p>
          <p>If no pointer with the value <var>Item</var> was found, -1 is returned.
</p>
        </descr>
      </element>
      <element name="TFPList.Insert">
        <short>Inserts a new pointer in the list at a given position.
</short>
        <descr>
          <p>
            <var>Insert</var> inserts pointer 
            <var>Item</var> at position

            <var>Index</var> in the list. All pointers starting from 
            <var>Index</var>
are shifted to the right.
</p>
          <p>If <var>Index</var> is not a valid position, then a <link id="EListError"/>
exception is raised.
</p>
        </descr>
        <seealso>
          <link id="TFPList.Add">Add</link>
          <link id="TFPList.Delete">Delete</link>
        </seealso>
      </element>
      <element name="TFPList.Insert.Item">
        <short>Pointer to be inserted.</short>
      </element>
      <element name="TFPList.Insert.Index">
        <short>Position where to insert</short>
      </element>
      <element name="TFPList.Last">
        <short>Returns the last non-nil pointer in the list.
</short>
        <descr>
          <p>
            <var>Last</var> returns the value of the last non-nil pointer in the
list.
</p>
          <p>If there are no pointers in the list or all pointers equal
<var>Nil</var>, then <var>Nil</var> is returned.
</p>
        </descr>
        <seealso>
          <link id="TFPList.First">First</link>
        </seealso>
      </element>
      <element name="TFPList.Move">
        <short>Moves a pointer from one position in the list to another.
</short>
        <descr>
          <p>
            <var>Move</var> moves the pointer at position 
            <var>CurIndex</var>
to position 
            <var>NewIndex</var>. This is done by storing the value 
at position 
            <var>CurIndex</var>, deleting the pointer at position

            <var>CurIndex</var>, and reinserting the value at position

            <var>NewIndex</var>
          </p>
          <p>If <var>CurIndex</var> or <var>Newindex</var> are not inside the valid
range of indices, an <link id="EListError"/> exception is raised.
</p>
        </descr>
        <seealso>
          <link id="TFPList.Exchange">Exchange</link>
        </seealso>
      </element>
      <element name="TFPList.Remove">
        <short>Removes a value from the list.
</short>
        <descr>
          <var>Remove</var> searches 
          <var>Item</var> in the list, and, if it finds it,
deletes the item from the list. Only the first occurrence of 
          <var>Item</var>
is removed.
</descr>
        <seealso>
          <link id="TFPList.Delete">Delete</link>
          <link id="TFPList.IndexOf">IndexOf</link>
          <link id="TFPList.Insert">Insert</link>
        </seealso>
      </element>
      <element name="TFPList.Pack">
        <short>Removes <var>Nil</var> pointers from the list and frees unused memory.
</short>
        <descr>
          <var>Pack</var> removes all 
          <var>nil</var> pointers from the list. 
The capacity of the list is then set to the number of pointers in the list.

This method can be used to free unused memory if the list has grown to
very large sizes and has a lot of unneeded nil pointers in it.
</descr>
        <seealso>
          <link id="TFPList.Clear"/>
        </seealso>
      </element>
      <element name="TFPList.Sort">
        <short>Sorts the pointers in the list.
</short>
        <descr>
          <p>
            <var>Sort&gt;</var> sorts the pointers in the list. Two pointers are compared
by passing them to the 
            <var>Compare</var> function. The result of this
function determines how the pointers will be sorted:
</p>
          <ul>
            <li>If the result of this function is negative, the first pointer is 
assumed to be 'less' than the second and will be moved before the second 
in the list.</li>
            <li>If the function result is positive, the first pointer is assumed to
be 'greater than' the second and will be moved after the second in the
list.</li>
            <li>if the function result is zero, the pointers are assumed to be 'equal'
and no moving will take place. </li>
          </ul>
          <p>The sort is done using a quicksort algorithm.
</p>
        </descr>
      </element>
      <element name="TFPList.Capacity">
        <short>Current capacity (i.e. number of pointers that can be stored) of the list.
</short>
        <descr>
          <p>
            <var>Capacity</var> contains the number of pointers the list can store
before it starts to grow. 
</p>
          <p>If a new pointer is added to the list using <link id="TFPList.Add">add</link>
or <link id="TFPList.Insert">insert</link>, and there is not enough memory to
store the new pointer, then the list will try to allocate more memory to
store the new pointer. Since this is a time consuming operation, it is
important that this operation be performed as little as possible. If
it is known how many pointers there will be before filling the list, it is
a good idea to set the capacity first before filling. This ensures that the
list doesn't need to grow, and will speed up filling the list.
</p>
        </descr>
        <seealso>
          <link id="TFPList.SetCapacity">SetCapacity</link>
          <link id="TFPList.Count">Count</link>
        </seealso>
      </element>
      <element name="TFPList.Count">
        <short>Current number of pointers in the list.
</short>
        <descr>
          <var>Count</var> is the current number of (possibly 
          <var>Nil</var>) pointers
in the list. Since the list is zero-based, the index of the largest pointer
is 
          <var>Count-1</var>.
</descr>
        <link id="TFPList.Capacity">Capacity</link>
      </element>
      <element name="TFPList.Items">
        <short>Provides access to the pointers in the list. 
</short>
        <descr>
          <p>
            <var>Items</var> is used to access the pointers in the list. It is the
default property of the 
            <var>TFPList</var> class, so it can be omitted. 
</p>
          <p>The list is zero-based, so Index must be in the range <var>0</var> to 
<var>Count-1</var>.
</p>
        </descr>
      </element>
      <element name="TFPList.List">
        <short>Memory array where pointers are stored.
</short>
        <descr>
          <var>List</var> points to the memory space where the pointers are stored.
This can be used to quickly copy the list of pinters to another location.
</descr>
      </element>
      <element name="TThreadList">
        <!-- Class -->
        <short>Thread-safe list object</short>
        <descr>TThreadList is a thread-safe <link id="Tlist"/> implementation. 
Unlike <var>TList</var>, it can be accessed read-write by multiple threads:
the list implementation will take care of locking the list when adding or
removing items from the list.
</descr>
        <seealso>
          <link id="TList"/>
        </seealso>
      </element>
      <element name="TThreadList.Create">
        <!-- Constructor -->
        <short>Creates a new thread-safe list.</short>
        <descr>
          <var>Create</var> instantiates a new 
          <var>TThreadList</var> instance. 
It initializes a critical section and an internal list object.
</descr>
        <seealso>
          <link id="TThreadList.Destroy"/>
        </seealso>
      </element>
      <element name="TThreadList.Destroy">
        <!-- Destructor -->
        <short>Destroys the list instance.</short>
        <descr>
          <var>Destroy</var> finalizes the critical section, clears the internal list object and calls
the inherited destructor.
</descr>
        <seealso>
          <link id="TThreadList.Create"/>
        </seealso>
      </element>
      <element name="TThreadList.Add">
        <!-- Procedure -->
        <short>Adds an element to the list.</short>
        <descr>
          <var>Add</var> attempts to lock the list and adds the pointer 
          <var>Item</var>
to the list. After the pointer was added, the list is unlocked again.
</descr>
        <seealso>
          <link id="TThreadList.LockList">LockList</link>
          <link id="TThreadList.Clear">Clear</link>
          <link id="TThreadList.Remove">Remove</link>
          <link id="TThreadList.UnLockList">UnlockList</link>
        </seealso>
      </element>
      <element name="TThreadList.Clear">
        <!-- Procedure -->
        <short>Removes all emements from the list.</short>
        <descr>
          <var>Clear</var> attempts to lock the list and then clears the list; all
items are removed from the list. After the list is cleared, it is again 
unlocked.
</descr>
        <seealso>
          <link id="TThreadList.LockList">LockList</link>
          <link id="TThreadList.Add">Add</link>
          <link id="TThreadList.Remove">Remove</link>
          <link id="TThreadList.UnLockList">UnlockList</link>
        </seealso>
      </element>
      <element name="TThreadList.LockList">
        <!-- Function -->
        <short>Locks the list for exclusive access.</short>
        <descr>
          <var>LockList</var> locks the list for exclusive access. Locklist uses an
internal critical section, so all rules for multiple locking of critical
sections apply to locklist/unlocklist as well.
</descr>
        <seealso>
          <link id="TThreadList.Clear">Clear</link>
          <link id="TThreadList.Add">Add</link>
          <link id="TThreadList.Remove">Remove</link>
          <link id="TThreadList.UnLockList">UnlockList</link>
        </seealso>
      </element>
      <element name="TThreadList.Remove">
        <!-- Procedure -->
        <short>Removes an item from the list.</short>
        <descr>
          <var>Remove</var> attempts to lock the list and then removes

          <var>Item</var> from the list. After the item is removed, the
list is again unlocked.
</descr>
        <seealso>
          <link id="TThreadList.LockList">LockList</link>
          <link id="TThreadList.Add">Add</link>
          <link id="TThreadList.Clear">Clear</link>
          <link id="TThreadList.UnLockList">UnlockList</link>
        </seealso>
      </element>
      <element name="TThreadList.UnlockList">
        <!-- Procedure -->
        <short>Unlocks the list after it was locked.</short>
        <descr>
          <var>UnLockList</var> unlocks the list when it was locked for exclusive access. 
UnLocklist and LockList use an internal critical section, so all rules for multiple 
locking/unlocking of critical sections apply.
</descr>
        <seealso>
          <link id="TThreadList.Clear">Clear</link>
          <link id="TThreadList.Add">Add</link>
          <link id="TThreadList.Remove">Remove</link>
          <link id="TThreadList.LockList">lockList</link>
        </seealso>
      </element>
      <element name="BITSHIFT">
        <!-- Constant -->
        <short>Used to calculate the size of a bits array</short>
        <seealso>
          <link id="TBits"/>
          <link id="TBits.Size"/>
        </seealso>
      </element>
      <element name="MASK">
        <!-- Constant -->
        <short>Bitmask with all bits on.</short>
        <seealso>
          <link id="TBits"/>
        </seealso>
      </element>
      <element name="MaxBitRec">
        <!-- Constant -->
        <short>Maximum number of bit records in TBits.</short>
        <seealso>
          <link id="TBits"/>
        </seealso>
      </element>
      <element name="MaxBitFlags">
        <!-- Constant -->
        <short>Maximum number of bits in TBits collection.</short>
        <seealso>
          <link id="TBits"/>
        </seealso>
      </element>
      <element name="TBitArray">
        <!-- Array type -->
        <short>Array to store bits.</short>
        <seealso>
          <link id="TBits"/>
        </seealso>
      </element>
      <element name="TBits">
        <!-- Class -->
        <short>Class to store collections of bits (binary values that can be 0 or 1)</short>
        <descr>
          <p>
            <var>TBits</var> can be used to store collections of bits in an indexed
array. This is especially useful for storing collections of booleans:
Normally the size of a boolean is the size of the smallest enumerated type,
i.e. 1 byte. Since a bit can take 2 values it can be used to store a boolean
as well. Since TBits can store 8 bits in a byte, it takes 8 times less space
to store an array of booleans in a TBits class then it would take to stoe
them in a conventional array.
</p>
          <p>
            <var>TBits</var> introduces methods to store and retrieve bit values,
apply masks, and search for bits. 
</p>
        </descr>
      </element>
      <element name="TBits.Create">
        <!-- Constructor -->
        <short>Creates a new bits collection.</short>
        <descr>
          <p>
            <var>Create</var> creates a new bit collection with initial size 
            <var>TheSize</var>.
The size of the collection can be changed later on. 
</p>
          <p>All bits are initially set to zero.</p>
        </descr>
        <seealso>
          <link id="TBits.Destroy">Destroy</link>
        </seealso>
      </element>
      <element name="TBits.Destroy">
        <!-- Destructor -->
        <short>Destroys a bit collection</short>
        <descr>
          <p>
            <var>Destroy</var> destroys a previously created bit collection and 
releases all memory used to store the bit collection.
</p>
          <p>
            <var>Destroy</var> should never be called directly, 
            <var>Free</var>
should be used instead.
</p>
        </descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TBits.Create">Create</link>
        </seealso>
      </element>
      <element name="TBits.getFSize">
        <!-- Function -->
        <short>Returns the number of records used to store the bits.</short>
        <descr>
          <var>GetFSize</var> returns the number of records used to store the current
number of bits.
</descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TBits.Size">Size</link>
        </seealso>
      </element>
      <element name="TBits.seton">
        <!-- Procedure -->
        <short>Turn a  particular bit on.</short>
        <descr>
          <var>SetOn</var> turns on the bit at position 
          <var>bit</var>, i.e. sets it
to 1. 
If 
          <var>bit</var> is at a position bigger than the current size, the collection
is expanded to the required size using 
          <link id="TBits.grow">Grow</link>.
</descr>
        <errors>If <var>bit</var> is larger than the maximum allowed bits array size or
is negative, an <link id="EBitsError"/> exception is raised.
</errors>
        <seealso>
          <link id="TBits.Bits">Bits</link>
          <link id="TBits.clear">Clear</link>
        </seealso>
      </element>
      <element name="TBits.clear">
        <!-- Procedure -->
        <short>Clears a particular bit.</short>
        <descr>
          <var>Clear</var> clears the bit at position 
          <var>bit</var>. If the array
If 
          <var>bit</var> is at a position bigger than the current size, the collection
is expanded to the required size using 
          <link id="TBits.grow">Grow</link>.
</descr>
        <errors>If <var>bit</var> is larger than the maximum allowed bits array size or
is negative, an <link id="EBitsError"/> exception is raised.
</errors>
        <seealso>
          <link id="TBits.Bits">Bits</link>
          <link id="TBits.clear">seton</link>
        </seealso>
      </element>
      <element name="TBits.clearall">
        <!-- Procedure -->
        <short>Clears all bits in the array.</short>
        <descr>
          <var>ClearAll</var> clears all bits in the array, i.e. sets them to zero. 
          <var>ClearAll</var> works faster than clearing all individual bits, since it 
uses the packed nature of the bits.
</descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TBits.Bits">Bits</link>
          <link id="TBits.clear">clear</link>
        </seealso>
      </element>
      <element name="TBits.andbits">
        <!-- Procedure -->
        <short>Performs an <var>and</var> operation on the bits.</short>
        <descr>
          <var>andbits</var> performs an 
          <var>and</var> operation on the bits in 
the array with the bits of array 
          <var>BitSet</var>. If 
          <var>BitSet</var>
contains less bits than the current array, then all bits which have no
counterpart in 
          <var>BitSet</var> are cleared.
</descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TBits.clearall">ClearAll</link>
          <link id="TBits.orbits">OrBits</link>
          <link id="TBits.xorbits">XOrBits</link>
          <link id="TBits.notbits">NotBits</link>
        </seealso>
      </element>
      <element name="TBits.orbits">
        <!-- Procedure -->
        <short>Performs an <var>or</var> operation on the bits.</short>
        <descr>
          <p>
            <var>andbits</var> performs an 
            <var>or</var> operation on the bits in 
the array with the bits of array 
            <var>BitSet</var>. 
</p>
          <p>If <var>BitSet</var>
contains less bits than the current array, then all bits which have no
counterpart in <var>BitSet</var> are left untouched.
</p>
          <p>If the current array contains less bits than <var>BitSet</var> then it is
grown to the size of <var>BitSet</var> before the <var>or</var> operation is
performed.
</p>
        </descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TBits.clearall">ClearAll</link>
          <link id="TBits.andbits">andBits</link>
          <link id="TBits.xorbits">XOrBits</link>
          <link id="TBits.notbits">NotBits</link>
        </seealso>
      </element>
      <element name="TBits.xorbits">
        <!-- Procedure -->
        <short>Performs a <var>xor</var> operation on the bits.</short>
        <descr>
          <p>
            <var>XorBits</var> performs a 
            <var>xor</var> operation on the bits in 
the array with the bits of array 
            <var>BitSet</var>. 
</p>
          <p>If <var>BitSet</var>
contains less bits than the current array, then all bits which have no
counterpart in <var>BitSet</var> are left untouched.
</p>
          <p>If the current array contains less bits than <var>BitSet</var> then it is
grown to the size of <var>BitSet</var> before the <var>xor</var> operation is
performed.
</p>
        </descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TBits.clearall">ClearAll</link>
          <link id="TBits.andbits">andBits</link>
          <link id="TBits.orbits">OrBits</link>
          <link id="TBits.notbits">NotBits</link>
        </seealso>
      </element>
      <element name="TBits.notbits">
        <!-- Procedure -->
        <short>Performs a <var>not</var> operation on the bits.</short>
        <descr>
          <p>
            <var>NotBits</var> performs a 
            <var>not</var> operation on the bits in 
the array with the bits of array 
            <var>Bitset</var>. 
</p>
          <p>If <var>BitSet</var>
contains less bits than the current array, then all bits which have no
counterpart in <var>BitSet</var> are left untouched.
</p>
        </descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TBits.clearall">ClearAll</link>
          <link id="TBits.andbits">andBits</link>
          <link id="TBits.orbits">OrBits</link>
          <link id="TBits.xorbits">XOrBits</link>
        </seealso>
      </element>
      <element name="TBits.get">
        <!-- Function -->
        <short>Retrieve the value of a particular bit</short>
        <descr>
          <var>Get</var> returns 
          <var>True</var> if the bit at position 
          <var>bit</var>
is set, or 
          <var>False</var> if it is not set.
</descr>
        <errors>If <var>bit</var> is not a valid bit index then an <link id="EBitsError"/>
exception is raised.
</errors>
        <seealso>
          <link id="TBits.Bits">Bits</link>
          <link id="TBits.FindFirstBit">FindFirstBit</link>
          <link id="TBits.seton">seton</link>
        </seealso>
      </element>
      <element name="TBits.grow">
        <!-- Procedure -->
        <short>Expands the bits array to the requested size.</short>
        <descr>
          <var>Grow</var> expands the bit array so it can at least contain

          <var>nbit</var> bits. If 
          <var>nbit</var> is less than the current size,
nothing happens.
</descr>
        <errors>If there is not enough memory to complete the operation, then an
<link id="EBitsError"/>is raised.
</errors>
        <seealso>
          <link id="TBits.Size">Size</link>
        </seealso>
      </element>
      <element name="TBits.equals">
        <!-- Function -->
        <short>Determines whether the bits of 2 arrays are equal.</short>
        <descr>
          <p>
            <var>equals</var> returns 
            <var>True</var> if all the bits in 
            <var>BitSet</var>
are the same as the ones in the current BitSet; if not, 
            <var>False</var> is
returned.
</p>
          <p>If the sizes of the two BitSets are different, the arrays are still reported
equal when all the bits in the larger set, which are not present in the smaller 
set, are zero. 
</p>
        </descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TBits.clearall">ClearAll</link>
          <link id="TBits.andbits">andBits</link>
          <link id="TBits.orbits">OrBits</link>
          <link id="TBits.xorbits">XOrBits</link>
        </seealso>
      </element>
      <element name="TBits.SetIndex">
        <!-- Procedure -->
        <short>Sets the start position for <link id="TBits.FindNextBit">FindNextBit</link> and <link id="TBits.FindPrevBit">FindPrevBit</link>
        </short>
        <descr>
          <p>
            <var>SetIndex</var> sets the search start position for
            <link id="TBits.FindNextBit">FindNextBit</link> and 

            <link id="TBits.FindPrevBit">FindPrevBit</link> to 
            <var>Index</var>.
This means that these calls will start searching from position

            <var>Index</var>.
</p>
          <p>This mechanism provides an alternative to <link id="TBits.FindFirstBit">FindFirstBit</link> which can also be used to
position for the <var>FindNextBit</var> and <var>FindPrevBit</var> calls.
</p>
        </descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TBits.FindNextBit">FindNextBit</link>
          <link id="TBits.FindPrevBit">FindPrevBit</link>
          <link id="TBits.FindFirstBit">FindFirstBit</link>
          <link id="TBits.OpenBit">OpenBit</link>
        </seealso>
      </element>
      <element name="TBits.FindFirstBit">
        <!-- Function -->
        <short>Find first bit with a particular value</short>
        <descr>
          <p>
            <var>FindFirstBit</var> searches for the first bit with value

            <var>State</var>. It returns the position of this bit, or 
            <var>-1</var> if
no such bit was found.
</p>
          <p>The search starts at position 0 in the array. If the first search
returned a positive result, the found position is saved, and the
<link id="TBits.FindNextBit">FindNextBit</link> and <link id="TBits.FindPrevBit">FindPrevBit</link> will use this position to resume the
search. To start a search from a certain position, the start position can be
set with the <link id="TBits.SetIndex">SetIndex</link> instead.
</p>
        </descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TBits.FindNextBit">FindNextBit</link>
          <link id="TBits.FindPrevBit">FindPrevBit</link>
          <link id="TBits.OpenBit">OpenBit</link>
          <link id="TBits.SetIndex">SetIndex</link>
        </seealso>
      </element>
      <element name="TBits.FindNextBit">
        <!-- Function -->
        <short>Searches the next bit with a particular value.</short>
        <descr>
          <p>
            <var>FindNextBit</var> resumes a previously started search. It searches for
the next bit with the value specified in the 
            <link id="TBits.FindFirstBit">FindFirstBit</link>. The search is done towards the
end of the array and starts at the position last reported by one of the 

            <var>Find</var> calls or at the position set with 
            <link id="TBits.SetIndex">SetIndex</link>.
</p>
          <p>If another bit with the same value is found, its position
is returned. If no more bits with the same value are present in the array,
<var>-1</var> is returned.
</p>
        </descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TBits.FindFirstBit">FindFirstBit</link>
          <link id="TBits.FindPrevBit">FindPrevBit</link>
          <link id="TBits.OpenBit">OpenBit</link>
          <link id="TBits.SetIndex">SetIndex</link>
        </seealso>
      </element>
      <element name="TBits.FindPrevBit">
        <!-- Function -->
        <short>Searches the previous bit with a particular value.</short>
        <descr>
          <p>
            <var>FindPrevBit</var> resumes a previously started search. It searches for
the previous bit with the value specified in the 
            <link id="TBits.FindFirstBit">FindFirstBit</link>. The search is done towards the
beginning of the array and starts at the position last reported by one of the 

            <var>Find</var> calls or at the position set with 
            <link id="TBits.SetIndex">SetIndex</link>.
</p>
          <p>If another bit with the same value is found, its position
is returned. If no more bits with the same value are present in the array,
<var>-1</var> is returned.
</p>
        </descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TBits.FindFirstBit">FindFirstBit</link>
          <link id="TBits.FindNextBit">FindNextBit</link>
          <link id="TBits.OpenBit">OpenBit</link>
          <link id="TBits.SetIndex">SetIndex</link>
        </seealso>
      </element>
      <element name="TBits.OpenBit">
        <!-- Function -->
        <short>Returns the position of the first bit that is set to <var>False</var>.</short>
        <descr>
          <var>OpenBit</var> returns the position of the first bit whose value is

          <var>0</var> (
          <var>False</var>), or 
          <var>-1</var> if no open bit was found. 
This call is equivalent to

          <var>FindFirstBit(False)</var>, except that it doesn't set the position for
the next searches.
</descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TBits.FindFirstBit">FindNextBit</link>
          <link id="TBits.FindPrevBit">FindPrevBit</link>
          <link id="TBits.FindFirstBit">FindFirstBit</link>
          <link id="TBits.SetIndex">SetIndex</link>
        </seealso>
      </element>
      <element name="TBits.Bits">
        <!-- Property -->
        <short>Access to all bits in the array.</short>
        <descr>
          <var>Bits</var> allows indexed access to all of the bits in the array. It
gives 
          <var>True</var> if the bit is 
          <var>1</var>, 
          <var>False</var>
otherwise; Assigning to this property will set, respectively clear the bit.
</descr>
        <errors>If an index is specified which is out of the allowed range then an <link id="EBitsError"/> exception is raised.
</errors>
        <seealso>
          <link id="TBits.Size">Size</link>
        </seealso>
      </element>
      <element name="TBits.Size">
        <!-- Property -->
        <short>Current size of the array of bits.</short>
        <descr>
          <var>Size</var> is the current size of the bit array. Setting this property
will adjust the size; this is equivalent to calling 
          <var>Grow(Value-1)</var>
        </descr>
        <errors>If an invalid size (negative or too large) is specified, a <link id="EBitsError"/> exception is raised.
</errors>
        <seealso>
          <link id="TBits.Bits">Bits</link>
        </seealso>
      </element>
      <element name="TPersistent">
        <!-- Class -->
        <short>Base class for streaming system and persistent properties.</short>
        <descr>
          <p>
            <var>TPersistent</var> is the basic class for the streaming system. Since it
is compiled in the 
            <var>{$M+}</var> state, the compiler generates  RTTI
(Run-Time Type Information) for it and all classes that descend from it.
This information can be used to stream all properties of classes.
</p>
          <p>It also introduces functionality to assign the contents of 2 classes to 
each other.
</p>
        </descr>
        <seealso>
          <link id="TComponent"/>
        </seealso>
      </element>
      <element name="TPersistent.AssignError">
        <!-- Procedure -->
        <short>Raises an <var>EConvertError</var> when an error occurs during
assignment.</short>
        <descr>
          <var>AssignError</var> raises an 
          <var>EConvertError</var> exception with
the classnames of the 
          <var>Source</var> and destination classes. It is used
when two incompatible classes are assigned to each other.
</descr>
        <seealso>
          <link id="TPersistent.Assign">Assign</link>
          <link id="TPersistent.AssignTo">AssignTo</link>
        </seealso>
      </element>
      <element name="TPersistent.AssignTo">
        <!-- Procedure -->
        <short>Generic assignment function.</short>
        <descr>
          <p>
            <var>AssignTo</var> is the generic function to assign the class' contents to 
another class. This method must be overridden by descendent classes to
actually assign the content of the source instance to the destination
instance. 
</p>
          <p>The <link id="TPersistent"/> implementation of <var>Assignto</var> raises 
an <var>EConvertError</var> exception. This is done for the following
reason: If the source class doesn't know how to assign itself to the
destination class (using <var>AssignTo</var>), the destination class may 
know how get the data from the source class (using <link id="TPersistent.Assign">Assign</link>). If all descendent methods are
implemented correctly, then if neither of the two classes knows how to
assign their contents to each other, execution will end up at <link id="TPersistent.Assign"/>, which will simply execute 
</p>
          <code>Dest.AssignTo(Self);
</code>
          <p>If neither of the classes knows how to assign to/from each other, then
execution will end up at the <var>TPersistent</var> implementation of
<var>AssignTo</var>, and an exception will be raised.
</p>
        </descr>
        <seealso>
          <link id="TPersistent.Assign">Assign</link>
        </seealso>
      </element>
      <element name="TPersistent.DefineProperties">
        <!-- Procedure -->
        <short>Declare non-published properties that need to be streamed.</short>
        <descr>
          <p>
            <var>DefineProperties</var> must be overridden by descendent classes to 
indicate to the streaming system which non-published properties must 
also be streamed.
</p>
          <p>The streaming systems stores only published properties in the stream.
Sometimes it is necessary to store additional data in the stream, data
which is not published. This can be done by overriding the
<var>DefineProperties</var> method. The <var>Filer</var> object is the
class that is responsible for writing all properties to the stream. 
</p>
          <p>To define new properties, two methods of the <link id="TFiler"/> class
should be used:
</p>
          <ol>
            <li>
              <link id="TFiler.DefineProperty">DefineProperty</link>, to define a
property which can be represented as text.</li>
            <li>
              <link id="TFiler.DefineBinaryProperty">DefineProperty</link>, to define a
property which contains binary data.</li>
          </ol>
          <p>On order for the streaming to work correctly, a call to the inherited 
<var>DefineProperties</var> is also needed, so ancestor objects also
get the possibility to read or write their private data to the stream.
Failure to call the inherited method will result in component properties not
being streamed correctly.
</p>
        </descr>
        <seealso>
          <link id="TFiler.DefineProperties"/>
          <link id="TFiler"/>
        </seealso>
      </element>
      <element name="TPersistent.GetOwner">
        <!-- Function -->
        <short>Returns the owner of the component.</short>
        <descr>
          <var>GetOwner</var> returns the owning component of the classes instane. 
The 
          <var>TPersistent</var> implementation of 
          <var>GetOwner</var> returns

          <var>Nil</var>. 
          <link id="TComponent"/> overrides this method.
</descr>
        <seealso>
          <link id="TComponent"/>
        </seealso>
      </element>
      <element name="TPersistent.Destroy">
        <!-- Destructor -->
        <short>Destroys the <var>TPersistent</var> instance. </short>
        <descr>
          <var>Destroy</var> disposes of the persistent object. This method should
never be called directly. Instead the 
          <var>Free</var> method should be used.
</descr>
      </element>
      <element name="TPersistent.Assign">
        <!-- Procedure -->
        <short>Assign the contents of one class to another.</short>
        <descr>
          <p>
            <var>Assign</var> copies the contents of 
            <var>Source</var> to

            <var>Self</var>, if the classes of the destination and source classes are
compatible.
</p>
          <p>The <var>TPersistent</var> implementation of <var>Assign</var> does nothing
but calling the <link id="TPersistent.AssignTo">AssignTo</link> method of
source. This means that if the destination class does not know how to assign
the contents of the source class, the source class instance is asked to assign
itself to the destination class. This means that it is necessary to
implement only one of the two methods so that two classes can be assiged to
one another.
</p>
          <remark>
            <p>In general, a statement of the form
</p>
            <code>Destination:=Source;
</code>
            <p>(where <var>Destination</var> and <var>Source</var> are classes) does not 
achieve the same as a statement of the form
</p>
            <code>Destination.Assign(Source);
</code>
            <p>After the former statement, both <var>Source</var> and
<var>Destination</var> will point to the same object. The latter statemtent
will copy the <i>contents</i> of the <var>Source</var> class to the
<var>Destination</var> class.
</p>
          </remark>
        </descr>
        <seealso>
          <link id="TPersistent.AssignTo">AssignTo</link>
        </seealso>
      </element>
      <element name="TPersistent.GetNamePath">
        <!-- Function -->
        <short>Returns a string that can be used to identify the class instance.</short>
        <descr>
          <p>
            <var>GetNamePath</var> returns a string that can be used to identify the
class instance. This can be used to display a name for this instance in a
Object designer.
</p>
          <p>
            <var>GetNamePath</var> constructs a name by recursively prepending the

            <var>Classname</var> of the 
            <var>Owner</var> instance to the

            <var>Classname</var> of this instance, separated by a dot.
</p>
        </descr>
        <seealso>
          <link id="TPersistent.GetOwner"/>
        </seealso>
      </element>
      <element name="TPersistentClass">
        <!-- "class of" type -->
        <short>Class reference type for <link id="TPersistent"/>.</short>
        <descr>
          <var>TPersistentClass</var> is the class reference type for the 
          <link id="TPersistent"/> class.
</descr>
        <seealso>
          <link id="TPersistent"/>
        </seealso>
      </element>
      <element name="TCollectionItem">
        <!-- Class -->
        <short>Basic object that is managed by a <link id="TCollection"/> class.</short>
        <descr>
          <p>
            <var>TCollectionItem</var> and 
            <link id="TCollection"/> form a pair of base
classes that manage a collection of named objects. The

            <var>TCollectionItem</var> is the named object that is managed, it
represents one item in the collection. An item in the collection is
represented by three properties: 
            <link id="TCollectionItem.DisplayName"/>, 

            <link id="TCollection.Index"/> and 
            <link id="TCollectionItem.ID"/>.
</p>
          <p>A <var>TCollectionItem</var> object is never created directly. To manage 
a set of named items, it is necessary to make a descendent of
<var>TCollectionItem</var> to which needed properties and methods are
added. This descendant can then be managed with a <link id="TCollection"/>
class. The managing collection will create and destroy it's items by itself,
it should therefore never be necessary to create <var>TCollectionItem</var>
descendents manually.
</p>
        </descr>
        <seealso>
          <link id="TCollection"/>
        </seealso>
      </element>
      <element name="TCollectionItem.Changed">
        <!-- Procedure -->
        <short>Method to notify the managing collection that the name or index of
this item has changed.
</short>
        <descr>This method is called when the <link id="TCollectionItem.DisplayName"/> is
set or when the <link id="TCollectionItem.Index"/> is changed.
</descr>
        <seealso>
          <link id="TCollectionItem.Id"/>
          <link id="TCollectionItem.Index"/>
          <link id="TCollection.Update"/>
        </seealso>
      </element>
      <element name="TCollectionItem.GetNamePath">
        <!-- Function -->
        <short>Returns the namepath of this collection item.</short>
        <descr>
          <var>GetNamePath</var> overrides the 
          <link id="TPersistent.GetNamePath"/>
method to return the name of the managing collection and appends its 
          <link id="TCollectionItem.Index"/> property.
</descr>
        <seealso>
          <link id="TCollectionItem.Collection"/>
          <link id="TPersistent.GetNamePath"/>
          <link id="TCollectionItem.Index"/>
        </seealso>
      </element>
      <element name="TCollectionItem.GetOwner">
        <!-- Function -->
        <short>Returns the managing collection.</short>
        <descr>
          <var>TCollectionItem</var> overrides 
          <link id="TPersistent.GetOwner"/> to
and returns the 
          <link id="TCollectionItem.Collection"/> that manages it.
</descr>
        <seealso>
          <link id="TPersistent.GetOwner"/>
          <link id="TCollectionItem.Collection"/>
        </seealso>
      </element>
      <element name="TCollectionItem.GetDisplayName">
        <!-- Function -->
        <short>Returns the <link id="TCollectionItem.DisplayName"/> of the 
collectionitem</short>
        <descr>
          <p>
            <var>GetDisplayName</var> returns the value of the 

            <link id="TCollectionItem.DisplayName"/> property. 
By default, this is the classname of the actual 
            <var>TCollectionItem</var> descendant.
</p>
          <p>Descendants of <var>TCollectionItem</var> can and should override this 
method to return a more meaningful value.
</p>
        </descr>
        <seealso>
          <link id="TCollectionItem.DisplayName"/>
        </seealso>
      </element>
      <element name="TCollectionItem.SetIndex">
        <!-- Procedure -->
        <short>Write method for the <link id="TCollectionItem.Index"/> property.</short>
        <descr>
          <var>SetIndex</var> implements the write handler for the 
          <link id="TCollectionItem.Index"/> property. It requests the managing collection to 
move this item to the desired index 
          <var>value</var>.
</descr>
        <seealso>
          <link id="TCollectionItem.Index"/>
        </seealso>
      </element>
      <element name="TCollectionItem.SetDisplayName">
        <!-- Procedure -->
        <short>Write method for the <link id="TCollectionItem.DisplayName"/> property</short>
        <descr>
          <p>
            <var>SetDisplayName</var> is the write method for the 
            <link id="TCollectionItem.DisplayName"/> property. It does nothing but notifying
the managing collection that the displayname has changed. It does NOT store
the actual 
            <var>Value</var>.
</p>
          <p>Descendants of <var>TCollectionItem</var> should override this method to 
store the actual displayname if this is required. 
</p>
        </descr>
        <seealso>
          <link id="TCollectionItem.DisplayName"/>
        </seealso>
      </element>
      <element name="TCollectionItem.Create">
        <!-- Constructor -->
        <short>Creates a new instance of this collection item.</short>
        <descr>
          <var>Create</var> instantiates a new item in a 
          <link id="TCollection"/>. It
is called by the 
          <link id="TCollection.Add"/> function and should under
normal circumstances never be called directly.
called 
</descr>
        <seealso>
          <link id="TCollectionItem.Destroy"/>
        </seealso>
      </element>
      <element name="TCollectionItem.Destroy">
        <!-- Destructor -->
        <short>Destroyes this collection item.</short>
        <descr>
          <p>
            <var>Destroy</var> removes the item from the managing collection 
and Destroys the item instance. 
</p>
          <p>This is the only way to remove items from a collection;
</p>
        </descr>
        <seealso>
          <link id="TCollectionItem.Create"/>
        </seealso>
      </element>
      <element name="TCollectionItem.Collection">
        <!-- Property -->
        <short>Pointer to the collection managing this item.</short>
        <descr>
          <var>Collection</var> points to the collection managing this item. This
property can be set to point to a new collection. If this is done, the old
collection will be notified that the item should no longer be managed, and
the new collection is notified that it should manage this item as well.
</descr>
        <seealso>
          <link id="TCollection"/>
        </seealso>
      </element>
      <element name="TCollectionItem.ID">
        <!-- Property -->
        <short>Initial index of this item.</short>
        <descr>
          <p>
            <var>ID</var> is the initial value of 
            <link id="TCollectionItem.Index"/>;
it doesn't change after the index changes. It can be used to uniquely
identify the item. The 
            <var>ID</var> property doesn't change as items are
added and removed from the collection.
</p>
          <p>While the <link id="TCollectionItem.Index"/> property forms a continuous 
series, <var>ID</var> does not. If items are removed from the collection, 
their <var>ID</var> is not used again, leaving gaps. Only when the
collection is initialiiy created, the <var>ID</var> and <var>Index</var>
properties will be equal.
</p>
        </descr>
        <seealso>
          <link id="TCollection.Items"/>
          <link id="TCollectionItem.Index"/>
        </seealso>
      </element>
      <element name="TCollectionItem.Index">
        <!-- Property -->
        <short>Index of the item in its managing collection <link id="TCollection.Items"/> property.</short>
        <descr>
          <p>
            <var>Index</var> is the current index of the item in its managing
collection's 
            <link id="TCollection.Items"/> property. This property may
change as items are added and removed from the collection.
</p>
          <p>The index of an item is zero-based, i.e. the first item has index zero.
The last item has index <var>Count-1</var> where <var>Count</var> is the
number of items in the collection.
</p>
          <p>The <var>Index</var> property of the items in a collection form a continuous
series ranging from <var>0</var> to <var>Count-1</var>. The <link id="TCollectionItem.ID"/> property does not form a continuous series, but
can also be used to identify an item. 
</p>
        </descr>
        <seealso>
          <link id="TCollectionItem.ID"/>
          <link id="TCollection.Items"/>
        </seealso>
      </element>
      <element name="TCollectionItem.DisplayName">
        <!-- Property -->
        <short>Name of the item, displayed in the object inspector.</short>
        <descr>
          <p>
            <var>DisplayName</var> contains the name of this item as shown in the object
inspector. For 
            <var>TCollectionItem</var> this returns always the class name 
of the managing collection, followed by the index of the item.
</p>
          <p>
            <var>TCollectionItem</var> does not implement any functionality to store
the 
            <var>DisplayName</var> property. The property can be set, but this will
have no effect other than that the managing collection is notified of a
change. The actual displayname will remain unchanged. To store the

            <var>DisplayName</var> property,
            <var>TCollectionItem</var> descendants
should override the 
            <link id="TCollectionItem.SetDisplayName"/> and

            <link id="TCollectionItem.GetDisplayName"/> to add storage functionality.
</p>
        </descr>
        <seealso>
          <link id="TCollectionItem.Index"/>
          <link id="TCollectionItem.ID"/>
          <link id="TCollectionItem.GetDisplayName"/>
          <link id="TCollectionItem.SetDisplayName"/>
        </seealso>
      </element>
      <element name="TCollectionItemClass">
        <!-- "class of" type -->
        <short>Class reference for <link id="TCollectionItem"/>.</short>
        <descr>
          <var>TCollectionItemClass</var> is used by the 

          <link id="TCollection.ItemClass"/> property of 
          <link id="TCollection"/> to
identify the descendent class of 
          <link id="TCollectionItem"/> which should
be created and managed.
</descr>
        <seealso>
          <link id="TCollectionItem"/>
          <link id="TCollection.ItemClass"/>
        </seealso>
      </element>
      <element name="TCollection">
        <!-- Class -->
        <short>Base class to manage collections of named objects.</short>
        <descr>
          <p>
            <var>TCollection</var> implements functionality to manage a collection
of named objects. Each of these objects needs to be a descendent of the 

            <link id="TCollectionItem"/> class. Exactly which type of object is managed
can be seen from the 
            <link id="TCollection.ItemClass"/> property.
</p>
          <p>Normally, no <var>TCollection</var> is created directly. Instead, a 
descendents of <var>TCollection</var> and <link id="TCollectionItem"/> 
are created as a pair.
</p>
        </descr>
        <seealso>
          <link id="TCollectionItem"/>
        </seealso>
      </element>
      <element name="TCollection.GetAttrCount">
        <!-- Function -->
        <short>Returns the count of attributes associated with each item.</short>
        <descr>
          <p>
            <var>GetAttrCount</var> returns 0 in the 
            <var>TCollection</var>
implementation. It can be used to determine the number of attributes
associated with each collection item. Descendent objects should override
this method to return the number of attributes.
</p>
          <p>This method is provided for compatibility with Delphi only and is not
used in Free Pascal.
</p>
        </descr>
        <seealso>
          <link id="TCollection.GetAttr"/>
          <link id="TCollection.GetItemAttr"/>
        </seealso>
      </element>
      <element name="TCollection.GetAttr">
        <!-- Function -->
        <short>Returns an attribute of the collection.</short>
        <descr>
          <p>This method is provided for compatibility with Delphi only and is not
used in Free Pascal.
</p>
        </descr>
        <seealso>
          <link id="TCollection.GetAttrCount"/>
          <link id="TCollection.GetItemAttr"/>
        </seealso>
      </element>
      <element name="TCollection.GetItemAttr">
        <!-- Function -->
        <short>Returns the attributes of an item.</short>
        <descr>
          <p>This method is provided for compatibility with Delphi only and is not
used in Free Pascal.
</p>
        </descr>
        <seealso>
          <link id="TCollection.GetAttr"/>
          <link id="TCollection.GetAttrCount"/>
        </seealso>
      </element>
      <element name="TCollection.GetNamePath">
        <!-- Function -->
        <short>Overrides <link id="TPersistent.GetNamePath"/> to return a proper
pathname.</short>
        <descr>
          <p>
            <var>GetNamePath</var> returns the name path for this collection. If the
following conditions are satisfied:
</p>
          <ol>
            <li>There is an owner object.</li>
            <li>The owner object returns a non-empty name path.</li>
            <li>The <link id="TCollection.Propname"/> property is not empty</li>
          </ol>
          <p>collection has an owner and the owning object has a name, then the function
returns the owner name, followed by the propname. If one of the conditions
is not satisfied, then the classname is returned.
</p>
        </descr>
        <seealso>
          <link id="TCollection.GetOwner"/>
          <link id="TCollection.Propname"/>
        </seealso>
      </element>
      <element name="TCollection.Changed">
        <!-- Procedure -->
        <short>Procedure called if an item is added to or removed from the collection.</short>
        <descr>
          <var>Changed</var> is called if a change takes place in the collection
managed by the class. If the update count ghas reached zero, it 
calls 
          <link id="TCollection.Update"/> with a nil argument.
</descr>
        <seealso>
          <link id="TCollection.Update"/>
          <link id="TCollection.Add"/>
          <link id="TCollection.Clear"/>
        </seealso>
      </element>
      <element name="TCollection.GetItem">
        <!-- Function -->
        <short>Read handler for the <link id="TCollection.Items"/> property.</short>
        <descr>
          <var>GetItem</var> is the read handler for the 
          <link id="TCollection.Items"/> property. It returns the 
          <var>Index</var>-th
element from the list of objects.
</descr>
        <errors>If <var>Index</var> is outside the allowed range, then an <link id="EListError"/> exception is raised.
</errors>
        <seealso>
          <link id="TCollection.Items"/>
          <link id="TCollection.Count"/>
          <link id="TCollection.SetItem"/>
        </seealso>
      </element>
      <element name="TCollection.SetItem">
        <!-- Procedure -->
        <short>Write handler for the <link id="TCollection.Items"/> property.</short>
        <descr>
          <var>SetItem</var> implements the write handler for the 
          <link id="TCollection.Items"/> property. It assignes 
          <var>Value</var> to the 

          <var>Index</var>-th element in the array. For this to work properly, the

          <link id="TPersistent.Assign"/> method of the 
          <var>Item</var> must work 
correctly.
</descr>
        <errors>If <var>Index</var> is outside the allowed range, then an <link id="EListError"/> exception is raised.
</errors>
        <seealso>
          <link id="TCollection.Items"/>
          <link id="TCollection.Count"/>
          <link id="TCollection.GetItem"/>
        </seealso>
      </element>
      <element name="TCollection.SetItemName">
        <!-- Procedure -->
        <short>Virtual method to set the name of the specified item</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCollection.SetPropName">
        <!-- Procedure -->
        <short>Write handler for the <link id="TCollection.PropName"/> property</short>
        <descr>
          <var>SetPropName</var> must be overridden by descendent objects to set the 

          <link id="TCollection.PropName"/> property to a suitable value. By default,

          <var>SetPropName</var> sets the 
          <var>PropName</var> property to empty.
</descr>
        <seealso>
          <link id="TCollection.PropName"/>
        </seealso>
      </element>
      <element name="TCollection.Update">
        <!-- Procedure -->
        <short>Hander called when an item in the collection has changed.</short>
        <descr>
          <p>
            <var>Update</var> is called in the following cases:
</p>
          <ol>
            <li>An item is added to or removed from the collection.</li>
            <li>An item is moved in the list, i.e. its <link id="TCollectionItem.Index"/>
property changes.</li>
            <li>An item's <link id="TCollectionItem.DisplayName"/> property
changes.</li>
          </ol>
          <p>Descendent classes can override this method to perform additional actions
when the collection changes. The <var>Item</var> parameter indicates the
item that was changed. This can be <var>Nil</var>
          </p>
        </descr>
        <seealso>
          <link id="TCollection.Changed"/>
        </seealso>
      </element>
      <element name="TCollection.PropName">
        <!-- Property -->
        <short>Name of the property that this collection represents.</short>
        <descr>
          <var>PropName</var> indicates the name of the property that this collection
is supposed to represent. By default, this is the empty string. Descendents
can override this property to return the name of the property that is
represented by this collection.
</descr>
        <seealso>
          <link id="TCollection.SetPropName"/>
          <link id="TCollection.GetPropName"/>
        </seealso>
      </element>
      <element name="TCollection.Create">
        <!-- Constructor -->
        <short>Creates a new collection.</short>
        <descr>
          <var>Create</var> instantiates a new instance of the 
          <var>TCollection</var> 
class which will manage objects of class 
          <var>AItemClass</var>. 
It creates the list used to hold all objects, and stores the 

          <var>AItemClass</var> for the adding of new objects to the collection.
</descr>
        <seealso>
          <link id="TCollection.ItemClass"/>
          <link id="TCollection.Destroy"/>
        </seealso>
      </element>
      <element name="TCollection.Destroy">
        <!-- Destructor -->
        <short>Destroys the collection and frees all the objects it manages.</short>
        <descr>
          <p>
            <var>Destroy</var> first clears the collection, and then frees all memory
allocated to this instance. 
</p>
          <p>Don't call <var>Destroy</var> directly, call <var>Free</var> instead.
</p>
        </descr>
        <seealso>
          <link id="TCollection.Create"/>
        </seealso>
      </element>
      <element name="TCollection.Add">
        <!-- Function -->
        <short>Creates and adds a new item to the collection.</short>
        <descr>
          <var>Add</var> instantiates a new item of class 
          <link id="TCollection.ItemClass"/> and adds it to the list. The newly created
object is returned.
</descr>
        <seealso>
          <link id="TCollection.ItemClass"/>
          <link id="TCollection.Clear"/>
        </seealso>
      </element>
      <element name="TCollection.Assign">
        <!-- Procedure -->
        <short>Assigns one collection to another.</short>
        <descr>
          <p>
            <var>Assign</var> assigns the contents of one collection to another.
It does this by clearing the items list, and adding as much elements as
there are in the 
            <var>Source</var> collection; it assigns to each created
element the contents of it's counterpart in the 
            <var>Source</var> element.
</p>
          <p>Two collections cannot be assigned to each other if instances of the
<var>ItemClass</var> classes cannot be assigned to each other. 
</p>
        </descr>
        <errors>If the objects in the collections cannot be assigned to one another, then
an <var>EConvertError</var> is raised.
</errors>
        <seealso>
          <link id="TPersistent.Assign"/>
          <link id="TCollectionItem"/>
        </seealso>
      </element>
      <element name="TCollection.BeginUpdate">
        <!-- Procedure -->
        <short>Start an update batch.</short>
        <descr>
          <p>
            <var>BeginUpdate</var> is called at the beginning of a batch update. It
raises the update count with 1.  
</p>
          <p>Call <var>BeginUpdate</var> at the beginning of a series of operations that
will change the state of the collection. This will avoid the call to 
<link id="TCollection.Update"/> for each operation.
At the end of the operations, a corresponding call to <var>EndUpdate</var> 
must be made. It is best to do this in the context of a 
<var>Try ... finally</var> block:
</p>
          <code>With MyCollection Do
    try
      BeginUpdate;
      // Some Lengthy operations
    finally
      EndUpdate;
    end;  
</code>
          <p>This insures that the number of calls to <var>BeginUpdate</var> always
matches the number of calls to <link id="TCollection.EndUpdate"/>, even in
case of an exception.
</p>
        </descr>
        <seealso>
          <link id="TCollection.EndUpdate"/>
          <link id="TCollection.Changed"/>
          <link id="TCollection.Update"/>
        </seealso>
      </element>
      <element name="TCollection.Clear">
        <!-- Procedure -->
        <short>Removes all items from the collection.</short>
        <descr>
          <var>Clear</var> will clear the collection, i.e. each item in the collection
is destroyed and removed from memory. 
After a call to 
          <var>Clear</var>, 
          <var>Count</var> is zero.
</descr>
        <seealso>
          <link id="TCollection.Add"/>
          <link id="TCollectionItem.Destroy"/>
          <link id="TCollection.Destroy"/>
        </seealso>
      </element>
      <element name="TCollection.EndUpdate">
        <!-- Procedure -->
        <short>Ends an update batch.</short>
        <descr>
          <var>EndUpdate</var> signals the end of a series of operations that change
the state of the collection, possibly triggering an update event. 
It does this by decreasing the update count with 1 and calling 
          <link id="TCollection.Changed"/> it should always be used in conjunction with

          <link id="TCollection.BeginUpdate"/>, preferably in the 
          <var>Finally</var>
section of a 
          <var>Try ... Finally</var> block.
</descr>
        <seealso>
          <link id="TCollection.BeginUpdate"/>
          <link id="TCollection.Changed"/>
          <link id="TCollection.Update"/>
        </seealso>
      </element>
      <element name="TCollection.FindItemID">
        <!-- Function -->
        <short>Searches for an Item in the collection, based on its
<link id="TCollectionItem.ID"/> property.</short>
        <descr>
          <p>
            <var>FindItemID</var> searches through the collection for the item that has
a value of 
            <var>ID</var> for its 
            <link id="TCollectionItem.ID"/> property,
and returns the found item. If no such item is found in the collection, 

            <var>Nil</var> is returned. 
</p>
          <p>The routine performs a linear search, so this can be slow on very large
collections.
</p>
        </descr>
        <seealso>
          <link id="TCollection.Items"/>
          <link id="TCollectionItem.ID"/>
        </seealso>
      </element>
      <element name="TCollection.Count">
        <!-- Property -->
        <short>Number of items in the collection.</short>
        <descr>
          <p>
            <var>Count</var> contains the number of items in the collection. 
</p>
          <remark>The items in the collection are identified by their <link id="TCollectionItem.Index"/> property, which is a zero-based index, meaning
that it can take values between <var>0</var> and <var>Count-1</var>, borders
included.
</remark>
        </descr>
        <seealso>
          <link id="TCollectionItem.Index"/>
          <link id="TCollection.Items"/>
        </seealso>
      </element>
      <element name="TCollection.ItemClass">
        <!-- Property -->
        <short>Class pointer for each item in the collection.</short>
        <descr>
          <var>ItemClass</var> is the class pointer with which each new item in the
collection is created. It is the value that was passed to the collection's
constructor when it was created, and does not change during the lifetime of
the collection.
</descr>
        <seealso>
          <link id="TCollectionItem"/>
          <link id="TCollection.Items"/>
        </seealso>
      </element>
      <element name="TCollection.Items">
        <!-- Property -->
        <short>Indexed array of items in the collection.</short>
        <descr>
          <p>
            <var>Items</var> provides indexed access to the items in the collection.
Since the array is zero-based, 
            <var>Index</var> should be an integer 
between 
            <var>0</var> and 
            <var>Count-1</var>.
</p>
          <p>It is possible to set or retrieve an element in the array. When setting
an element of the array, the object that is assigned should be compatible
with the class of the objects in the collection, as given by the 
<link id="TCollection.ItemClass"/> property.
</p>
          <p>Adding an element to the array can be done with the <link id="TCollection.Add"/> method. The array can be cleared with the <link id="TCollection.Clear"/> method. Removing an element of the array should
be done by freeing that element.
</p>
        </descr>
        <seealso>
          <link id="TCollection.Count"/>
          <link id="TCollection.ItemClass"/>
          <link id="TCollection.Clear"/>
          <link id="TCollection.Add"/>
        </seealso>
      </element>
      <element name="IStringsAdapter">
        <!-- Class -->
        <short>IStringsAdapter Interface declaration.</short>
        <descr>Is not yet supported in Free Pascal.
</descr>
        <seealso>
          <link id="TStrings"/>
        </seealso>
      </element>
      <element name="TStrings">
        <!-- Class -->
        <short>Abstract container class for strings.</short>
        <descr>
          <p>
            <var>TStrings</var> is used in almost all classes that hold lists of strings.
Many components implement TStrings in an different way, according to their specific needs.
All these lists can be processed in the same way, using the methods introduced in the base class.

            <var>TStrings</var> allows to retrieve strings or objects by index or by name.
</p>
          <p>
            <var>TStrings</var> is an abstract class to manage an array of
strings. It introduces methods to set and retrieve strings in the array,
searching for a particular string, concatenating the strings and so on.
It also allows an arbitrary object to be associated with each string.
</p>
          <p>It also introduces methods to manage a series of <var>name=value</var> 
pairs, as found in many configuration files or dictionaries.
</p>
          <p>An instance of <var>TStrings</var> is never created directly, instead a
descendent class such as <link id="TStringList"/> should be created. This is
because <var>TStrings</var> doesn't store any strings, this 
functionality has to be implemented in the derived classes.
</p>
          <p>Derived classes have to implement only a few methods, in order to make available the full functionality of the TStrings class:

Get, GetCount, Clear, Delete and Insert.

Also GetObject and PutObject when associated objects are supported.
</p>
[entire review 2010-01-14 DoDi]</descr>
        <seealso>
          <link id="TStringList"/>
        </seealso>
      </element>
      <element name="TStrings.DefineProperties">
        <!-- Procedure -->
        <short>Installs the methods for streaming the contents of the string collection.</short>
        <descr>
          <var>DefineProperties</var> allows the contents of the string collection
to be streamed. As such, it overrides 
          <link id="TPersistent.DefineProperties"/>
        </descr>
        <seealso>
          <link id="TPersistent.DefineProperties"/>
        </seealso>
      </element>
      <element name="TStrings.Error">
        <!-- Procedure -->
        <short>Raises an <link id="EStringListError"/> exception.</short>
        <descr>
          <p>
            <var>Error</var> raises an 
            <link id="EStringListError"/> exception. It passes

            <var>Msg</var> as a format with 
            <var>Data</var> as the only argument.
</p>
          <p>This method can be used by descendent objects to raise an error.</p>
        </descr>
        <seealso>
          <link id="EStringListError"/>
        </seealso>
      </element>
      <element name="TStrings.Get">
        <!-- Function -->
        <short>Get an string by index.</short>
        <descr>Descendent classes must override this
method and implement a routine that retrieves the <var>Index</var>-th string
in the list. <var>Index</var> should have an value between <var>0</var> and
<var>Count-1</var>, in all other cases an error should be raised using
<link id="TStrings.Error"/>.
</descr>
        <seealso>
          <link id="TStrings.Strings"/>
          <link id="TStrings.Put"/>
          <link id="TStrings.GetObject"/>
          <link id="TStringList"/>
        </seealso>
      </element>
      <element name="TStrings.GetCapacity">
        <!-- Function -->
        <short>Returns the number of allocated entries (array size).</short>
        <descr>The default implementation returns the list <link id="TStrings.Count">Count</link>.
Descendent classes can override this method, to return the current size of the allocated array.</descr>
        <seealso>
          <link id="TStrings.Capacity"/>
          <link id="TStrings.SetCapacity"/>
          <link id="TStrings.Count"/>
        </seealso>
      </element>
      <element name="TStrings.GetCount">
        <!-- Function -->
        <short>Returns the number of assigned items.</short>
        <descr>Descendent classes must override this abstract method, to return the 
current number of assigned entries in the list (empty strings included). 
</descr>
        <seealso>
          <link id="TStrings.Count"/>
          <link id="TStrings.Capacity"/>
        </seealso>
      </element>
      <element name="TStrings.GetObject">
        <!-- Function -->
        <short>Get the object associated with the indexed item.</short>
        <descr>The default implementation returns <var>Nil</var>.
Descendent classes can override this method to return the object associated to the <var>Index</var>-th string 
in the list. <var>Index</var> should have a value between <var>0</var> and
<var>Count-1</var>. If <var>Index</var> is outside the allowed range, an
error should be raised using <link id="TStrings.Error"/>.
</descr>
        <seealso>
          <link id="TStrings.Objects"/>
          <link id="TStrings.PutObject"/>
          <link id="TStrings.Get"/>
        </seealso>
      </element>
      <element name="TStrings.GetTextStr">
        <!-- Function -->
        <short>Returns the entire content as one string.</short>
        <descr>The default implementation returns the concatenated strings, separated by line endings.

Descendent classes may override this method to implement an efficienter
algorithm which is more suitable to their storage method.</descr>
        <seealso>
          <link id="TStrings.Text"/>
          <link id="TStrings.SetTextStr"/>
        </seealso>
      </element>
      <element name="TStrings.Put">
        <!-- Procedure -->
        <short>Replaces the indexed string, preserving the associated object.</short>
        <descr>The default implementation Deletes the entry and Inserts the new string and the old object.

Descendent classes can override this method with a more efficient implementation, according to their storage model.
</descr>
        <seealso>
          <link id="TStrings.Strings"/>
          <link id="TStrings.Get"/>
          <link id="TStrings.PutObject"/>
        </seealso>
      </element>
      <element name="TStrings.PutObject">
        <!-- Procedure -->
        <short>Replaces the indexed object.</short>
        <descr>The default implementation does nothing.

Derived classes can override this method, to really store the object.</descr>
        <seealso>
          <link id="TStrings.Objects"/>
          <link id="TStrings.GetObject"/>
          <link id="TStrings.Put"/>
        </seealso>
        <errors>When the index is not in 0..Count-1, an exception should be raised using <link id="TStrings.Error"/>.
</errors>
      </element>
      <element name="TStrings.SetCapacity">
        <!-- Procedure -->
        <short>Sets the capacity of the list.</short>
        <descr>
          <p>The default implementation does nothing.</p>
          <p>Descendent classes can override this method, to reallocate the memory holding the strings and objects.
When the capacity is decreased, Count should be adjusted accordingly.
</p>
        </descr>
        <seealso>
          <link id="TStrings.Capacity"/>
          <link id="TStrings.GetCapacity"/>
        </seealso>
      </element>
      <element name="TStrings.SetTextStr">
        <!-- Procedure -->
        <short>Fills the list with the lines in the given string.</short>
        <descr>Descendent classes can override this method to implement an more efficient 
algorithm, according to their storage model.
</descr>
        <seealso>
          <link id="TStrings.Text"/>
          <link id="TStrings.GetTextStr"/>
        </seealso>
      </element>
      <element name="TStrings.SetUpdateState">
        <!-- Procedure -->
        <short>Sets the update state. </short>
        <descr>This method is called when an update cycle starts or ends.

The default implementation does nothing.

Descendent classes may override this method to e.g. send change messages to their associated control.</descr>
        <seealso>
          <link id="TStrings.BeginUpdate"/>
          <link id="TStrings.EndUpdate"/>
        </seealso>
      </element>
      <element name="TStrings.Destroy">
        <!-- Destructor -->
        <short>Frees all strings in the list; associated objects are not affected.</short>
        <seealso/>
      </element>
      <element name="TStrings.Add">
        <!-- Function -->
        <short>Adds an string to the list, returning its list index.</short>
        <descr/>
        <seealso>
          <link id="TStrings.Items"/>
          <link id="TStrings.AddObject"/>"

          <link id="TStrings.Insert"/>
          <link id="TStrings.Delete"/>
          <link id="TStrings.Strings"/>
          <link id="TStrings.Count"/>
        </seealso>
      </element>
      <element name="TStrings.AddObject">
        <!-- Function -->
        <short>Adds the string and its associated object to the list.</short>
        <descr>
          <p>
            <var>AddObject</var> adds 
            <var>S</var> to the list of strings, and
associates 
            <var>AObject</var> with it. It returns the index of the new entry.
</p>
          <p>Sorted or otherwise specialized lists will not always append the new entry to the end of the list.
</p>
          <remark>An object added to the list is not automatically destroyed by the list of
the list is destroyed or the string it is associated with is deleted. It is
the responsibility of the application to destroy any objects associated with
strings.
</remark>
        </descr>
        <seealso>
          <link id="TStrings.Add"/>
          <link id="Tstrings.Items"/>
          <link id="TStrings.Objects"/>
          <link id="Tstrings.InsertObject"/>
        </seealso>
      </element>
      <element name="TStrings.Append">
        <!-- Procedure -->
        <short>Adds the string to the list.</short>
        <descr>
          <var>Append</var> does the same as 
          <link id="TStrings.Add"/>, it only does
not return the index of the inserted string.</descr>
        <seealso>
          <link id="TStrings.Add"/>
        </seealso>
      </element>
      <element name="TStrings.AddStrings">
        <!-- Procedure -->
        <short>Add contents of another stringlist to this list.</short>
        <descr>
          <var>AddStrings</var> adds the contents of 
          <var>TheStrings</var> to the
stringlist. Any associated objects are added as well.
</descr>
        <seealso>
          <link id="TStrings.Add"/>
          <link id="TStrings.Assign"/>
        </seealso>
      </element>
      <element name="TStrings.Assign">
        <!-- Procedure -->
        <short>Assign the contents of another stringlist to this one.</short>
        <descr>
          <var>Assign</var> replaces the contents of the stringlist with the contents
of 
          <var>Source</var> if 
          <var>Source</var> is also of type

          <var>TStrings</var>. Any associated objects are copied as well.
</descr>
        <seealso>
          <link id="TStrings.Add"/>
          <link id="TStrings.AddStrings"/>
          <link id="TPersistent.Assign"/>
        </seealso>
      </element>
      <element name="TStrings.BeginUpdate">
        <!-- Procedure -->
        <short>Marks the begin of an update sequence.</short>
        <descr>
          <p>Multiple consecutive changes to a string list should be enclosed within calls to <var>BeginUpdate</var> and <link id="TStrings.EndUpdate">EndUpdate</link>, to prevent unwanted actions in between.
</p>
          <p>Update sequences can be nested, UpdateCount tracks the number of pending update sequences (zero if no updates are pending). That's why it's essential that the number of BeginUpdate and EndUpdate calls match, and try-finally blocks should be used to ensure the calls of EndUpdate, even in case of exceptions.
</p>
          <p>The first BeginUpdate and the last EndUpdate call triggers the <link id="TStrings.SetUpdateState">SetUpdateState</link> method.
Because many <var>TStrings</var> methods call<var>BeginUpdate</var> and <var>EndUpdate</var> internally, according methods in derived classes should do the same, to prevent unwanted intermediate update events.
</p>
          <remark>
            <p>Always put the corresponding call to <link id="TStrings.EndUpdate"/> in the
context of a <var>Finally</var> block, to ensure that the update count is
always descreased at the end of the operation, even if an exception
occurred:
</p>
            <code>With MyStrings do
    try
      BeginUpdate;
      // some updates
    Finally
      EndUpdate
    end;  
</code>
          </remark>
        </descr>
        <seealso>
          <link id="TStrings.EndUpdate"/>
        </seealso>
      </element>
      <element name="TStrings.Clear">
        <!-- Procedure -->
        <short>Removes all entries from the list.</short>
        <descr>
          <p>
            <var>Clear</var> will remove all strings and their associated objects from
the list. After a call to clear, 
            <link id="TStrings.Count"/> is zero.
</p>
          <p>Since it is an abstract method, <var>TStrings</var> itself does not implement 
<var>Clear</var>. Descendent classes such as <link id="TStringList"/> implement this method.
</p>
        </descr>
        <seealso>
          <link id="TStrings.Items"/>
          <link id="TStrings.Delete"/>
          <link id="TStrings.Count"/>"
</seealso>
      </element>
      <element name="TStrings.Delete">
        <!-- Procedure -->
        <short>Deletes the indexed entry from the list.</short>
        <descr>
          <p>
            <var>Delete</var> deletes the string at position 
            <var>Index</var> from the
list. The associated object is also removed from the list, but not
destroyed. 
            <var>Index</var> is zero-based, and should be in the range 

            <var>0</var> to 
            <var>Count-1</var>.
</p>
          <p>Since it is an abstract method, <var>TStrings</var> itself does not implement 
<var>Delete</var>. Descendent classes such as <link id="TStringList"/> implement this method.
</p>
        </descr>
        <errors>If <var>Index</var> is not in the allowed range, an <link id="EStringListError"/> is raised.
</errors>
        <seealso>
          <link id="TStrings.Insert"/>
          <link id="TStrings.Items"/>
          <link id="TStrings.Clear"/>
        </seealso>
      </element>
      <element name="TStrings.EndUpdate">
        <!-- Procedure -->
        <short>Marks the end of an update sequence.</short>
        <descr>For more information, see <link id="TStrings.BeginUpdate"/>.
</descr>
        <seealso>
          <link id="TStrings.BeginUpdate"/>
        </seealso>
      </element>
      <element name="TStrings.Equals">
        <!-- Function -->
        <short>Compares the contents of two stringlists.</short>
        <descr>
          <p>
            <var>Equals</var> compares the contents of the stringlist with the contents
of 
            <var>TheStrings</var>. If the contents match, i.e. the stringlist contain 
an equal amount of strings, and all strings match, then 
            <var>True</var> is
returned. If the number of strings in the lists is is unequal, or they
contain one or more different strings, 
            <var>False</var> is returned.
</p>
          <remark>
            <ol>
              <li>The strings are compared case-insensitively.</li>
              <li>The associated objects are not compared</li>
            </ol>
          </remark>
        </descr>
        <seealso>
          <link id="Tstrings.Items"/>
          <link id="TStrings.Count"/>
          <link id="TStrings.Assign"/>
        </seealso>
      </element>
      <element name="TStrings.Exchange">
        <!-- Procedure -->
        <short>Exchanges two list entries.</short>
        <descr>
          <p>
            <var>Exchange</var> exchanges the strings at positions 
            <var>Index1</var>
and 
            <var>Index2</var>. The associated objects are also exchanged.
</p>
        </descr>
        <errors>If either <var>Index1</var> or <var>Index2</var> is not in the range 0..Count-1, an <link id="EStringListError"/> exception is raised.</errors>
        <seealso>
          <link id="TStrings.Move"/>
          <link id="TStrings.Strings"/>
          <link id="TStrings.Count"/>
        </seealso>
      </element>
      <element name="TStrings.GetText">
        <!-- Function -->
        <short>Returns the contents as a PChar</short>
        <descr>
          <p>
            <var>GetText</var> allocates an memory buffer and copies the contents of the
stringlist to this buffer as a series of strings, separated by end-of-line markers. The buffer is zero terminated.
</p>
          <remark>The caller is responsible for freeing the returned memory buffer. 
</remark>
        </descr>
        <seealso>
          <link id="Save and Load TStrings"/>
        </seealso>
      </element>
      <element name="TStrings.IndexOf">
        <!-- Function -->
        <short>Returns the list index of the given string; -1 if not found.</short>
        <descr>
          <p>
            <var>IndexOf</var> searches the list for 
            <var>S</var>. The search is
case-insensitive. If a matching entry is found, its position is returned.
if no matching string is found, 
            <var>-1</var> is returned.
</p>
          <remark>
            <ol>
              <li>Only the first occurrence of the string is returned.</li>
              <li>Sorted lists do a binary search, so that not necessarily the first of multiple identical entries is returned.</li>
              <li>The returned position is zero-based, i.e. 0 indicates the first string in the list.</li>
            </ol>
          </remark>
        </descr>
        <seealso>
          <link id="TStrings.IndexOfObject"/>
          <link id="TStrings.IndexOfName"/>
          <link id="TStrings.Strings"/>
        </seealso>
      </element>
      <element name="TStrings.IndexOfName">
        <!-- Function -->
        <short>Returns the index of <var>Name</var> in a name-value pairs list; -1 if not found.</short>
        <descr>For more information see <link id="TStrings.IndexOf">IndexOf</link>.</descr>
        <seealso>
          <link id="TStrings.IndexOf"/>
          <link id="TStrings.IndexOfObject"/>
          <link id="TStrings.Strings"/>
        </seealso>
      </element>
      <element name="TStrings.IndexOfObject">
        <!-- Function -->
        <short>Returns the list index of the given object; -1 if not found.</short>
        <descr>For more information see <link id="TStrings.IndexOf">IndexOf</link>.</descr>
        <seealso/>
      </element>
      <element name="TStrings.Insert">
        <!-- Procedure -->
        <short>Insert an string into the list.</short>
        <descr>
          <p>The string <var>S</var> is inserted at position <var>Index</var>, moving up the entry at this position and all following entries. 
<var>Index</var> can have values from <var>0</var> to <var>Count</var>. 
If <var>Index</var> is equal or higher than <var>Count</var>, then the string is appended to the list [implementation specific].
</p>
          <remark>
            <ol>
              <li>
                <var>Insert</var> is used by default by all methods that add strings to the list.</li>
              <li>If the string has an associated object, use <link id="TStrings.InsertObject"/> instead.</li>
            </ol>
          </remark>
        </descr>
        <errors>If <var>Index</var> is less than zero or larger than <var>Count</var> then
an <link id="EStringListError"/> exception is raised.</errors>
        <seealso>
          <link id="TStrings.Add"/>
          <link id="TStrings.InsertObject"/>
          <link id="TStrings.Append"/>
          <link id="TStrings.Delete"/>
        </seealso>
      </element>
      <element name="TStrings.InsertObject">
        <!-- Procedure -->
        <short>Inserts an string and an associated object into the list.</short>
        <descr>For more information see <link id="TStrings.Insert"/>.</descr>
        <errors>If <var>Index</var> is less than zero or larger than <var>Count</var> then
an <link id="EStringListError"/> exception is raised.</errors>
        <seealso>
          <link id="TStrings.Insert"/>
          <link id="TStrings.AddObject"/>
          <link id="TStrings.Append"/>
          <link id="TStrings.Delete"/>
        </seealso>
      </element>
      <element name="TStrings.LoadFromFile">
        <!-- Procedure -->
        <short>Fills the list with the lines in an file.</short>
        <descr>
          <p>
            <var>LoadFromFile</var> loads the contents of an file into the stringlist.
Each line in the file becomes one entry in the stringlist. 
</p>
          <p>
            <var>LoadFromFile</var> is a wrapper around 
            <link id="TStrings.LoadfromStream"/>, eliminating the need to handle an file stream in application code. 
</p>
          <p>This action replaces the contents of the stringlist.
To append the contents of an file to the list, load the file into a temporary <link id="TStringList"/> and <link id="TStrings.AddStrings">add</link> this one to the list.
</p>
        </descr>
        <seealso>
          <link id="TStrings.LoadFromStream"/>
          <link id="TStrings.SaveToFile"/>
          <link id="TStrings.SaveToStream"/>
          <link id="TStrings.SetTextString"/>
          <link id="TStrings.Text"/>
          <link id="Save and Load TStrings"/>
        </seealso>
      </element>
      <element name="TStrings.LoadFromStream">
        <!-- Procedure -->
        <short>Fills the list with the lines in an stream.</short>
        <descr>
          <var>LoadFromStream</var> loads the contents of 
          <var>Stream</var> into the stringlist.

Each line in the stream becomes one string in the stringlist.</descr>
        <seealso>
          <link id="TStrings.LoadFromFile"/>
          <link id="TStrings.SaveToFile"/>
          <link id="Tstrings.SaveToStream"/>
          <link id="Save and Load TStrings"/>
        </seealso>
      </element>
      <element name="TStrings.Move">
        <!-- Procedure -->
        <short>Move an entry to another index in the list.</short>
        <descr>
          <p>The entry at index <var>CurIndex</var> is removed from the list, and inserted again at <var>NewIndex</var>.
Both the string and its associated object are moved. 
<var>CurIndex</var> and <var>NewIndex</var> must be in the range of <var>0</var> to
<var>Count-1</var>.
</p>
          <remark>
            <p>This may not always lead to the desired result if <var>NewIndex</var> is bigger
than <var>CurIndex</var>. Consider the following example:
</p>
            <code>With MyStrings do
    begin
    Clear;
    Add('String 0');
    Add('String 1');
    Add('String 2');
    Add('String 3');
    Add('String 4');
    Move(1,3);
    end;
</code>
            <p>After the move 'String 1' will precede 'String 4', not 'String 3' at the original index 3.
</p>
          </remark>
        </descr>
        <errors>If either <var>CurIndex</var> or <var>NewIndex</var> is outside the allowed
range, an <link id="EStringListError"/> is raised.</errors>
        <seealso>
          <link id="TStrings.Exchange"/>
        </seealso>
      </element>
      <element name="TStrings.SaveToFile">
        <!-- Procedure -->
        <short>Save the contents of the list to a file.</short>
        <descr>
          <p>
            <var>SaveToFile</var> saves the contents of the stringlist to the file with
name 
            <var>FileName</var>. It writes the strings to the file, separated by
end-of-line markers, so each line in the file will contain 1 string from the
stringlist. The associated objects are not stored in the file!
</p>
          <p>
            <var>SaveToFile</var> creates a 
            <link id="TFileStream">file stream</link>
with name 
            <var>FileName</var>, calls 
            <link id="TStrings.SaveToStream"/>
and then destroys the file stream object.
</p>
        </descr>
        <errors>An <link id="EStreamError"/> exception can be raised if the file <var>FileName</var> cannot be opened,
or if it cannot be written to.</errors>
        <seealso>
          <link id="TStrings.SaveToStream"/>
          <link id="Tstrings.LoadFromStream"/>
          <link id="TStrings.LoadFromFile"/>
          <link id="Save and Load TStrings"/>
        </seealso>
      </element>
      <element name="TStrings.SaveToStream">
        <!-- Procedure -->
        <short>Save the contents of the string to a stream.</short>
        <descr>
          <p>
            <var>SaveToStream</var> saves the contents of the stringlist to

            <var>Stream</var>. It writes the strings to the stream, separated by
end-of-line markers, so each 'line' in the stream will contain 1 string from the
stringlist.
</p>
        </descr>
        <errors>An <link id="EStreamError"/> exception can be raised if the stream cannot be written to.
</errors>
        <seealso>
          <link id="TStrings.SaveToFile"/>
          <link id="Tstrings.LoadFromStream"/>
          <link id="TStrings.LoadFromFile"/>
          <link id="Save and Load TStrings"/>
        </seealso>
      </element>
      <element name="TStrings.SetText">
        <!-- Procedure -->
        <short>Replaces the contents of the list by the lines in a PChar.</short>
        <descr>
          <var>SetText</var> parses the contents of 
          <var>TheText</var> and fills the
stringlist based on the contents. It regards 
          <var>TheText</var> as a series
of strings, separated by end-of-line markers. Each of these strings is added
to the stringlist.</descr>
        <seealso>
          <link id="s"/>
          <link id="TStrings.Text"/>
          <link id="Save and Load TStrings"/>
        </seealso>
      </element>
      <element name="TStrings.Capacity">
        <!-- Property -->
        <short>Number of strings that the list can currently hold, before it tries to expand.</short>
        <descr>
          <p>
            <var>TStrings</var> returns 
            <link id="TStrings.Count"/> when read, writing has no effect. 
Descendent classes such as 
            <link id="TStringlist"/> override 
            <link id="TStrings.GetCapacity">GetCapacity</link> and 

            <link id="TStrings.SetCapacity">SetCapacity</link> as appropriate.
</p>
        </descr>
        <seealso>
          <link id="TStringList"/>
          <link id="TStrings.Count"/>
          <link id="TStrings.GetCapacity"/>
          <link id="TStrings.SetCapacity"/>
        </seealso>
      </element>
      <element name="TStrings.GetNameValue">
        <short>Return the indexed entry, splitted into its name and value parts.</short>
        <descr/>
        <seealso>
          <link id="TStrings.NameValueSeparator"/>
        </seealso>
      </element>
      <element name="TStrings.Delimiter">
        <short>Field delimiter in <link id="#rtl.classes.TStrings.DelimitedText">DelimitedText</link>.</short>
        <descr>
          <var>Delimiter</var> is the character used to separate the
stringlist strings in 
          <link id="TStrings.DelimitedText">DelimitedText</link>.</descr>
        <seealso>
          <link id="TStrings.DelimitedText"/>
        </seealso>
      </element>
      <element name="TStrings.DelimitedText">
        <short>Get or set all strings in the list in a delimited format.</short>
        <descr>
          <p>Reading <var>DelimitedText</var> returns all strings, properly quoted with <link id="TStrings.Quotechar">QuoteChar</link> and separated by the <link id="TStrings.Delimiter">Delimiter</link> character.
</p>
          <p>Strings are quoted if they contain delimiters, spaces or any other characters with ASCII value less than 32.
If <link id="TStrings.StrictDelimiter">StrictDelimiter</link> is True, only strings containing #0 or Delimiter are quoted.
[Bug: when StrictDelimiter=True, strings never are quoted]
</p>
          <p>The <link id="TStrings.CommaText">CommaText</link> property is a special form of delimited text, 
where the delimiter character is a comma and the quote character is a double quote.
</p>
        </descr>
        <seealso>
          <link id="TStrings.Delimiter"/>
          <link id="TStrings.StrictDelimiter"/>
          <link id="TStrings.Text"/>
          <link id="TStrings.QuoteChar"/>
          <link id="TStrings.CommaText"/>
        </seealso>
      </element>
      <element name="TStrings.QuoteChar">
        <short>Quote character used in <link id="#rtl.classes.TStrings.DelimitedText">DelimitedText</link>.</short>
        <descr>In DelimitedText representation the delimiters and other characters can not occur in the field strings. Such strings are automatically quoted and unquoted, using the <var>QuoteChar</var> character; hereby occurences of the quote character inside a field are handled properly, so that no restrictions apply to the allowed characters in delimited fields.</descr>
        <seealso>
          <link id="TStrings.DelimitedText"/>
        </seealso>
      </element>
      <element name="TStrings.NameValueSeparator">
        <short>The character used to split name-value pairs; default is '='.</short>
        <descr>
          <p>When a string list is desgined for access by name, every string holds a name-value pair separated by the <var>NameValueSeparator</var> character. <var>NameValueSeparator</var> is the <b>only</b> character that can not occur in the name of an entry.
</p>
          <p>By default, this is the equal sign (=), resulting in Name=Value pairs.
</p>
          <p>
            <var>NameValueSeparator</var> can be set to e.g. a colon for Name:Value pairs. This should be done 
            <b>before</b> any entries are added to the list, there is no guarantee that later changes will be reflected in the already stored entries.
</p>
          <p>A string without a <var>NameValueSeparator</var> character in it is considered as an unnamed entry, whose value is the entire string. In this special case the value part can <b>not</b> contain a <var>NameValueSeparator</var> character, because it would be interpreted as a name-value separator; unnamed entries should be added with a an additional leading <var>NameValueSeparator</var> character, that allows to split the string correctly into an empty name and remaining value part.
</p>
        </descr>
      </element>
      <element name="TStrings.ValueFromIndex">
        <short>Indexed access to the value of an entry.</short>
        <descr>
          <p>When a list is designed for <link id="TStrings.Values">access by name</link>, <var>ValueFromIndex</var> allows access to the values by their list index.</p>
          <p>The value part are all characters in the string after the 
<link id="TStrings.NameValueSeparator">NameValueSeparator</link>
character, or all characters if the <var>NameValueSeparator</var> character
is not present.</p>
        </descr>
        <seealso>
          <link id="TStrings.IndexOfName"/>
          <link id="TStrings.Values"/>
        </seealso>
      </element>
      <element name="TStringList.CustomSort">
        <short>Sort the stringlist using a custom sort algorithm</short>
        <descr>
          <var>CustomSort</var> sorts the stringlist with a custom comparison
function. The function should compare 2 elements in the list, and return a
negative number if the first item is before the second. It should return 0
if the elements are equal, and a positive result indicates that the second
elements should be before the first.
</descr>
        <seealso>
          <link id="TStringList.Sorted"/>
          <link id="TStringList.Sort"/>
        </seealso>
      </element>
      <element name="TStringList.CaseSensitive">
        <short/>
        <descr>Indicates whether locating strings happens in a case sensitive manner.</descr>
      </element>
      <element name="TStrings.CommaText">
        <!-- Property -->
        <short>Contents of the list as a comma-separated string.</short>
        <descr>
          <p>
            <var>CommaText</var> represents the stringlist as a single string,
consisting of a comma-separated concatenation of the strings in the list. 
If one of the strings contains spaces, comma's or quotes it will be enclosed by 
double quotes. Any double quotes in a string will be doubled. For instance
the following strings:
</p>
          <pre>Comma,string
Quote"string
Space string
NormalSttring
</pre>
          <p>is converted to
</p>
          <code>"Comma,string","Quote""String","Space string",NormalString
</code>
          <p>Conversely, when setting the <var>CommaText</var> property, the text will be parsed
according to the rules outlined above, and the strings will be set
accordingly. Note that spaces will in this context be regarded as string
separators, unless the string as a whole is contained in double quotes.
Spaces that occur next to a delimiter will be ignored.
The following string:
</p>
          <pre>"Comma,string" , "Quote""String",Space string,, NormalString
</pre>
          <p>Will be converted to
</p>
          <pre>Comma,String
Quote"String
Space
String

NormalString
</pre>
          <p>This is a special case of the <link id="DelimitedText"/> property where the
quote character is always the double quote, and the delimiter is always the
colon.
</p>
        </descr>
        <seealso>
          <link id="TStrings.Text"/>
          <link id="TStrings.SetText"/>
          <link id="Save and Load TStrings"/>
        </seealso>
      </element>
      <element name="TStrings.Count">
        <!-- Property -->
        <short>Number of strings in the list.</short>
        <descr>
          <p>
            <var>Count</var> is the current number of entries in the list.

            <var>TStrings</var> does not implement this property; descendent classes
herefore must implement the abstract 
            <link id="TStrings.GetCount">GetCount</link> method.
</p>
          <p>Strings in the list are always uniquely identified by their index. 
The list index is zero-based, i.e. it's supported range is <var>0</var> to <var>Count-1</var>. trying to access a string with
an index larger than or equal to <var>Count</var> will result in an error.
Code that iterates over the list in a stringlist should always take into
account the zero-based character of the list index.
</p>
        </descr>
        <seealso>
          <link id="TStrings.Strings"/>
          <link id="TStrings.Objects"/>
          <link id="TStrings.Capacity"/>
        </seealso>
      </element>
      <element name="TStrings.Names">
        <!-- Property -->
        <short>Name parts of the name-value pairs in the list.</short>
        <descr>
          <p>
            <var>Names</var> provides indexed access to the names of the name-value
pairs in the list. It returns the name part of the 
            <var>Index</var>-th
string in the list.
</p>
          <remark>The index is not an index based on the number of name-value pairs in the
list. It is the name part of the name-value pair a string <var>Index</var>
in the list. If the string at position <var>Index</var> is not a name-value
pair (i.e. does not contain the <link id="TStrings.NameValueSeparator">NameValueSeparator</link> (default '='), then an empty name is
returned.
</remark>
        </descr>
        <seealso>
          <link id="TStrings.Values"/>
          <link id="TStrings.IndexOfName"/>
        </seealso>
      </element>
      <element name="TStrings.Objects">
        <!-- Property -->
        <short>Indexed access to the objects associated with the strings in the list.</short>
        <descr>
          <p>
            <var>Objects</var> provides indexed access to the objects associated with the strings in the list. 

            <var>Index</var> must be in the range of 
            <var>0</var> to 
            <var>Count-1</var>. 
</p>
          <p>Setting the <var>objects</var> property will not free the previously associated object,
if there was one. The caller is repsonsible for freeing the object that
was previously associated to the string.
</p>
          <p>
            <var>TStrings</var> does not implement any storage for objects. Reading the

            <var>Objects</var> property will always return 
            <var>Nil</var>, setting the
property will have no effect. It is the responsability of descendent
classes to provide storage for the object references.
</p>
        </descr>
        <errors>If an <var>Index</var> outside the valid range is specified, an <link id="EStringListError"/> exception will be raised.
</errors>
        <seealso>
          <link id="TStrings.Strings"/>
          <link id="TStrings.IndexOfObject"/>
          <link id="TStrings.Names"/>
          <link id="TStrings.Values"/>
        </seealso>
      </element>
      <element name="TStrings.Values">
        <!-- Property -->
        <short>Access strings by key (Name)</short>
        <descr>
          <p>While <var>Strings</var> allows to access the list entries by index, <var>Values</var> allows for an access by name.
The <var>Name</var> can contain any characters, even spaces, except for the separator character 
<link id="TStrings.NameValueSeparator">NameValueSeparator</link>. The default NameValueSeparator is "=", compatible with the contents of INI files.
</p>
          <p>
            <var>Values</var> represents the value parts of the name-value pairs in the
list.
</p>
          <p>When reading this property, if there is a name-value pair in the list 
of strings that has name part <var>Name</var>, then the corresponding value 
is returned. If there is no such pair, an empty string is returned.
</p>
          <p>When writing this value, first it is checked whether there exists a 
name-value pair in the list with name <var>Name</var>. If such a pair is
found, it's value part is overwritten with the specified value. If no
such pair is found, a new name-value pair is added with the specified
<var>Name</var> and value.
</p>
          <remark>
            <ol>
              <li>Names are compared case-insensitively.</li>
              <li>Any character, including whitespace, up till the first <link id="TStrings.NameValueSeparator">NameValueSeparator</link>
in a string is considered part of the name.</li>
            </ol>
          </remark>
        </descr>
        <seealso>
          <link id="TStrings.Names"/>
          <link id="TStrings.Strings"/>
          <link id="TStrings.Objects"/>
          <link id="Save and Load TStrings"/>
        </seealso>
      </element>
      <element name="TStrings.Strings">
        <!-- Property -->
        <short>Indexed access to the strings in the list.</short>
        <descr>
          <p>
            <var>Strings</var> is the default property of 
            <var>TStrings</var>. It
provides indexed read-write access to the list of strings. Reading it will
return the string at position 
            <var>Index</var> in the list. Writing it will
set the string at position 
            <var>Index</var>. 
</p>
          <p>
            <var>Index</var> is the position of the string in the list. It is
zero-based, i.e. valued values range from 
            <var>0</var> (the first string in
the list) till 
            <var>Count-1</var> (the last string in the list). 
When browsing through the strings in the list, this fact must be taken into
account.
</p>
          <p>To access the objects associated with the strings in the list, use the <link id="TStrings.Objects"/> property. The name parts of name-value pairs can be
accessed with the <link id="TStrings.Names"/> property, and the values can
be set or read through the <link id="TStrings.Values"/> property.
</p>
          <p>Searching through the list can be done using the <link id="TStrings.IndexOf"/> method.
</p>
        </descr>
        <errors>If <var>Index</var> is outside the allowed range, an <link id="EStringListError"/> exception is raised.
</errors>
        <seealso>
          <link id="TStrings.Count"/>
          <link id="TStrings.Objects"/>
          <link id="TStrings.Names"/>
          <link id="TStrings.Values"/>
          <link id="TStrings.IndexOf"/>
        </seealso>
      </element>
      <element name="TStrings.Text">
        <!-- Property -->
        <short>Contents of the list as one string, containing lines of text.</short>
        <descr>
          <p>The <var>Text</var> string is compatible with the contents of an text file, where all list entries are represented by lines of text.
</p>
          <p>
            <var>Text</var> returns, when read, the contents of the stringlist as one 
big string, consisting of all strings in the list separated by end-of-line markers. 

When this property is set, the string will be cut into
smaller strings, based on the positions of end-of-line markers. Any previous content of the stringlist will be lost.
</p>
          <p>
            <var>Text</var> and related methods should be used sparingly, since most implementations store the list entries in an array of strings, and a conversion between 
            <var>Strings</var> and 
            <var>Text</var> occurs on every usage. 
It's more efficient to store the 
            <var>Text</var> in a local variable and to perform searches and other operations with that local string. When that string will be changed, write it back only after all changes are done.
</p>
          <remark>If any of the strings in the list contains an end-of-line marker, then the
resulting string will appear to contain more strings than actually present
in the list. To avoid this ambiguity, use the <link id="TStrings.CommaText"/> 
property instead.
</remark>
        </descr>
        <seealso>
          <link id="TStrings.Strings"/>
          <link id="TStrings.Count"/>
          <link id="TStrings.CommaText"/>
          <link id="Save and Load TStrings"/>
        </seealso>
      </element>
      <element name="TStrings.StringsAdapter">
        <!-- Property -->
        <short>Not implemented in Free Pascal.</short>
        <descr>This property and related classes are used in the Delphi VCL for <b>internal</b> purposes (OLE interface). Not needed in the LCL.</descr>
        <seealso/>
      </element>
      <element name="TDuplicates">
        <!-- Enumeration type -->
        <short>Type to describe what to do with duplicate values in a <link id="TStringlist"/>.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDuplicates.dupIgnore">
        <!-- Enumeration value -->
        <short>Duplicate values will not be be added to the list, but no error will
be triggered.</short>
      </element>
      <element name="TDuplicates.dupAccept">
        <!-- Enumeration value -->
        <short>Duplicate values can be added to the list.</short>
      </element>
      <element name="TDuplicates.dupError">
        <!-- Enumeration value -->
        <short>If an attempt is made to add a duplicate value to the list, an
<link id="EStringListError"/> exception is raised.</short>
      </element>
      <element name="dupIgnore">
        <!-- Enumeration value -->
        <short>Duplicate values will not be be added to the list, but no error will
be triggered.</short>
      </element>
      <element name="dupAccept">
        <!-- Enumeration value -->
        <short>Duplicate values can be added to the list.</short>
      </element>
      <element name="dupError">
        <!-- Enumeration value -->
        <short>If an attempt is made to add a duplicate value to the list, an <link id="EStringListError"/> exception is raised.</short>
      </element>
      <element name="TStringItemList">
        <!-- Array type -->
        <short>Array of <link id="TStringItem"/> records.</short>
        <descr>This declaration is provided for Delphi compatibility, it is not used in
Free Pascal.
</descr>
      </element>
      <element name="TStringList">
        <!-- Class -->
        <short>Standard implementation of the <link id="TStrings"/> class.</short>
        <descr>
          <p>
            <var>TStringList</var> is a descendent class of 
            <link id="TStrings"/> that
implements all of the abstract methods introduced there. It also introduces 
some additional methods:
</p>
          <ul>
            <li>Sort the list, or keep the list sorted at all times</li>
            <li>Special handling of duplicates in sorted lists</li>
            <li>Notification of changes in the list</li>
          </ul>
        </descr>
        <seealso>
          <link id="TStrings"/>
          <link id="TStrings.Duplicates"/>
          <link id="TStrings.Sorted"/>
        </seealso>
      </element>
      <element name="TStringList.Changed">
        <!-- Procedure -->
        <short>Called when the list of strings was modified.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TStringList.Changing">
        <!-- Procedure -->
        <short>Called when the list is changing.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TStringList.Get">
        <!-- Function -->
        <short>Overrides the standard read handler for the <link id="TStrings.Strings"/> property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TStringList.GetCapacity">
        <!-- Function -->
        <short>Overrides the standard read handler for the <link id="TStrings.Capacity"/> property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TStringList.GetCount">
        <!-- Function -->
        <short>Overrides the standard read handler for the <link id="TStrings.Count"/> property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TStringList.GetObject">
        <!-- Function -->
        <short>Overrides the standard read handler for the <link id="TStrings.Objects"/> property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TStringList.Put">
        <!-- Procedure -->
        <short>Overrides the standard write handler for the <link id="TStrings.Strings"/> property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TStringList.PutObject">
        <!-- Procedure -->
        <short>Overrides the standard write handler for the <link id="TStrings.Objects"/> property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TStringList.SetCapacity">
        <!-- Procedure -->
        <short>Overrides the standard write handler for the <link id="TStrings.Capacity"/> property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TStringList.SetUpdateState">
        <!-- Procedure -->
        <short>Overrides the standard <link id="TStrings.SetUpdateState"/>
call.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TStringList.Destroy">
        <!-- Destructor -->
        <short>Destroys the stringlist.</short>
        <descr>
          <p>
            <var>Destroy</var> clears the stringlist, release all memory allocated for
the storage of the strings, and then calls the inherited destroy method.
</p>
          <remark>Any objects associated to strings in the list will <em>not</em> be
destroyed; it is the responsability of the caller to destroy all objects
associated with strings in the list.
</remark>
        </descr>
      </element>
      <element name="TStringList.Add">
        <!-- Function -->
        <short>Implements the <link id="TStrings.Add"/> function.</short>
        <descr>
          <p>
            <var>Add</var> will add 
            <var>S</var> to the list. If the list is sorted and
the string 
            <var>S</var> is already present in the list and 

            <link id="TStringList.Duplicates"/> is 
            <var>dupError</var> then an 
            <link id="EStringListError"/> exception is raised. If 
            <var>Duplicates</var> is
set to 
            <var>dupIgnore</var> then the return value is underfined.
</p>
          <p>If the list is sorted, new strings will not necessarily be added to the end
of the list, rather they will be inserted at their alphabetical position.
</p>
        </descr>
        <errors>If the list is sorted and the string <var>S</var> is already present in the list and 
<link id="TStringList.Duplicates"/> is <var>dupError</var> then an <link id="EStringListError"/> exception is raised.
</errors>
        <seealso>
          <link id="TStringList.Insert"/>
          <link id="TStringList.Duplicates"/>
        </seealso>
      </element>
      <element name="TStringList.Clear">
        <!-- Procedure -->
        <short>Implements the <link id="TStrings.Clear"/> function.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TStringList.Delete">
        <!-- Procedure -->
        <short>Implements the <link id="TStrings.Delete"/> function.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TStringList.Exchange">
        <!-- Procedure -->
        <short>Implements the <link id="TStrings.Exchange"/> function.</short>
        <descr>
          <p>
            <var>Exchange</var> will exchange two items in the list as described in 

            <link id="TStrings.Exchange"/>. 
</p>
          <remark>
            <var>Exchange</var> will not check whether the list os sorted or not; 
if 
            <var>Exchange</var> is called on a sorted list and the strings are not
identical, the sort order of the list will be destroyed.
</remark>
        </descr>
        <seealso>
          <link id="TStringList.Sorted"/>
          <link id="TStrings.Exchange"/>
        </seealso>
      </element>
      <element name="TStringList.Find">
        <!-- Function -->
        <short>Locates the index for a given string in sorted lists.</short>
        <descr>
          <p>
            <var>Find</var> returns 
            <var>True</var> if the string 
            <var>S</var> is present in the
list. Upon exit, the 
            <var>Index</var> parameter will contain the position of
the string in the list. If the string is not found, the function will return

            <var>False</var> and 
            <var>Index</var> will contain the position where the
string will be inserted if it is added to the list.
</p>
          <remark>
            <ol>
              <li>Use this method only on sorted lists. For unsorted lists, use <link id="TStringList.IndexOf"/> instead.</li>
              <li>Find uses a binary search method to locate the string</li>
            </ol>
          </remark>
        </descr>
        <seealso/>
      </element>
      <element name="TStringList.IndexOf">
        <!-- Function -->
        <short>Overrides the <link id="TStrings.IndexOf"/> property.</short>
        <descr>
          <var>IndexOf</var> overrides the ancestor method 
          <link id="TStrings.indexOf"/>. It tries to optimize the
search by executing a binary search if the list is sorted. The function
returns the position of 
          <var>S</var> if it is found in the list, or -1 if
the string is not found in the list.
</descr>
        <seealso>
          <link id="TStrings.IndexOf"/>
          <link id="TStringList.Find"/>
        </seealso>
      </element>
      <element name="TStringList.Insert">
        <!-- Procedure -->
        <short>Overrides the <link id="TStrings.Insert"/> method.</short>
        <descr>
          <var>Insert</var> will insert the string 
          <var>S</var> at position

          <var>Index</var> in the list. If the list is sorted, an 
          <link id="EStringListError"/> exception will be raised instead. 
          <var>Index</var>
is a zero-based position. 
</descr>
        <errors>If <var>Index</var> contains an invalid value (less than zero or larger than
<var>Count</var>, or the list is sorted, an <link id="EStringListError"/>
exception will be raised.
</errors>
        <seealso>
          <link id="TStringList.Add"/>
          <link id="TStrings.Insert"/>
          <link id="TStringList.InsertObject"/>
        </seealso>
      </element>
      <element name="TStringList.Sort">
        <!-- Procedure -->
        <short>Sorts the strings in the list.</short>
        <descr>
          <var>Sort</var> will sort the strings in the list using the quicksort
algorithm. If the list has its 
          <link id="TStringList.Sorted"/> property set
to 
          <var>True</var> then nothing will be done. 
</descr>
        <seealso>
          <link id="TStringList.Sorted"/>
        </seealso>
      </element>
      <element name="TStringList.Duplicates">
        <!-- Property -->
        <short>Describes the behaviour of a sorted list with respect to duplicate
strings.</short>
        <descr>
          <p>
            <var>Duplicates</var> describes what to do in case a duplicate value is
added to the list:
</p>
          <table>
            <tr>
              <td>dupIgnore</td>
              <td>
                <printshort id="TDuplicates.dupIgnore"/>
              </td>
            </tr>
            <tr>
              <td>dupError</td>
              <td>
                <printshort id="TDuplicates.dupError"/>
              </td>
            </tr>
            <tr>
              <td>dupAccept</td>
              <td>
                <printshort id="TDuplicates.dupAccept"/>
              </td>
            </tr>
          </table>
          <p>If the stringlist is not sorted, the <var>Duplicates</var> setting is
ignored.
</p>
        </descr>
        <seealso/>
      </element>
      <element name="TStringList.Sorted">
        <!-- Property -->
        <short>Determines whether the list is sorted or not.</short>
        <descr>
          <p>
            <var>Sorted</var> can be set to 
            <var>True</var> in order to cause the list
of strings to be sorted. Further additions to the list will be inserted at
the correct position so the list remains sorted at all times. Setting the 
property to 
            <var>False</var> has no immediate effect, but will allow strings
to be inserted at any position.
</p>
          <remark>
            <ol>
              <li>When <var>Sorted</var> is <var>True</var>, <link id="TStringList.Insert"/>
cannot be used. For sorted lists, <link id="TStringList.Add"/> should be
used instead.</li>
              <li>If <var>Sorted</var> is <var>True</var>, the <link id="TStringList.Duplicates"/> setting has effect. This setting is ignored
when <var>Sorted</var> is <var>False</var>.</li>
            </ol>
          </remark>
        </descr>
        <seealso>
          <link id="TStringList.Sort"/>
          <link id="TStringList.Duplicates"/>
          <link id="TStringList.Add"/>
          <link id="TstringList.Insert"/>
        </seealso>
      </element>
      <element name="TStringList.OnChange">
        <!-- Property -->
        <short>Event triggered after the list was modified.</short>
        <descr>
          <p>
            <var>OnChange</var> can be assigned to respond to changes that have occurred
in the list. The handler is called whenever strings are added, moved,
modified or deleted from the list. 
</p>
          <p>The <var>Onchange</var> event is triggered after the modification took place. 
When the modification is about to happen, an <link id="TstringList.OnChanging"/> event occurs.
</p>
        </descr>
        <seealso>
          <link id="TStringList.OnChanging"/>
        </seealso>
      </element>
      <element name="TStringList.OnChanging">
        <!-- Property -->
        <short>Event triggered when the list is about to be modified.</short>
        <descr>
          <p>
            <var>OnChanging</var> can be assigned to respond to changes that will occurred
in the list. The handler is called whenever strings will be added, moved,
modified or deleted from the list.
</p>
          <p>The <var>Onchanging</var> event is triggered before the modification will
take place. When the modification has happened, an <link id="TstringList.OnChange"/> event occurs.
</p>
        </descr>
        <seealso>
          <link id="TStringList.OnChange"/>
        </seealso>
      </element>
      <element name="TStream">
        <!-- Class -->
        <short>Base class for streams.</short>
        <descr>
          <p>
            <var>TStream</var> is the base class for all streaming classes. It defines
methods for 
            <link id="TStream.Read">reading</link>, 
            <link id="TStream.Write">writing</link> from and to streams, as well as functions to
determine the size of the stream as well as the current position of the
stream.
</p>
          <p>Descendent classes such as <link id="TMemoryStream"/> or <link id="TFileStream"/> then override these methods to write streams to
memory or file.
</p>
        </descr>
        <seealso>
          <link id="TMemoryStream"/>
          <link id="TFileStream"/>
          <link id="TStringStream"/>
        </seealso>
      </element>
      <element name="TStream.SetSize">
        <!-- Procedure -->
        <short>Sets the size of the stream</short>
        <descr>
          <var>SetSize</var> is the write handler for the 
          <link id="TStream.Size"/>
property. The 
          <var>TStream</var> implementation of 
          <var>SetSize</var> does
nothing, but descendent classes may override this methods to allow
programmers to set the size of the stream.
</descr>
        <seealso>
          <link id="TStream.GetSize"/>
          <link id="TStream.Size"/>
        </seealso>
      </element>
      <element name="TStream.Read">
        <!-- Function -->
        <short>Reads data from the stream to a buffer and returns the number of
bytes read.</short>
        <descr>
          <p>
            <var>Read</var> attempts to read 
            <var>Count</var> from the stream to 

            <var>Buffer</var> and returns the number of bytes actually read.
</p>
          <p>This method should be used when the number of bytes is not determined. 
If a specific number of bytes is expected, use <link id="TSTream.ReadBuffer"/> instead. 
</p>
          <p>As implemented in <var>TStream</var>, <var>Read</var> does nothing but
raises an <link id="EStreamError"/> exception to indicate that reading 
is not supported. Descendent classes that allow reading must override 
this method to do the actual reading.
</p>
        </descr>
        <errors>In case a descendent class does not allow reading from the stream, an
exception is raised.
</errors>
        <seealso>
          <link id="TStream.Write"/>
          <link id="TStream.ReadBuffer"/>
        </seealso>
      </element>
      <element name="TStream.Write">
        <!-- Function -->
        <short>Writes data from a buffer to the stream and returns the number of
bytes written.</short>
        <descr>
          <p>
            <var>Write</var> attempts to write 
            <var>Count</var> bytes from

            <var>Buffer</var> to the stream. It returns the actual number of bytes
written to the stream.
</p>
          <p>This method should be used when the number of bytes that should be
written is not determined. If a specific number of bytes should be 
written, use <link id="TSTream.WriteBuffer"/> instead. 
</p>
          <p>As implemented in <var>TStream</var>, <var>Write</var> does nothing but
raises <link id="EStreamError"/> exception to indicate that writing is not supported.
Descendent classes that allow writing must override this method to do the actual writing.
</p>
        </descr>
        <errors>In case a descendent class does not allow writing to the stream, an
exception is raised.
</errors>
        <seealso>
          <link id="TStream.Read"/>
          <link id="TStream.WriteBuffer"/>
        </seealso>
      </element>
      <element name="TStream.Seek">
        <!-- Function -->
        <short>Sets the current position in the stream</short>
        <descr>
          <p>
            <var>Seek</var> sets the position of the stream to 
            <var>Offset</var> bytes
from 
            <var>Origin</var>. 
            <var>Origin</var> can have one of the following
values:
</p>
          <table>
            <tr>
              <td>Constant</td>
              <td>Meaning</td>
            </tr>
            <tr>
              <td>soFromBeginning</td>
              <td>Set the position relative to the start of
the stream.</td>
            </tr>
            <tr>
              <td>soFromCurrent</td>
              <td>Set the position relative to the current
position in the stream.</td>
            </tr>
            <tr>
              <td>soFromEnd</td>
              <td>Set the position relative to the end of the
stream.</td>
            </tr>
          </table>
          <p>
            <var>Offset</var> should be negative when the origin is 
            <var>SoFromEnd</var>. 
It should be positive for 
            <var>soFromBeginning</var> and can have both signs
for 
            <var>soFromCurrent</var>
          </p>
          <p>This is an abstract method, which must be overridden by descendent classes.
They may choose not to implement this method for all values of
<var>Origin</var> and <var>Offset</var>. 
</p>
        </descr>
        <errors>An exception may be raised if this method is called with an invalid pair of
<var>Offset</var>,<var>Origin</var> values. e.g. a negative
<var>offset</var> for <var>soFromBeginning</var>.
</errors>
        <seealso>
          <link id="TStream.Position"/>
        </seealso>
      </element>
      <element name="TStream.ReadBuffer">
        <!-- Procedure -->
        <short>Reads data from the stream to a buffer</short>
        <descr>
          <p>
            <var>ReadBuffer</var> reads 
            <var>Count</var> bytes of the stream into

            <var>Buffer</var>. If the stream does not contain 
            <var>Count</var> bytes,
then an exception is raised.
</p>
          <p>
            <var>ReadBuffer</var> should be used to read in a fixed number of bytes,
such as when reading structures or the content of variables. If the number
of bytes is not determined, use 
            <link id="TStream.Read"/> instead.

            <var>ReadBuffer</var> uses 
            <var>Read</var> internally to do the actual
reading.
</p>
        </descr>
        <errors>If the stream does not allow to read <var>Count</var> bytes, then an
exception is raised.
</errors>
        <seealso>
          <link id="TStream.Read"/>
          <link id="TStream.WriteBuffer"/>
        </seealso>
      </element>
      <element name="TStream.WriteBuffer">
        <!-- Procedure -->
        <short>Writes data from the stream to the buffer</short>
        <descr>
          <p>
            <var>WriteBuffer</var> writes 
            <var>Count</var> bytes to the stream from

            <var>Buffer</var>. If the stream does not allow 
            <var>Count</var> bytes to be
written, then an exception is raised.
</p>
          <p>
            <var>WriteBuffer</var> should be used to read in a fixed number of bytes,
such as when writing structures or the content of variables. If the number
of bytes is not determined, use 
            <link id="TStream.Write"/> instead.

            <var>WriteBuffer</var> uses 
            <var>Write</var> internally to do the actual
reading.
</p>
        </descr>
        <errors>If the stream does not allow to write <var>Count</var> bytes, then an
exception is raised.
</errors>
        <seealso>
          <link id="TStream.Write"/>
          <link id="TStream.ReadBuffer"/>
        </seealso>
      </element>
      <element name="TStream.CopyFrom">
        <!-- Function -->
        <short>Copy data from one stream to another</short>
        <descr>
          <p>
            <var>CopyFrom</var> reads 
            <var>Count</var> bytes from 
            <var>Source</var> and
writes them to the current stream. This updates the current position in the
stream. After the action is completed, the number of bytes copied is
returned.
</p>
          <p>This can be used to quickly copy data from one stream to another or to copy
the whole contents of the stream.
</p>
        </descr>
        <seealso>
          <link id="TStream.Read"/>
          <link id="TStream.Write"/>
        </seealso>
      </element>
      <element name="TStream.ReadComponent">
        <!-- Function -->
        <short>Reads component data from a stream</short>
        <descr>
          <p>
            <var>ReadComponent</var> reads a component state from the stream and
transfers this state to 
            <var>Instance</var>. If 
            <var>Instance</var> is nil,
then it is created first based on the type stored in the stream.

            <var>ReadComponent</var> returns the component as it is read from the stream.
</p>
          <p>
            <var>ReadComponent</var> simply creates a 
            <link id="TReader"/> object and
calls its 
            <link id="TReader.ReadRootComponent">ReadRootComponent</link>
method.
</p>
        </descr>
        <errors>If an error occurs during the reading of the component, an <link id="EFilerError"/> exception is raised.
</errors>
        <seealso>
          <link id="TStream.WriteComponent"/>
          <link id="TStream.ReadComponentRes"/>
          <link id="TReader.ReadRootComponent"/>
        </seealso>
      </element>
      <element name="TStream.ReadComponentRes">
        <!-- Function -->
        <short>Reads component data and resource header from a stream</short>
        <descr>
          <p>
            <var>ReadComponentRes</var> reads a resource header from the stream, and then
calls 
            <link id="TStream.ReadComponent">ReadComponent</link> to read the
component state from the stream into 
            <var>Instance</var>. 
</p>
          <p>This method is usually called by the global streaming method when
instantiating forms and datamodules as created by an IDE. It should be used
mainly on Windows, to store components in Windows resources.
</p>
        </descr>
        <errors>If an error occurs during the reading of the component, an <link id="EFilerError"/> exception is raised.
</errors>
        <seealso>
          <link id="TStream.ReadComponent"/>
          <link id="TStream.WriteComponentRes"/>
        </seealso>
      </element>
      <element name="TStream.WriteComponent">
        <!-- Procedure -->
        <short>Write component data to the stream</short>
        <descr>
          <p>
            <var>WriteComponent</var> writes the published properties of

            <var>Instance</var> to the stream, so they can later be read with 
            <link id="TStream.ReadComponent"/>. This method is intended to be used by an IDE,
to preserve the state of a form or datamodule as designed in the IDE.
</p>
          <p>
            <var>WriteComponent</var> simply calls 
            <link id="TStream.WriteDescendent">WriteDescendent</link> with 
            <var>Nil</var>
ancestor.
</p>
        </descr>
        <seealso>
          <link id="TStream.ReadComponent"/>
          <link id="TStream.WriteComponentRes"/>
        </seealso>
      </element>
      <element name="TStream.WriteComponentRes">
        <!-- Procedure -->
        <short>Write resource header and component data to a stream</short>
        <descr>
          <p>
            <var>WriteComponentRes</var> writes a 
            <var>ResName</var> resource header 
to the stream and then calls 
            <link id="TStream.WriteComponent">WriteComponent</link> 
to write the published properties of 
            <var>Instance</var> to the stream.
</p>
          <p>This method is intened for use by an IDE that can use it to store forms or
datamodules as designed in a Windows resource stream.
</p>
        </descr>
        <seealso>
          <link id="TStream.WriteComponent"/>
          <link id="TStream.ReadComponentRes"/>
        </seealso>
      </element>
      <element name="TStream.WriteDescendent">
        <!-- Procedure -->
        <short>Write component data to a stream, relative to an ancestor</short>
        <descr>
          <p>
            <var>WriteDescendent</var> writes the state of 
            <var>Instance</var> to the
stream where it differs from 
            <var>Ancestor</var>, i.e. only the changed 
properties are written to the stream.
</p>
          <p>
            <var>WriteDescendent</var> creates a 
            <link id="TWriter"/> object and calls 
its 
            <link id="TWriter.WriteDescendent">WriteDescendent</link> object. The
writer is passed a 
            <link id="TBinaryObjectWriter">binary driver
object</link> by default. 
</p>
        </descr>
        <seealso/>
      </element>
      <element name="TStream.WriteDescendentRes">
        <!-- Procedure -->
        <short>Write resource header and component data to a stream, relative to an ancestor</short>
        <descr>
          <p>
            <var>WriteDescendentRes</var> writes a 
            <var>ResName</var> resource header,
and then calls 
            <link id="TStream.WriteDescendent">WriteDescendent</link> to
write the state of 
            <var>Instance</var> to the
stream where it differs from 
            <var>Ancestor</var>, i.e. only the changed
properties are written to the stream.
</p>
          <p>This method is intened for use by an IDE that can use it to store forms or
datamodules as designed in a Windows resource stream.
</p>
        </descr>
        <seealso/>
      </element>
      <element name="TStream.WriteResourceHeader">
        <!-- Procedure -->
        <short>Write resource header to the stream</short>
        <descr>
          <p>
            <var>WriteResourceHeader</var> writes a resource-file header for a resource
called 
            <var>ResName</var>. It returns in 
            <var>FixupInfo</var> the argument
that should be passed on to 
            <link id="TStream.FixupResourceHeader"/>.
</p>
          <p>
            <var>WriteResourceHeader</var> should not be used directly. It is called by
the 
            <link id="TStream.WriteComponentRes"/> and 

            <link id="TStream.WriteDescendentRes"/>
methods.
</p>
        </descr>
        <seealso>
          <link id="TStream.FixupResourceHeader"/>
          <link id="TStream.WriteComponentRes"/>
          <link id="TStream.WriteDescendentRes"/>
        </seealso>
      </element>
      <element name="TStream.FixupResourceHeader">
        <!-- Procedure -->
        <short>Not implemented in FPC</short>
        <descr>
          <p>
            <var>FixupResourceHeader</var> is used to write the size of the resource
after a component was written to stream. The size is determined from the
current position, and it is written at position 
            <var>FixupInfo</var>. After
that the current position is restored.
</p>
          <p>
            <var>FixupResourceHeader</var> should never be called directly; it is
handled by the streaming system. 
</p>
        </descr>
        <seealso>
          <link id="TStream.WriteResourceHeader"/>
          <link id="TStream.WriteComponentRes"/>
          <link id="TStream.WriteDescendentRes"/>
        </seealso>
      </element>
      <element name="TStream.ReadResHeader">
        <!-- Procedure -->
        <short>Read a resource header from the stream.</short>
        <descr>
          <p>
            <var>ReadResourceHeader</var> reads a reasource file header from the stream.
It positions the stream just beyond the header.
</p>
          <p>
            <var>ReadResourceHeader</var> should not be called directly, it is called by
the streaming system when needed. 
</p>
        </descr>
        <errors>If the resource header is invalid an <link id="EInvalidImage"/> exception is
raised.
</errors>
        <seealso>
          <link id="TStream.ReadComponentRes"/>
          <link id="EInvalidImage"/>
        </seealso>
      </element>
      <element name="TStream.ReadByte">
        <!-- Function -->
        <short>Read a byte from the stream and return its value.</short>
        <descr>
          <var>ReadByte</var> reads one byte from the stream and returns its value.
</descr>
        <errors>If the byte cannot be read, a <link id="EStreamError"/> exception will be
raised. This is a utility function which symply calls the
<link id="TStream.Read">Read</link> function.
</errors>
        <seealso>
          <link id="TStream.Read"/>
          <link id="TStream.WriteByte"/>
          <link id="TStream.ReadWord"/>
          <link id="TStream.ReadDWord"/>
          <link id="TStream.ReadAnsiString"/>
        </seealso>
      </element>
      <element name="TStream.ReadWord">
        <!-- Function -->
        <short>Read a word from the stream and return its value.</short>
        <descr>
          <var>ReadWord</var> reads one Word (i.e. 2 bytes) from the stream 
and returns its value. This is a utility function which symply calls the

          <link id="TStream.Read">Read</link> function.
</descr>
        <errors>If the word cannot be read, a <link id="EStreamError"/> exception will be
raised.
</errors>
        <seealso>
          <link id="TStream.Read"/>
          <link id="TStream.WriteWord"/>
          <link id="TStream.ReadByte"/>
          <link id="TStream.ReadDWord"/>
          <link id="TStream.ReadAnsiString"/>
        </seealso>
      </element>
      <element name="TStream.ReadDWord">
        <!-- Function -->
        <short>Read a DWord from the stream and return its value.</short>
        <descr>
          <var>ReadDWord</var> reads one DWord (i.e. 4 bytes) from the stream 
and returns its value. This is a utility function which simply calls the

          <link id="TStream.Read">Read</link> function.
</descr>
        <errors>If the DWord cannot be read, a <link id="EStreamError"/> exception will be
raised.
</errors>
        <seealso>
          <link id="TStream.Read"/>
          <link id="TStream.WriteDWord"/>
          <link id="TStream.ReadByte"/>
          <link id="TStream.ReadWord"/>
          <link id="TStream.ReadAnsiString"/>
        </seealso>
      </element>
      <element name="TStream.ReadAnsiString">
        <!-- Function -->
        <short>Read an ansistring from the stream and return its value.</short>
        <descr>
          <var>ReadAnsiString</var> reads an ansistring from the stream 
and returns its value. This is a utility function which simply calls the
read function several times.

The Ansistring should be stored as 4 bytes (a DWord) representing the length
of the string, and then the string value itself. 
The 
          <link id="TStream.WriteAnsiString">WriteAnsiString</link> function
writes an ansistring in such a format.
</descr>
        <errors>If the AnsiString cannot be read, a <link id="EStreamError"/> exception will be
raised.
</errors>
        <seealso>
          <link id="TStream.Read"/>
          <link id="TStream.WriteAnsiString"/>
          <link id="TStream.ReadByte"/>
          <link id="TStream.ReadWord"/>
          <link id="TStream.ReadDWord"/>
        </seealso>
      </element>
      <element name="TStream.WriteByte">
        <!-- Procedure -->
        <short>Write a byte to the stream.</short>
        <descr>
          <var>WriteByte</var> writes the byte 
          <var>B</var> to the stream. This is a
utility function which simply calls the 
          <link id="TStream.Write">Write</link> function.

The byte can be read from the stream using the 
          <link id="TStream.ReadByte">ReadByte</link> function.
</descr>
        <errors>If an error occurs when attempting to write, an <link id="EStreamError"/> exception will be raised.
</errors>
        <seealso>
          <link id="TStream.Write"/>
          <link id="TStream.ReadByte"/>
          <link id="TStream.WriteWord"/>
          <link id="TStream.WriteDWord"/>
          <link id="TStream.WriteAnsiString"/>
        </seealso>
      </element>
      <element name="TStream.WriteWord">
        <!-- Procedure -->
        <short>Write a word to the stream.</short>
        <descr>
          <var>WriteWord</var> writes the word 
          <var>W</var> (i.e. 2 bytes) to the stream. This is a
utility function which simply calls the 
          <link id="TStream.Write">Write</link> function.

The word can be read from the stream using the 
          <link id="TStream.ReadWord">ReadWord</link> function.
</descr>
        <errors>If an error occurs when attempting to write, an <link id="EStreamError"/> exception will be raised.
</errors>
        <seealso>
          <link id="TStream.Write"/>
          <link id="TStream.ReadWord"/>
          <link id="TStream.WriteByte"/>
          <link id="TStream.WriteDWord"/>
          <link id="TStream.WriteAnsiString"/>
        </seealso>
      </element>
      <element name="TStream.WriteDWord">
        <!-- Procedure -->
        <short>Write a DWord to the stream.</short>
        <descr>
          <var>WriteDWord</var> writes the DWord 
          <var>D</var> (i.e. 4 bytes) to the stream. This is a
utility function which simply calls the 
          <link id="TStream.Write">Write</link> function.

The DWord can be read from the stream using the 
          <link id="TStream.ReadDWord">ReadDWord</link> function.
</descr>
        <errors>If an error occurs when attempting to write, an <link id="EStreamError"/> exception will be raised.
</errors>
        <seealso>
          <link id="TStream.Write"/>
          <link id="TStream.ReadDWord"/>
          <link id="TStream.WriteByte"/>
          <link id="TStream.WriteWord"/>
          <link id="TStream.WriteAnsiString"/>
        </seealso>
      </element>
      <element name="TStream.WriteAnsiString">
        <!-- Procedure -->
        <short>Write an ansistring to the stream.</short>
        <descr>
          <var>WriteAnsiString</var> writes the AnsiString 
          <var>S</var> (i.e. 4 bytes) to the stream. This is a
utility function which simply calls the 
          <link id="TStream.Write">Write</link> function.

The ansistring is written as a 4 byte length specifier, followed by the
ansistring's content.

The ansistring can be read from the stream using the 
          <link id="TStream.ReadAnsiString">ReadAnsiString</link> function.
</descr>
        <errors>If an error occurs when attempting to write, an <link id="EStreamError"/> exception will be raised.
</errors>
        <seealso>
          <link id="TStream.Write"/>
          <link id="TStream.ReadAnsiString"/>
          <link id="TStream.WriteByte"/>
          <link id="TStream.WriteWord"/>
          <link id="TStream.WriteDWord"/>
        </seealso>
      </element>
      <element name="TStream.Position">
        <!-- Property -->
        <short>The current position in the stream.</short>
        <descr>
          <p>
            <var>Position</var> can be read to determine the current position in the
stream. It can be written to to set the (absolute) position in the stream.
The position is zero-based, so to set the position at the beginning of the
stream, the position must be set to zero. 
</p>
          <remark>Not all <var>TStream</var>  descendants support setting the position in the 
stream, so this should be used with care.
</remark>
        </descr>
        <errors>Some descendents may raise an <link id="EStreamError"/> exception if they
do not support setting the stream position.
</errors>
        <seealso>
          <link id="TStream.Size"/>
          <link id="TStream.Seek"/>
        </seealso>
      </element>
      <element name="TStream.Size">
        <!-- Property -->
        <short>The current size of the stream.</short>
        <descr>
          <p>
            <var>Size</var> can be read to determine the stream size or to set the
stream size. 
</p>
          <remark>Not all descendents of <var>TStream</var> support getting or setting the
stream size; they may raise an exception if the <var>Size</var> property 
is read or set.
</remark>
        </descr>
        <seealso>
          <link id="TStream.Position"/>
          <link id="TStream.Seek"/>
        </seealso>
      </element>
      <element name="THandleStream">
        <!-- Class -->
        <short>Base class for streams that are identified by an OS handle.</short>
        <descr>
          <p>
            <var>THandleStream</var> is an abstract descendent of the 
            <link id="TStream"/>
class that provides methods for a stream to handle all reading and writing 
to and from a handle, provided by the underlying OS. To this end, it
overrides the 
            <link id="THandleStream.Read">Read</link> and  
            <link id="THandleStream.Write">Write</link> methods of TStream. 
</p>
          <remark>
            <ul>
              <li>
                <var>ThandleStream</var> does not obtain a handle from the OS by itself,
it just handles reading and writing to such a handle by wrapping the system
calls for reading and writing; 
Descendent classes should obtain a handle from the OS by themselves and pass it on in the inherited 
constructor.</li>
              <li>Contrary to Delphi, no seek is implemented for <var>THandleStream</var>,
since pipes and sockets do not support this. The seek is implemented in
descendent methods that support it.
</li>
            </ul>
          </remark>
        </descr>
        <seealso>
          <link id="TStream"/>
          <link id="TFileStream"/>
        </seealso>
      </element>
      <element name="THandleStream.Create">
        <!-- Constructor -->
        <short>Create a handlestream from an OS Handle.</short>
        <descr>
          <var>Create</var> creates a new instance of a 
          <var>THandleStream</var>
class. It stores 
          <var>AHandle</var> in an internal variable and 
then calls the inherited constructor. 
</descr>
        <seealso>
          <link id="TStream"/>
        </seealso>
      </element>
      <element name="THandleStream.Read">
        <!-- Function -->
        <short>Overrides standard read method.</short>
        <descr>
          <p>
            <var>Read</var> overrides the 
            <link id="TStream.Read">Read</link> 
method of 
            <var>TStream</var>. It uses the 
            <link id="THandleStream.Handle">Handle</link> property to read the

            <var>Count</var> bytes into 
            <var>Buffer</var>
          </p>
          <p>If no error occurs while reading, the number of bytes actually read will be
returned.
</p>
        </descr>
        <errors>If the operating system reports an error while reading from the handle, -1
is returned.
</errors>
        <seealso>
          <link id="TStream.Read"/>
          <link id="THandleStream.Write"/>
          <link id="THandleStream.Handle"/>
        </seealso>
      </element>
      <element name="THandleStream.Write">
        <!-- Function -->
        <short>Overrides standard write method.</short>
        <descr>
          <p>
            <var>Write</var> overrides the 
            <link id="TStream.Write">Write</link> 
method of 
            <var>TStream</var>. It uses the 
            <link id="THandleStream.Handle">Handle</link> property to write the

            <var>Count</var> bytes from 
            <var>Buffer</var>. 
</p>
          <p>If no error occurs while writing, the number of bytes actually written will be
returned.
</p>
        </descr>
        <errors>If the operating system reports an error while writing to the handle, 0 is returned. 
</errors>
        <seealso>
          <link id="TStream.Read"/>
          <link id="THandleStream.Write"/>
          <link id="THandleStream.Handle"/>
        </seealso>
      </element>
      <element name="THandleStream.Handle">
        <!-- Property -->
        <short>The OS handle of the stream.</short>
        <descr>
          <var>Handle</var> represents the Operating system handle to which reading 
and writing is done. The handle can be read only, i.e. it cannot be set
after the 
          <var>THandlestream</var> instance  was created. It should be 
passed to the constructor 
          <link id="THandleStream.Create"/>
        </descr>
        <seealso>
          <link id="THandleStream"/>
          <link id="THandleStream.Create"/>
        </seealso>
      </element>
      <element name="TFileStream">
        <!-- Class -->
        <short>Stream that stores its data in a named file on disk.</short>
        <descr>
          <p>
            <var>TFileStream</var> is a 
            <link id="TStream"/> descdendent that
stores or reads it's data from a named file in the filesystem of 
the operating system.
</p>
          <p>To this end, it overrides some of the methods in <var>TStream</var>
and implements them for the case of files on disk, and it adds the <link id="TFileStream.Filename">FileName</link> property to the list of public
properties.
</p>
        </descr>
        <seealso>
          <link id="TFileStream.Create"/>
          <link id="TStream"/>
        </seealso>
      </element>
      <element name="TFileStream.SetSize">
        <!-- Procedure -->
        <short>Sets the size of the file stream.</short>
        <descr>
          <p>
            <var>SetSize</var> sets the size of the file at 
            <var>NewSize</var> bytes.
Errors returned by the operating system call will be silently ignored.
</p>
          <p>This is the protected write method of the public <link id="TStream.Size"/>
property.
</p>
        </descr>
        <seealso>
          <link id="TStream.Size"/>
        </seealso>
      </element>
      <element name="TFileStream.Create">
        <!-- Constructor -->
        <short>Creates a file stream.</short>
        <descr>
          <p>
            <var>Create</var> creates a new instance of a 
            <var>TFileStream</var> class.
It opens the file 
            <var>AFileName</var> with mode 
            <var>Mode</var>, which can
have one of the following values:
</p>
          <table>
            <tr>
              <td>fmCreate</td>
              <td>
                <printshort id="fmCreate"/>
              </td>
            </tr>
            <tr>
              <td>fmOpenRead</td>
              <td>
                <printshort id="fmOpenRead"/>
              </td>
            </tr>
            <tr>
              <td>fmOpenWrite</td>
              <td>
                <printshort id="fmOpenWrite"/>
              </td>
            </tr>
            <tr>
              <td>fmOpenReadWrite</td>
              <td>
                <printshort id="fmOpenReadWrite"/>
              </td>
            </tr>
          </table>
          <p>After the file has been opened in the requested mode and a handle has been
obtained from the operating system, the inherited constructor is called.
</p>
        </descr>
        <errors>If the file could not be opened in the requested mode, an <link id="EFOpenError"/> exception is raised.
</errors>
        <seealso>
          <link id="TStream"/>
          <link id="TFileStream.FileName"/>
          <link id="THandleStream.Create"/>
        </seealso>
      </element>
      <element name="TFileStream.Destroy">
        <!-- Destructor -->
        <short>Destroys the file stream.</short>
        <descr>
          <p>
            <var>Destroy</var> closes the file (causing possible buffered data to be
written to disk) and then calls the inherited destructor.
</p>
          <p>Do not call <var>destroy</var> directly, instead call the <var>Free</var> 
method. Destroy does not check whether <var>Self</var> is nil, while
<var>Free</var> does.
</p>
        </descr>
        <seealso>
          <link id="TFileStream.Create"/>
        </seealso>
      </element>
      <element name="TFileStream.Seek">
        <!-- Function -->
        <short>Overrides the standard method.</short>
        <descr>
          <p>
            <var>Seek</var> attempts to set the position of the stream at

            <var>Offset</var> bytes from 
            <var>Origin</var>. 
            <var>Offset</var> can have
any integer value which would set the position within the boundaries of the
file, and thus the valid range depends on the value of 
            <var>Origin</var>.

            <var>Origin</var> can have one of the following values:
</p>
          <table>
            <tr>
              <td>soFromBeginning</td>
              <td>
                <printshort id="soFromBeginning"/>
              </td>
            </tr>
            <tr>
              <td>soFromCurrent</td>
              <td>
                <printshort id="soFromCurrent"/>
              </td>
            </tr>
            <tr>
              <td>soFromEnd</td>
              <td>
                <printshort id="soFromEnd"/>
              </td>
            </tr>
          </table>
          <p>
            <var>Seek</var> returns the new position in the file, or -1 on error.
</p>
        </descr>
        <errors>On error, -1 is returned, and the position is not changed.
</errors>
        <seealso>
          <link id="TStream.Position"/>
          <link id="TStream.Size"/>
        </seealso>
      </element>
      <element name="TFileStream.FileName">
        <!-- Property -->
        <short>The filename of the stream.</short>
        <descr>
          <var>FileName</var> is the name of the file that the stream reads from or writes
to. It is the name as passed in the constructor of the stream; it cannot be
changed. To write to another file, the stream must be freed and created
again with the new filename.
</descr>
        <seealso>
          <link id="TFileStream.Create"/>
        </seealso>
      </element>
      <element name="TCustomMemoryStream">
        <!-- Class -->
        <short>Abstract stream that stores its data in memory.</short>
        <descr>
          <p>
            <var>TCustomMemoryStream</var> is the parent class for streams that stored
their data in memory. It introduces all needed functions to handle reading
from and navigating through the memory, and introduces a 

            <link id="TCustomMemoryStream.Memory">Memory</link> property which points to
the memory area where the stream data is kept. 
</p>
          <p>The only thing which <var>TCustomMemoryStream</var> does not do is obtain 
memory to store data when writing data  or the writing of data. This
functionality is implemented in descendent streams such as <link id="TMemoryStream"/>. The reason for this approach is that this way it is
possible to create e.g. read-only descendents of
<var>TCustomMemoryStream</var> that point to a fixed part in memory which
can be read from, but not written to. 
</p>
          <remark>Since <var>TCustomMemoryStream</var> is an abstract class, do not create 
instances of <var>TMemoryStream</var> directly. Instead,
create instances of descendents such as <link id="TMemoryStream"/>. 
</remark>
        </descr>
        <seealso>
          <link id="TMemoryStream"/>
          <link id="TStream"/>
        </seealso>
      </element>
      <element name="TCustomMemoryStream.SetPointer">
        <!-- Procedure -->
        <short>Sets the internal memory pointer and size of the memory block.</short>
        <descr>
          <p>
            <var>SetPointer</var> updates the internal memory pointer and the size of
the memory area pointed to.  
</p>
          <p>Descendent memory streams should call this method whenever they set or reset
the memory the stream should read from or write to.
</p>
        </descr>
        <seealso>
          <link id="TCustomMemoryStream.Memory"/>
          <link id="TStream.Size"/>
        </seealso>
      </element>
      <element name="TCustomMemoryStream.Read">
        <!-- Function -->
        <short>Reads <var>Count</var> bytes from the stream into <var>buffer</var>.</short>
        <descr>
          <p>
            <var>Read</var> reads 
            <var>Count</var> bytes from the stream into the memory
pointed to by 
            <var>buffer</var>. It returns the number of bytes actually
read.
</p>
          <p>This method overrides the <link id="TStream.Read"/> method of <link id="TStream"/>. It will read as much bytes as are still available in the
memory area pointer to by <link id="TCustomMemoryStream.Memory">Memory</link>.
After the bytes are read, the internal stream position is updated.
</p>
        </descr>
        <seealso>
          <link id="TCustomMemoryStream.Memory"/>
          <link id="TStream.Read"/>
        </seealso>
      </element>
      <element name="TCustomMemoryStream.Seek">
        <!-- Function -->
        <short>Sets a new position in the stream.</short>
        <descr>
          <var>Seek</var> overrides the abstract 
          <link id="TStream.Seek"/> method.
It simply updates the internal stream position, and returns the new
position.
</descr>
        <errors>No checking is done whether the new position is still a valid position, i.e.
whether the position is still within the range <var>0..Size</var>.
Attempting a seek outside the valid memory range of the stream may result in
an exception at the next read or write operation.
</errors>
        <seealso>
          <link id="TStream.Position"/>
          <link id="TStream.Size"/>
          <link id="TCustomMemoryStream.Memory"/>
        </seealso>
      </element>
      <element name="TCustomMemoryStream.SaveToStream">
        <!-- Procedure -->
        <short>Writes the contents of the memory stream to another stream.</short>
        <descr>
          <p>
            <var>SaveToStream</var> writes the contents of the memory stream to  

            <var>Stream</var>. The content of 
            <var>Stream</var> is not cleared first.
The current position of the memory stream is not changed by this action.
</p>
          <remark>
            <p>This method will work much faster than the use of the 
<link id="TStream.CopyFrom"/> method:
</p>
            <code>Seek(0,soFromBeginning);
  Stream.CopyFrom(Self,Size);
</code>
            <p>because the <var>CopyFrom</var> method copies the contents in blocks, while
<var>SaveToStream</var> writes the contents of the memory as one big block.
</p>
          </remark>
        </descr>
        <errors>If an error occurs when writing to <var>Stream</var> an <link id="EStreamError"/> exception will be raised.
</errors>
        <seealso>
          <link id="TCustomMemoryStream.SaveToFile"/>
          <link id="TStream.CopyFrom"/>
        </seealso>
      </element>
      <element name="TCustomMemoryStream.SaveToFile">
        <!-- Procedure -->
        <short>Writes the contents of the stream to a file.</short>
        <descr>
          <p>
            <var>SaveToFile</var> writes the contents of the stream to a file with name

            <var>FileName</var>.
It simply creates a filestream and writes the contents of the memorystream
to this file stream using 
            <link id="TCustomMemoryStream.SaveToStream"/>.
</p>
          <remark>
            <p>This method will work much faster than the use of the <link id="TStream.CopyFrom"/> method:
</p>
            <code>Stream:=TFileStream.Create(fmCreate,FileName);
  Seek(0,soFromBeginning);
  Stream.CopyFrom(Self,Size);
</code>
            <p>because the <var>CopyFrom</var> method copies the contents in blocks, while
<var>SaveToFile</var> writes the contents of the memory as one big block.
</p>
          </remark>
        </descr>
        <errors>If an error occurs when creating or writing to the file, an <link id="EStreamError"/> exception may occur.
</errors>
        <seealso>
          <link id="TCustomMemoryStream.SaveToStream"/>
          <link id="TFileStream"/>
          <link id="TStream.CopyFrom"/>
        </seealso>
      </element>
      <element name="TCustomMemoryStream.Memory">
        <!-- Property -->
        <short>Pointer to the data kept in the memory stream.</short>
        <descr>
          <p>
            <var>Memory</var> points to the memory area where stream keeps it's data.
The property is read-only, so the pointer cannot be set this way.
</p>
          <remark>Do not write to the memory pointed to by <var>Memory</var>, since the memory
content may be read-only, and thus writing to it may cause errors.
</remark>
        </descr>
        <seealso>
          <link id="TStream.Size"/>
        </seealso>
      </element>
      <element name="TMemoryStream">
        <!-- Class -->
        <short>Standard implementation of a stream that stores its data in memory</short>
        <descr>
          <p>
            <var>TMemoryStream</var> is a 
            <link id="TStream"/> descendent that stores
it's data in memory. It descends directly from 
            <link id="TCustomMemoryStream"/>
and implements the necessary to allocate and de-allocate memory directly from
the heap. It implements the 
            <link id="TMemoryStream.Write">Write</link> method
which is missing in 
            <var>TCustomMemoryStream</var>.
</p>
          <p>
            <var>TMemoryStream</var> also introduces methods to load the contents of
another stream or a file into the memory stream.
</p>
          <p>It is not necessary to do any memory management manually, as the stream 
will allocate or de-allocate memory as needed. When the stream is freed, all
allocated memory will be freed as well.
</p>
        </descr>
        <seealso>
          <link id="TCustomMemoryStream"/>
          <link id="TStream"/>
        </seealso>
      </element>
      <element name="TMemoryStream.Realloc">
        <!-- Function -->
        <short>Sets the new capacity for the memory stream</short>
        <descr>
          <p>
            <var>SetCapacity</var> sets the capacity of the memory stream, i.e.
does the actual allocation or de-allocation of memory for the stream. It
allocates at least 
            <var>NewCapacity</var> bytes on the heap, moves the 
current contents of the stream to this location (as much as fits in) and 
returns the new memory location. 
Extra allocated memory is not initialized, i.e. may contain garbage.
</p>
          <p>Memory is allocated in blocks of 4 Kb; this can be changed by overriding 
the method.
</p>
        </descr>
        <seealso>
          <link id="TMemoryStream.Capacity"/>
        </seealso>
      </element>
      <element name="TMemoryStream.Capacity">
        <!-- Property -->
        <short>Current capacity of the stream.</short>
        <descr>
          <p>
            <var>Capacity</var> is the current capacity of the stream, this is the 
current size of the memory allocated to the stream. This is not necessarily
equal to the size of the stream, but will always be larger than or equal to
the size of the stream. When writing to the stream, the 
            <link id="TMemoryStream.Write"/> sets the capacity to the needed value.
</p>
          <p>If a lot of write operations will occur, performance may be improved by
setting the capacity to a large value, so less reallocations of memory will
occur while writing to the stream.
</p>
        </descr>
        <seealso>
          <link id="TMemoryStream.ReAlloc"/>
        </seealso>
      </element>
      <element name="TMemoryStream.Destroy">
        <!-- Destructor -->
        <short>Frees any allocated memory and destroys the memory stream.</short>
        <descr>
          <var>Destroy</var> clears the memory stream, thus in effect freeing any memory 
allocated for it, and then frees the memory stream.
</descr>
      </element>
      <element name="TMemoryStream.Clear">
        <!-- Procedure -->
        <short>Zeroes the position, capacity and size of the stream.</short>
        <descr>
          <var>Clear</var> sets the position and size to 0, and sets the capacity of
the stream to 0, thus freeing all memory allocated for the stream.
</descr>
        <seealso>
          <link id="TStream.Size"/>
          <link id="TStream.Position"/>
          <link id="TCustomMemoryStream.Memory"/>
        </seealso>
      </element>
      <element name="TMemoryStream.LoadFromStream">
        <!-- Procedure -->
        <short>Loads the contents of a stream into memory.</short>
        <descr>
          <p>
            <var>LoadFromStream</var> loads the contents of 
            <var>Stream</var> into
the memorybuffer of the stream. Any previous contents of the memory 
stream are overwritten. Memory is allocated as needed.
</p>
          <remark>
            <p>The <var>LoadFromStream</var> uses the <link id="TStream.Size">Size</link>
property of <var>Stream</var> to determine how much memory must be
allocated. Some streams do not allow the stream size to be determined, so
care must be taken when using this method.
</p>
            <p>This method will work much faster than the use of the <link id="TStream.CopyFrom"/> method:
</p>
            <code>Seek(0,soFromBeginning);
  CopyFrom(Stream,Stream.Size);
</code>
            <p>because the <var>CopyFrom</var> method copies the contents in blocks, while
<var>LoadFromStream</var> reads the contents of the stream as one big block.
</p>
          </remark>
        </descr>
        <errors>If an error occurs when reading from the stream, an <link id="EStreamError"/> may occur.
</errors>
        <seealso>
          <link id="TStream.CopyFrom"/>
          <link id="TMemoryStream.LoadFromFile"/>
        </seealso>
      </element>
      <element name="TMemoryStream.LoadFromFile">
        <!-- Procedure -->
        <short>Loads the contents of a file into memory.</short>
        <descr>
          <p>
            <var>LoadFromFile</var> loads the contents of the file with name

            <var>FileName</var> into the memory stream. The current contents of the
memory stream is replaced by the contents of the file. Memory is allocated
as needed.
</p>
          <p>The <var>LoadFromFile</var> method simply creates a filestream and then
calls the <link id="TMemoryStream.LoadFromStream"/> method.
</p>
        </descr>
If an error occurs when creating or reading from the stream, an 
        <link id="EStreamError"/> may occur.

        <seealso>
          <link id="TMemoryStream.LoadFromStream"/>
        </seealso>
      </element>
      <element name="TMemoryStream.SetSize">
        <!-- Procedure -->
        <short>Sets the size for the memory stream.</short>
        <descr>
          <var>SetSize</var> sets the size of the memory stream to 
          <var>NewSize</var>.
This will set the capacity of the stream to 
          <var>NewSize</var> and correct
the current position in the stream when needed.
</descr>
        <seealso>
          <link id="TStream.Position"/>
          <link id="TStream.Size"/>
        </seealso>
      </element>
      <element name="TMemoryStream.Write">
        <!-- Function -->
        <short>Writes data to the stream's memory.</short>
        <descr>
          <p>
            <var>Write</var> writes 
            <var>Count</var> bytes from 
            <var>Buffer</var>
to the stream's memory, starting at the current position in the stream.
If more memory is needed than currently allocated, more memory will be
allocated. Any contents in the memory stream at the current position will be
overwritten. The function returns the number of bytes actually written
(which should under normal circumstances always equal 
            <var>Count</var>).
</p>
          <p>This method overrides the <link id="TStream.Write"/> method.
</p>
        </descr>
        <errors>If no more memory could be allocated, then an exception will be raised.
</errors>
        <seealso>
          <link id="TCustomMemoryStream.Read"/>
        </seealso>
      </element>
      <element name="TStringStream">
        <!-- Class -->
        <short>Stream that stores its data in a string.</short>
        <descr>
          <p>
            <var>TStringStream</var> stores its data in an ansistring. The contents of
this string is available as the 

            <link id="TStringStream.DataString">DataString</link> property. It also
introduces some methods to read or write parts of the stringstream's data
as a string.
</p>
          <p>The main purpose of a <var>TStringSTream</var> is to be able to treat a
string as a stream from which can be read.
</p>
        </descr>
        <seealso>
          <link id="TStream"/>
          <link id="TStringStream.DataString"/>
          <link id="TStringStream.ReadString"/>
          <link id="TStringStream.WriteString"/>
        </seealso>
      </element>
      <element name="TStringStream.SetSize">
        <!-- Procedure -->
        <short>Sets the size of the stream.</short>
        <descr>
          <var>SetSize</var> sets the size of the stream to 
          <var>newsize</var>. 
It does this by setting the size of the ansisting in which the stream 
is stored. 
          <var>NewSize</var> can have any value greater than or equal to
zero.
</descr>
        <errors>In case there is not enough memory, an exception may be raised.
</errors>
        <seealso>
          <link id="TStream.Size"/>
        </seealso>
      </element>
      <element name="TStringStream.Create">
        <!-- Constructor -->
        <short>Creates a new stringstream and sets its initial content.</short>
        <descr>
          <var>Create</var> creates a new 
          <var>TStringStream</var> instance and
sets its initial content to 
          <var>Astring</var>. The position is still 0 but
the size of the stream will equal the length of the string.
</descr>
        <seealso>
          <link id="TStringStream.DataString"/>
        </seealso>
      </element>
      <element name="TStringStream.Read">
        <!-- Function -->
        <short>Reads from the stream.</short>
        <descr>
          <var>Read</var> overrides the 
          <link id="TStream.Read">Read</link>
from 
          <link id="TStream"/>. It tries to read 
          <var>Count</var> bytes into

          <var>Buffer</var>. It returns the number of bytes actually read. The
position of the stream is advanced with the number of bytes actually read;
When the reading has reached the end of the 
          <link id="TStringSTream.DataString">DataString</link>, then the reading stops,
i.e. it is not possible to read beyond the end of the datastring.
</descr>
        <seealso>
          <link id="TStream.Read"/>
          <link id="TStringStream.Write"/>
          <link id="TStringStream.DataString"/>
        </seealso>
      </element>
      <element name="TStringStream.ReadString">
        <!-- Function -->
        <short>Reads a string of length <var>Count</var>
        </short>
        <descr>
          <p>
            <var>ReadString</var> reads 
            <var>Count</var> bytes from the stream and
returns the read bytes as a string. If less than 
            <var>Count</var> bytes 
were available, the string has as many characters as bytes could be read.
</p>
          <p>The <var>ReadString</var> method is a wrapper around the <link id="TStringStream.Read">Read</link> method. It does not do the same stringas
the <link id="TStream.ReadAnsiString"/> method, which first reads a length
integer to determine the length of the string to be read.
</p>
        </descr>
        <seealso>
          <link id="TStringStream.Read"/>
          <link id="TStream.ReadAnsiString"/>
        </seealso>
      </element>
      <element name="TStringStream.Seek">
        <!-- Function -->
        <short>Sets the position in the stream.</short>
        <descr>
          <var>Seek</var> implements the abstract 
          <link id="TStream.Seek">Seek</link>
method.
</descr>
        <seealso/>
      </element>
      <element name="TStringStream.Write">
        <!-- Function -->
        <short>
          <var>Write</var> overries the 
          <link id="TStream.Write"/>
method.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TStringStream.WriteString">
        <!-- Procedure -->
        <short>
          <var>WriteString</var> writes a string to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TStringStream.DataString">
        <!-- Property -->
        <short>Contains the contents of the stream in string form</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TResourceStream">
        <!-- Class -->
        <short>Stream that reads its data from a resource object.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TResourceStream.Initialize">
        <!-- Procedure -->
        <short>Initializes the resource stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TResourceStream.Create">
        <!-- Constructor -->
        <short>Creates a new instance of a resource stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TResourceStream.CreateFromID">
        <!-- Constructor -->
        <short>Creates a new instance of a resource stream with a resource</short>
        <descr>The resource is loaded from the loaded module (identified by the handle
<var>Instance</var>), identifier <var>ResID</var> and type
<var>ResType</var>.
</descr>
        <seealso/>
      </element>
      <element name="TResourceStream.Destroy">
        <!-- Destructor -->
        <short>Destroys the instance of the resource stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TValueType">
        <!-- Enumeration type -->
        <short>Enumerated type used to identify the kind of streamed property</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TValueType.vaNull">
        <!-- Enumeration value -->
        <short>Empty value. Ends a list.</short>
      </element>
      <element name="TValueType.vaList">
        <!-- Enumeration value -->
        <short>Identifies the start of a list of values</short>
      </element>
      <element name="TValueType.vaInt8">
        <!-- Enumeration value -->
        <short>Integer value, 8 bits long.</short>
      </element>
      <element name="TValueType.vaInt16">
        <!-- Enumeration value -->
        <short>Integer value, 16 bits long.</short>
      </element>
      <element name="TValueType.vaInt32">
        <!-- Enumeration value -->
        <short>Integer value, 32 bits long.</short>
      </element>
      <element name="TValueType.vaExtended">
        <!-- Enumeration value -->
        <short>Extended value.</short>
      </element>
      <element name="TValueType.vaString">
        <!-- Enumeration value -->
        <short>String value.</short>
      </element>
      <element name="TValueType.vaIdent">
        <!-- Enumeration value -->
        <short>Identifier.</short>
      </element>
      <element name="TValueType.vaFalse">
        <!-- Enumeration value -->
        <short>Boolean <var>False</var> value.</short>
      </element>
      <element name="TValueType.vaTrue">
        <!-- Enumeration value -->
        <short>Boolean <var>True</var> value.</short>
      </element>
      <element name="TValueType.vaBinary">
        <!-- Enumeration value -->
        <short>Binary data follows.</short>
      </element>
      <element name="TValueType.vaSet">
        <!-- Enumeration value -->
        <short>Set data follows.</short>
      </element>
      <element name="TValueType.vaLString">
        <!-- Enumeration value -->
        <short>Ansistring data follows.</short>
      </element>
      <element name="TValueType.vaNil">
        <!-- Enumeration value -->
        <short>Nil pointer.</short>
      </element>
      <element name="TValueType.vaCollection">
        <!-- Enumeration value -->
        <short>Collection follows</short>
      </element>
      <element name="TValueType.vaSingle">
        <!-- Enumeration value -->
        <short>Single type follows.</short>
      </element>
      <element name="TValueType.vaCurrency">
        <!-- Enumeration value -->
        <short>Currency value follows</short>
      </element>
      <element name="TValueType.vaDate">
        <!-- Enumeration value -->
        <short>Date value follows</short>
      </element>
      <element name="TValueType.vaWString">
        <!-- Enumeration value -->
        <short>Widestring value follows.</short>
      </element>
      <element name="TValueType.vaInt64">
        <!-- Enumeration value -->
        <short>Integer value, 64 bits long.</short>
      </element>
      <element name="TFilerFlag">
        <!-- Enumeration type -->
        <short>Flags used by the <link id="TFiler"/> class</short>
        <descr>The <var>TFiler</var> class uses this enumeration type to decide whether the
streamed object was streamed as part of an inherited form or not.
</descr>
        <seealso>
          <link id="TFiler"/>
        </seealso>
      </element>
      <element name="TFilerFlag.ffInherited">
        <!-- Enumeration value -->
        <short>Stored object is an inherited object.</short>
      </element>
      <element name="TFilerFlag.ffChildPos">
        <!-- Enumeration value -->
        <short>The position of the child on it's parent is included.</short>
      </element>
      <element name="TFilerFlag.ffInline">
        <!-- Enumeration value -->
        <short>Used for frames.</short>
      </element>
      <element name="TFilerFlags">
        <!-- Set type -->
        <short>Set of <link id="TFilerFlag"/>
        </short>
      </element>
      <element name="TReaderProc">
        <!-- Procedure type -->
        <short>Reader procedure used by <link id="TPersistent.DefineProperties">DefineProperties</link>
        </short>
        <descr>The <var>TReaderProc</var> reader procedure is a callback procedure which 
will be used by a <link id="TPersistent"/> descendent to read user 
properties from a stream during the streaming process. The <var>Reader</var>
argument is the writer object which can be used read properties from the
stream.
</descr>
        <seealso>
          <Link id="TPersistent.DefineProperties"/>
        </seealso>
      </element>
      <element name="TWriterProc">
        <!-- Procedure type -->
        <short>Writer procedure used by <link id="TPersistent.DefineProperties">DefineProperties</link>
        </short>
        <descr>The <var>TWriterProc</var> writer procedure is a callback procedure which 
will be used by a <link id="TPersistent"/> descendent to write user 
properties from a stream during the streaming process. The <var>Writer</var>
argument is the writer object which can be used write properties to the
stream.
</descr>
        <seealso>
          <Link id="TPersistent.DefineProperties"/>
        </seealso>
      </element>
      <element name="TStreamProc">
        <!-- Procedure type -->
        <short>Procedure type used in streaming.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TFiler">
        <!-- Class -->
        <short>Class responsible for streaming of components.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TFiler.SetRoot">
        <!-- Procedure -->
        <short>Sets the root component which is being streamed.</short>
        <descr>Sets the root component. 
The root component is the initial component which is being streamed.
</descr>
        <seealso/>
      </element>
      <element name="TFiler.DefineProperty">
        <!-- Procedure -->
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TFiler.DefineBinaryProperty">
        <!-- Procedure -->
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TFiler.Root">
        <!-- Property -->
        <short>The root component is the initial component which is being streamed.
</short>
        <descr>The streaming process will stream a component and all the components which
it owns. The <var>Root</var> component is the component which is initially
streamed.
</descr>
        <seealso>
          <link id="TFiler.LookupRoot">LookupRoot</link>
        </seealso>
      </element>
      <element name="TFiler.LookupRoot">
        <!-- Property -->
        <short>Component used to look up ancestor components.</short>
        <descr>When comparing inherited component's values against parent values, the
values are compared with the component in <var>LookupRoot</var>. Initially,
it is set to <link id="TFiler.Root">Root</link>.
</descr>
        <seealso>
          <link id="TFiler.Root">Root</link>
        </seealso>
      </element>
      <element name="TFiler.Ancestor">
        <!-- Property -->
        <short>Ancestor component from which an inherited component is streamed.</short>
        <descr>When streaming a component, this is the parent component. Only properties
that differ from the parent's property value will be streamed.
</descr>
        <seealso>
          <link id="TFiler.Root">Root</link>
          <link id="TFiler.LookupRoot">LookupRoot</link>
        </seealso>
      </element>
      <element name="TFiler.IgnoreChildren">
        <!-- Property -->
        <short>Determines whether children will be streamed as well.</short>
        <descr>By default, all children (i.e. owned objects) will also be streamed when
streaming a component. This property can be used to prevent owned objects
from being streamed.
</descr>
      </element>
      <element name="TComponentClass">
        <!-- "class of" type -->
        <short>Class of TComponent</short>
        <descr>The <var>TComponentClass</var> type is used when constructing 
<link id="TComponent"/> descendent instances and when registering
components.
</descr>
        <seealso>
          <link id="TComponent"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader">
        <!-- Class -->
        <short>Abstract driver class to read stored component data.</short>
        <descr>
          <p>The Free Pascal streaming mechanism, while compatible with Delphi's
mechanism, differs from it in the sense that the streaming mechanism uses
a driver class when streaming components. The <var>TAbstractObjectReader</var>
class is the base driver class for reading property values from streams.
It consists entirely of abstract methods, which must be implemented by
descendent classes.
</p>
          <p>Different streaming mechanisms can be implemented by making a descendent
from <var>TAbstractObjectReader</var>. The <link id="TBinaryObjectReader"/>
class is such a descendent class, which streams data in binary (Delphi
compatible) format.
</p>
          <p>All methods described in this class, mustbe implemented by descendent
classes.
</p>
        </descr>
        <seealso>
          <link id="TBinaryObjectReader"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.NextValue">
        <!-- Function -->
        <short>Returns the type of the next value in the stream.</short>
        <descr>
          <p>This function should return the type of the next value in the stream, 
but should not read the actual value, i.e. the stream position should not be altered by
this method. This is used to 'peek' in the stream what value is next.
</p>
        </descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadValue"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.ReadValue">
        <!-- Function -->
        <short>Reads the type of the next value.</short>
        <descr>This function returns the type of the next value in the stream and reads it.
i.e. after the call to this method, the stream is positioned to read the
value of the type returned by this function.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadValue"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.BeginRootComponent">
        <!-- Procedure -->
        <short>Starts the reading of the root component.</short>
        <descr>This function can be used to initialize the driver class for reading a
component. It is called once at the beginning of the read process, and 
is immediatly followed by a call to <link id="TAbstractObjectReader.BeginComponent">BeginComponent</link>.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.BeginComponent"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.BeginComponent">
        <!-- Procedure -->
        <short>Marks the reading of a new component. </short>
        <descr>
          <p>This method is called when the streaming process wants to start reading a 
new component. 
</p>
          <p>Descendent classes should override this method to read the start of a
component new component definition and return the needed arguments. 
<var>Flags</var> should be filled with any flags that were found at the
component definition, as well as <var>AChildPos</var>. The
<var>CompClassName</var> should be filled with the class name of the
streamed component, and the <var>CompName</var> argument should be filled
with the name of the component.
</p>
          <p>
            <var>AChildPos</var> is used to change the ordering in which components
appear below their parent component when streaming descendent forms.
</p>
        </descr>
        <seealso>
          <link id="TAbstractObjectReader.BeginRootComponent"/>
          <link id="TAbstractObjectReader.BeginProperty"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.BeginProperty">
        <!-- Function -->
        <short>Marks the reading of a property value.</short>
        <descr>
          <var>BeginProperty</var> is called by the streaming system when it wants to
read a new property. The return value of the function is the name of the 
property which can be read from the stream.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.BeginComponent"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.ReadBinary">
        <!-- Procedure -->
        <short>Read binary data from the stream.</short>
        <descr>
          <var>ReadBinary</var> is called when binary data should be read from the
stream 
(i.e. after 
          <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of 
          <var>vaBinary</var>). The data should be stored in the 
          <var>DestData</var> memory stream
by descendent classes.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadFloat"/>
          <link id="TAbstractObjectReader.ReadDate"/>
          <link id="TAbstractObjectReader.ReadSingle"/>
          <link id="TAbstractObjectReader.ReadIdent"/>
          <link id="TAbstractObjectReader.ReadInt8"/>
          <link id="TAbstractObjectReader.ReadInt16"/>
          <link id="TAbstractObjectReader.ReadInt32"/>
          <link id="TAbstractObjectReader.ReadInt64"/>
          <link id="TabstractObjectReader.ReadSet"/>
          <link id="TabstractObjectReader.ReadStr"/>
          <link id="TabstractObjectReader.ReadString"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.ReadFloat">
        <!-- Function -->
        <short>Read a float value from the stream.</short>
        <descr>
          <var>ReadFloat</var> is called by the streaming system when it wants to read
a float from the stream (i.e. after 
          <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of 
          <var>vaExtended</var>). The return value should be the value of the float.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadFloat"/>
          <link id="TAbstractObjectReader.ReadDate"/>
          <link id="TAbstractObjectReader.ReadSingle"/>
          <link id="TAbstractObjectReader.ReadIdent"/>
          <link id="TAbstractObjectReader.ReadInt8"/>
          <link id="TAbstractObjectReader.ReadInt16"/>
          <link id="TAbstractObjectReader.ReadInt32"/>
          <link id="TAbstractObjectReader.ReadInt64"/>
          <link id="TabstractObjectReader.ReadSet"/>
          <link id="TabstractObjectReader.ReadStr"/>
          <link id="TabstractObjectReader.ReadString"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.ReadSingle">
        <!-- Function -->
        <short>Read a single (real-type) value from the stream.</short>
        <descr>
          <var>ReadSingle</var> is called by the streaming system when it wants to read
a single-type float from the stream  (i.e. after 
          <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of 
          <var>vaSingle</var>). The return value should be the value of 
the float.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadFloat"/>
          <link id="TAbstractObjectReader.ReadDate"/>
          <link id="TAbstractObjectReader.ReadSingle"/>
          <link id="TAbstractObjectReader.ReadIdent"/>
          <link id="TAbstractObjectReader.ReadInt8"/>
          <link id="TAbstractObjectReader.ReadInt16"/>
          <link id="TAbstractObjectReader.ReadInt32"/>
          <link id="TAbstractObjectReader.ReadInt64"/>
          <link id="TabstractObjectReader.ReadSet"/>
          <link id="TabstractObjectReader.ReadStr"/>
          <link id="TabstractObjectReader.ReadString"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.ReadDate">
        <!-- Function -->
        <short>Read a date value from the stream.</short>
        <descr>
          <var>ReadDate</var> is called by the streaming system when it wants to read
a date/time value from the stream  (i.e. after 
          <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of 
          <var>vaDate</var>). The return value should be the date/time
value. (This value can be stored as a float, since 
          <var>TDateTime</var> is
nothing but a float.)
</descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadFloat"/>
          <link id="TAbstractObjectReader.ReadSingle"/>
          <link id="TAbstractObjectReader.ReadIdent"/>
          <link id="TAbstractObjectReader.ReadInt8"/>
          <link id="TAbstractObjectReader.ReadInt16"/>
          <link id="TAbstractObjectReader.ReadInt32"/>
          <link id="TAbstractObjectReader.ReadInt64"/>
          <link id="TabstractObjectReader.ReadSet"/>
          <link id="TabstractObjectReader.ReadStr"/>
          <link id="TabstractObjectReader.ReadString"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.ReadIdent">
        <!-- Function -->
        <short>Read an identifier from the stream.</short>
        <descr>
          <p>
            <var>ReadIdent</var> is called by the streaming system if it expects to read
an identifier of type 
            <var>ValueType</var> from the stream after a call to

            <link id="TAbstractObjectReader.Readvalue">ReadValue</link> returned

            <var>vaIdent</var>. The identifier 
should be returned as a string. Note that in some cases the identifier does 
not actually have to be in the stream. The following table indicates which
identifiers must actually be read:
</p>
          <table>
            <tr>
              <td>ValueType</td>
              <td>Expected value</td>
            </tr>
            <tr>
              <td>vaIdent</td>
              <td>Read from stream.</td>
            </tr>
            <tr>
              <td>vaNil</td>
              <td>'Nil'. This does not have to be read from the stream.</td>
            </tr>
            <tr>
              <td>vaFalse</td>
              <td>'False'. This does not have to be read from the stream.</td>
            </tr>
            <tr>
              <td>vaTrue</td>
              <td>'True'. This does not have to be read from the stream.</td>
            </tr>
            <tr>
              <td>vaNull</td>
              <td>'Null'. This does not have to be read from the stream.</td>
            </tr>
          </table>
        </descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadFloat"/>
          <link id="TAbstractObjectReader.ReadDate"/>
          <link id="TAbstractObjectReader.ReadSingle"/>
          <link id="TAbstractObjectReader.ReadInt8"/>
          <link id="TAbstractObjectReader.ReadInt16"/>
          <link id="TAbstractObjectReader.ReadInt32"/>
          <link id="TAbstractObjectReader.ReadInt64"/>
          <link id="TabstractObjectReader.ReadSet"/>
          <link id="TabstractObjectReader.ReadStr"/>
          <link id="TabstractObjectReader.ReadString"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.ReadInt8">
        <!-- Function -->
        <short>Read an 8-bit integer from the stream.</short>
        <descr>
          <var>ReadInt8</var> is called by the streaming process if it expects to 
read an integer value with a size of 8 bits (1 byte) from the stream (i.e. after 
          <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of 
          <var>vaInt8</var>). 
The return value is the value if the integer. Note that the size of the
value in the stream does not actually have to be 1 byte.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadFloat"/>
          <link id="TAbstractObjectReader.ReadDate"/>
          <link id="TAbstractObjectReader.ReadSingle"/>
          <link id="TAbstractObjectReader.ReadIdent"/>
          <link id="TAbstractObjectReader.ReadInt16"/>
          <link id="TAbstractObjectReader.ReadInt32"/>
          <link id="TAbstractObjectReader.ReadInt64"/>
          <link id="TabstractObjectReader.ReadSet"/>
          <link id="TabstractObjectReader.ReadStr"/>
          <link id="TabstractObjectReader.ReadString"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.ReadInt16">
        <!-- Function -->
        <short>Read a 16-bit integer from the stream.</short>
        <descr>
          <var>ReadInt16</var> is called by the streaming process if it expects to 
read an integer value with a size of 16 bits (2 bytes) from the stream (i.e. after 
          <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of 
          <var>vaInt16</var>). 
The return value is the value if the integer. Note that the size of the 
value in the stream does not actually have to be 2 bytes.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadFloat"/>
          <link id="TAbstractObjectReader.ReadDate"/>
          <link id="TAbstractObjectReader.ReadSingle"/>
          <link id="TAbstractObjectReader.ReadIdent"/>
          <link id="TAbstractObjectReader.ReadInt8"/>
          <link id="TAbstractObjectReader.ReadInt32"/>
          <link id="TAbstractObjectReader.ReadInt64"/>
          <link id="TabstractObjectReader.ReadSet"/>
          <link id="TabstractObjectReader.ReadStr"/>
          <link id="TabstractObjectReader.ReadString"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.ReadInt32">
        <!-- Function -->
        <short>Read a 32-bit integer from the stream.</short>
        <descr>
          <var>ReadInt32</var> is called by the streaming process if it expects to 
read an integer value with a size of 32 bits (4 bytes) from the stream (i.e. after 
          <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of 
          <var>vaInt32</var>). 
The return value is the value of the integer. Note that the size of the 
value in the stream does not actually have to be 4 bytes.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadFloat"/>
          <link id="TAbstractObjectReader.ReadDate"/>
          <link id="TAbstractObjectReader.ReadSingle"/>
          <link id="TAbstractObjectReader.ReadIdent"/>
          <link id="TAbstractObjectReader.ReadInt8"/>
          <link id="TAbstractObjectReader.ReadInt16"/>
          <link id="TAbstractObjectReader.ReadInt64"/>
          <link id="TabstractObjectReader.ReadSet"/>
          <link id="TabstractObjectReader.ReadStr"/>
          <link id="TabstractObjectReader.ReadString"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.ReadInt64">
        <!-- Function -->
        <short>Read a 64-bit integer from the stream.</short>
        <descr>
          <var>ReadInt64</var> is called by the streaming process if it expects to 
read an int64 value with a size of 64 bits (8 bytes) from the stream (i.e. after 
          <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of 
          <var>vaInt64</var>). 
The return value is the value if the integer. Note that the size of the 
value in the stream does not actually have to be 8 bytes.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadFloat"/>
          <link id="TAbstractObjectReader.ReadDate"/>
          <link id="TAbstractObjectReader.ReadSingle"/>
          <link id="TAbstractObjectReader.ReadIdent"/>
          <link id="TAbstractObjectReader.ReadInt8"/>
          <link id="TAbstractObjectReader.ReadInt16"/>
          <link id="TAbstractObjectReader.ReadInt32"/>
          <link id="TabstractObjectReader.ReadSet"/>
          <link id="TabstractObjectReader.ReadStr"/>
          <link id="TabstractObjectReader.ReadString"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.ReadSet">
        <!-- Function -->
        <short>Reads a set from the stream.</short>
        <descr>
          <p>This method is called by the streaming system if it expects to read a 
set from the stream  (i.e. after <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of <var>vaSet</var>). The return value is the contents of the
set, encoded in a bitmask the following way:
</p>
          <p>For each (enumerated) value in the set, the bit corresponding to the 
ordinal value of the enumerated value should be set. i.e. 
as <var>1 shl ord(value)</var>.
</p>
        </descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadFloat"/>
          <link id="TAbstractObjectReader.ReadDate"/>
          <link id="TAbstractObjectReader.ReadSingle"/>
          <link id="TAbstractObjectReader.ReadIdent"/>
          <link id="TAbstractObjectReader.ReadInt8"/>
          <link id="TAbstractObjectReader.ReadInt16"/>
          <link id="TAbstractObjectReader.ReadInt32"/>
          <link id="TAbstractObjectReader.ReadInt64"/>
          <link id="TabstractObjectReader.ReadStr"/>
          <link id="TabstractObjectReader.ReadString"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.ReadStr">
        <!-- Function -->
        <short>Read a shortstring from the stream</short>
        <descr>
          <var>ReadStr</var> is called by the streaming system if it expects to read a
string from the stream  (i.e. after 
          <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of 
          <var>vaLString</var>,
          <var>vaWstring</var> or 

          <var>vaString</var>). The return value is the string.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadFloat"/>
          <link id="TAbstractObjectReader.ReadDate"/>
          <link id="TAbstractObjectReader.ReadSingle"/>
          <link id="TAbstractObjectReader.ReadIdent"/>
          <link id="TAbstractObjectReader.ReadInt8"/>
          <link id="TAbstractObjectReader.ReadInt16"/>
          <link id="TAbstractObjectReader.ReadInt32"/>
          <link id="TAbstractObjectReader.ReadInt64"/>
          <link id="TabstractObjectReader.ReadSet"/>
          <link id="TabstractObjectReader.ReadString"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.ReadString">
        <!-- Function -->
        <short>Read a string of type <var>StringType</var> from the stream.</short>
        <descr>
          <var>ReadStr</var> is called by the streaming system if it expects to read a
string from the stream  (i.e. after 
          <link id="TAbstractObjectReader.ReadValue">ReadValue</link> 
returned a valuetype of 
          <var>vaLString</var>,
          <var>vaWstring</var> or 

          <var>vaString</var>). The return value is the string.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadFloat"/>
          <link id="TAbstractObjectReader.ReadDate"/>
          <link id="TAbstractObjectReader.ReadSingle"/>
          <link id="TAbstractObjectReader.ReadIdent"/>
          <link id="TAbstractObjectReader.ReadInt8"/>
          <link id="TAbstractObjectReader.ReadInt16"/>
          <link id="TAbstractObjectReader.ReadInt32"/>
          <link id="TAbstractObjectReader.ReadInt64"/>
          <link id="TabstractObjectReader.ReadSet"/>
          <link id="TabstractObjectReader.ReadStr"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.SkipComponent">
        <!-- Procedure -->
        <short>Skip till the end of the component.</short>
        <descr>This method is used to skip the entire declaration of a component in the
stream. Each descendent of <var>TAbstractObjectReader</var> should implement
this in a way which is optimal for the implemented stream format.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.BeginComponent"/>
          <link id="TAbstractObjectReader.SkipValue"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.SkipValue">
        <!-- Procedure -->
        <short>Skip the current value.</short>
        <descr>
          <var>SkipValue</var> should be used when skipping a value in the stream;
The method should determine the type of the value which should be skipped
by itself, if this is necessary.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.SkipComponent"/>
        </seealso>
      </element>
      <element name="TBinaryObjectReader">
        <!-- Class -->
        <short>Driver class descendent which reads component data stored in binary format.</short>
        <descr>The <var>TBinaryObjectReader</var> class reads component data stored in 
binary form in a file. For this, it overrides or implements all abstract
methods from <link id="TAbstractObjectReader"/>. No new functionality is 
added by this class, it is a driver class for the streaming system.
</descr>
        <seealso>
          <link id="TAbstractObjectReader"/>
          <link id="TBinaryObjectWriter"/>
        </seealso>
      </element>
      <element name="TBinaryObjectReader.Create">
        <!-- Constructor -->
        <short>Creates a new binary data reader instance.</short>
        <descr>
          <var>Create</var> instantiates a new binary component data reader. The

          <var>Stream</var> stream is the stream from which data will be read. The

          <var>BufSize</var> argument is the size of the internal buffer that will be
used by the reader. This can be used to optimize the reading process.
</descr>
        <seealso>
          <link id="TAbstractObjectReader"/>
        </seealso>
      </element>
      <element name="TBinaryObjectReader.Destroy">
        <!-- Destructor -->
        <short>Destroys the binary data reader.</short>
        <descr>
          <var>Destroy</var> frees the buffer allocated when the instance was created.
It also positions the stream on the last used position in the stream (the
buffering may cause the reader to read more bytes than were actually used.)
</descr>
        <seealso>
          <link id="TBinaryObjectReader.Create"/>
        </seealso>
      </element>
      <element name="TFindMethodEvent">
        <!-- Procedure type -->
        <short>Occurs when the streaming process needs to locate a method</short>
        <descr>If a <link id="TReader"/> instance needs to locate a method and it doesn't
find it in the streamed form, then the <link id="TReader.OnFindMethod">OnFindMethod</link> event handler will be called,
if one is installed. This event can be assigned in order to use different
locating methods. If a method is found, then its address should be returned
in <var>Address</var>. The <var>Error</var> should be set to <var>True</var> 
if the reader should raise an exception after the event was handled. If it 
is set to <var>False</var> no exception will be raised, even if no method
was found. On entry, <var>Error</var> will be set to <var>True</var>.
</descr>
      </element>
      <element name="TSetNameEvent">
        <!-- Procedure type -->
        <short>Occurs when the reader needs to set a component's name.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReferenceNameEvent">
        <!-- Procedure type -->
        <short>Occurs when a named object needs to be looked up.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAncestorNotFoundEvent">
        <!-- Procedure type -->
        <short>This event occurs when an ancestor component cannot be found.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReadComponentsProc">
        <!-- Procedure type -->
        <short>Callback type when reading a component from a stream</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReaderError">
        <!-- Procedure type -->
        <short>Event handler type, called when an error occurs during the streaming.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TFindComponentClassEvent">
        <!-- Procedure type -->
        <short>Event handler type, occurs when a component class pointer must be
found when reading a component from a stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCreateComponentEvent">
        <!-- Procedure type -->
        <short>Event handler type, occurs when a component instance must be created
when a component is read from a stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader">
        <!-- Class -->
        <short>Generic reader object which reads component data from any given source.</short>
        <descr>The <var>TReader</var> class is a reader class that implements generic
component streaming capabilities, independent of the format of the data in
the stream. It uses a driver class <link id="TAbstractObjectReader"/> to
do the actual reading of data. The interface of the <var>TReader</var> class
should be identical to the interface in Delphi.
</descr>
        <seealso>
          <link id="TFiler"/>
          <link id="TWriter"/>
          <link id="TAbstractObjectReader"/>
        </seealso>
      </element>
      <element name="TReader.Error">
        <!-- Function -->
        <short>Calls an installed error handler and passes it <var>Message</var>
        </short>
        <descr>
          <p>
            <var>Error</var> returns 
            <var>False</var> if no 
            <link id="TReader.OnError"/>
handler is installed. If one is installed, then it will be called, passing
the reader instance, message, and function return value as parameters.
</p>
          <p>If the function result <var>False</var>, i.e. when there is no handler
installed or the handler restured <var>False</var>, then the calling code
will raise an exception.
</p>
        </descr>
        <seealso>
          <link id="TReader.FindMethod"/>
        </seealso>
      </element>
      <element name="TReader.FindMethod">
        <!-- Function -->
        <short>Return the address of a published method.</short>
        <descr>
          <p>
            <var>FindMethod</var> will search for the method in 
            <var>ARoot</var>. If it
isn't found there, then it will call a 
            <var>OnFindMethod</var> handler, if
one is installed, passing it the method name 
            <var>AMethodName</var>, the
result pointer and a variable which says whether an exception should be
raised if no method with name 
            <var>AMethodName</var> is found.
</p>
          <p>If the method cannot be found and the <link id="TReader.OnFindMethod">OnFindMethod</link> returns <var>True</var>, then
an exception will be raised.
</p>
        </descr>
        <seealso>
          <link id="TReader.OnFindMethod"/>
          <link id="TFindMethodEvent"/>
        </seealso>
      </element>
      <element name="TReader.ReadProperty">
        <!-- Procedure -->
        <short>Read and process a property name</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadPropValue">
        <!-- Procedure -->
        <short>Reads a property value for <var>PropInfo</var>.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.PropertyError">
        <!-- Procedure -->
        <short>Skips a property value and raises an exception.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadData">
        <!-- Procedure -->
        <short>Reads the components data after it has been created.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.PropName">
        <!-- Property -->
        <short>Name of the property being read at this moment.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.CanHandleExceptions">
        <!-- Property -->
        <short>Indicates whether the reader is handling exceptions at this stage.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.Create">
        <!-- Constructor -->
        <short>Creates a new reader class</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.Destroy">
        <!-- Destructor -->
        <short>Destroys a reader class.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.BeginReferences">
        <!-- Procedure -->
        <short>Initializes the component referencing mechanism.</short>
        <descr>When streaming components, the streaming mechanism keeps a list of existing
components that can be referenced to. This method initializes up that system.
</descr>
      </element>
      <element name="TReader.CheckValue">
        <!-- Procedure -->
        <short>Raises an exception if the next value in the stream is not of type
<var>Value</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.DefineProperty">
        <!-- Procedure -->
        <short>Reads a user-defined property from the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.DefineBinaryProperty">
        <!-- Procedure -->
        <short>Reads a user-defined binary property from the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.EndOfList">
        <!-- Function -->
        <short>Returns true if the stream contains an end-of-list marker.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.EndReferences">
        <!-- Procedure -->
        <short>Finalizes the component referencing mechanism.</short>
        <descr>When streaming components, the streaming mechanism keeps a list of existing
components that can be referenced to. This method cleans up that system.
</descr>
        <seealso/>
      </element>
      <element name="TReader.FixupReferences">
        <!-- Procedure -->
        <short>Tries to resolve all unresolved component references.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.NextValue">
        <!-- Function -->
        <short>Returns the type of the next value.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadBoolean">
        <!-- Function -->
        <short>Reads a boolean from the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadChar">
        <!-- Function -->
        <short>Reads a character from the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadCollection">
        <!-- Procedure -->
        <short>Reads a collection from the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadComponent">
        <!-- Function -->
        <short>Starts reading a component from the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadComponents">
        <!-- Procedure -->
        <short>Starts reading child components from the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadFloat">
        <!-- Function -->
        <short>Reads a float from the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadSingle">
        <!-- Function -->
        <short>Reads a single-type real from the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadDate">
        <!-- Function -->
        <short>Reads a date from the stream</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadIdent">
        <!-- Function -->
        <short>Reads an identifier from the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadInteger">
        <!-- Function -->
        <short>Reads an integer from the stream</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadInt64">
        <!-- Function -->
        <short>Reads a 64-bit integer from the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadListBegin">
        <!-- Procedure -->
        <short>Checks for the beginning of a list.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadListEnd">
        <!-- Procedure -->
        <short>Checks for the end of a list.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadRootComponent">
        <!-- Function -->
        <short>Starts reading a root component.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadString">
        <!-- Function -->
        <short>Reads a string from the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.ReadValue">
        <!-- Function -->
        <short>Reads the next value type from the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.CopyValue">
        <!-- Procedure -->
        <short>Copy a value to a writer.</short>
        <descr>
          <var>CopyValue</var> reads the next value from the reader stream, and writes
it to the passed 
          <var>Writer</var>.
</descr>
        <seealso/>
      </element>
      <element name="TReader.Owner">
        <!-- Property -->
        <short>Owner of the component being read</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.Parent">
        <!-- Property -->
        <short>Parent of the component being read.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.Driver">
        <!-- Property -->
        <short>The driver in use for streaming the data.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.OnError">
        <!-- Property -->
        <short>Handler called when an error occurs.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.OnFindMethod">
        <!-- Property -->
        <short>Handler to find or change a method address.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.OnSetName">
        <!-- Property -->
        <short>Handler called when setting a component name.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.OnReferenceName">
        <!-- Property -->
        <short>Handler called when another component is referenced.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.OnAncestorNotFound">
        <!-- Property -->
        <short>Handler called when the ancestor component cannot be found.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.OnCreateComponent">
        <!-- Property -->
        <short>Handler called when a component needs to be created.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TReader.OnFindComponentClass">
        <!-- Property -->
        <short>Handler called when a component class reference needs to be found.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAbstractObjectWriter">
        <!-- Class -->
        <short>Abstract driver class for writing component data.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAbstractObjectWriter.BeginCollection">
        <!-- Procedure -->
        <short>Start writing a collection.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAbstractObjectWriter.BeginComponent">
        <!-- Procedure -->
        <short>Start writing a component</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAbstractObjectWriter.BeginList">
        <!-- Procedure -->
        <short>Start writing a list.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAbstractObjectWriter.EndList">
        <!-- Procedure -->
        <short>Mark the end of a list.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAbstractObjectWriter.BeginProperty">
        <!-- Procedure -->
        <short>Start writing a property</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAbstractObjectWriter.EndProperty">
        <!-- Procedure -->
        <short>Marks the end of writing of a property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAbstractObjectWriter.WriteBinary">
        <!-- Procedure -->
        <short>Writes binary data to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAbstractObjectWriter.WriteBoolean">
        <!-- Procedure -->
        <short>Writes a boolean value to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAbstractObjectWriter.WriteFloat">
        <!-- Procedure -->
        <short>Writes a float value to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAbstractObjectWriter.WriteSingle">
        <!-- Procedure -->
        <short>Writes a single-type real value to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAbstractObjectWriter.WriteDate">
        <!-- Procedure -->
        <short>Writes a date type to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAbstractObjectWriter.WriteIdent">
        <!-- Procedure -->
        <short>Writes an identifier to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAbstractObjectWriter.WriteInteger">
        <!-- Procedure -->
        <short>Writes an integer value to the stream</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAbstractObjectWriter.WriteMethodName">
        <!-- Procedure -->
        <short>Writes a methodname to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAbstractObjectWriter.WriteSet">
        <!-- Procedure -->
        <short>Writes a set value to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAbstractObjectWriter.WriteString">
        <!-- Procedure -->
        <short>Writes a string value to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TBinaryObjectWriter">
        <!-- Class -->
        <short>Driver class which stores component data in binary form.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TBinaryObjectWriter.Create">
        <!-- Constructor -->
        <short>Creates a new instance of a binary object writer.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TBinaryObjectWriter.Destroy">
        <!-- Destructor -->
        <short>Destroys an instance of the binary object writer.</short>
        <descr/>
        <seealso/>
      </element>
      <element link="TAbstractObjectWriter.BeginCollection" name="TBinaryObjectWriter.BeginCollection">
        <short>Start writing a collection.</short>
      </element>
      <element link="TAbstractObjectWriter.BeginComponent" name="TBinaryObjectWriter.BeginComponent">
        <!-- Procedure -->
        <short>Start writing a component</short>
      </element>
      <element link="TAbstractObjectWriter.BeginList" name="TBinaryObjectWriter.BeginList">
        <!-- Procedure -->
        <short>Start writing a list.</short>
      </element>
      <element link="TAbstractObjectWriter.EndList" name="TBinaryObjectWriter.EndList">
        <!-- Procedure -->
        <short>Mark the end of a list.</short>
      </element>
      <element link="TAbstractObjectWriter.BeginProperty" name="TBinaryObjectWriter.BeginProperty">
        <!-- Procedure -->
        <short>Start writing a property</short>
      </element>
      <element link="TAbstractObjectWriter.EndProperty" name="TBinaryObjectWriter.EndProperty">
        <!-- Procedure -->
        <short>Marks the end of writing of a property.</short>
      </element>
      <element link="TAbstractObjectWriter.WriteBinary" name="TBinaryObjectWriter.WriteBinary">
        <!-- Procedure -->
        <short>Writes binary data to the stream.</short>
      </element>
      <element link="TAbstractObjectWriter.WriteBoolean" name="TBinaryObjectWriter.WriteBoolean">
        <!-- Procedure -->
        <short>Writes a boolean value to the stream.</short>
      </element>
      <element link="TAbstractObjectWriter.WriteFloat" name="TBinaryObjectWriter.WriteFloat">
        <!-- Procedure -->
        <short>Writes a float value to the stream.</short>
      </element>
      <element link="TAbstractObjectWriter.WriteSingle" name="TBinaryObjectWriter.WriteSingle">
        <!-- Procedure -->
        <short>Writes a single-type real value to the stream.</short>
      </element>
      <element link="TAbstractObjectWriter.WriteDate" name="TBinaryObjectWriter.WriteDate">
        <!-- Procedure -->
        <short>Writes a date type to the stream.</short>
      </element>
      <element link="TAbstractObjectWriter.WriteIdent" name="TBinaryObjectWriter.WriteIdent">
        <!-- Procedure -->
        <short>Writes an identifier to the stream.</short>
      </element>
      <element link="TAbstractObjectWriter.WriteInteger" name="TBinaryObjectWriter.WriteInteger">
        <!-- Procedure -->
        <short>Writes an integer value to the stream.</short>
      </element>
      <element link="TAbstractObjectWriter.WriteMethodName" name="TBinaryObjectWriter.WriteMethodName">
        <!-- Procedure -->
        <short>Writes a methodname to the stream.</short>
      </element>
      <element link="TAbstractObjectWriter.WriteSet" name="TBinaryObjectWriter.WriteSet">
        <!-- Procedure -->
        <short>Writes a set value to the stream.</short>
      </element>
      <element link="TAbstractObjectWriter.WriteString" name="TBinaryObjectWriter.WriteString">
        <!-- Procedure -->
        <short>Writes a string value to the stream.</short>
      </element>
      <element name="TTextObjectWriter">
        <!-- Class -->
        <short>Driver class which stores component data in text format.</short>
        <descr>Not yet implemented.
</descr>
        <seealso/>
      </element>
      <element name="TFindAncestorEvent">
        <!-- Procedure type -->
        <short>Event that occurs w</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter">
        <!-- Class -->
        <short>Object to write component data to an arbitrary format.</short>
        <descr/>
        <seealso/>
      </element>
      <element link="TFiler.SetRoot" name="TWriter.SetRoot">
        <!-- Procedure -->
        <short>Sets the root component</short>
      </element>
      <element name="TWriter.WriteBinary">
        <!-- Procedure -->
        <short>Writes binary data to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.WriteProperty">
        <!-- Procedure -->
        <short>Writes one property to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.WriteProperties">
        <!-- Procedure -->
        <short>Writes the published properties to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.Create">
        <!-- Constructor -->
        <short>Creates a new Writer instance with a driver.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.Create">
        <!-- Constructor -->
        <short>Creates a new Writer with a stream and bufsize.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.Destroy">
        <!-- Destructor -->
        <short>Destroys the writer instance.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.DefineProperty">
        <!-- Procedure -->
        <short>Callback used when defining and streaming custom properties.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.DefineBinaryProperty">
        <!-- Procedure -->
        <short>Callback used when defining and streaming custom properties.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.WriteBoolean">
        <!-- Procedure -->
        <short>Write boolean value to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.WriteCollection">
        <!-- Procedure -->
        <short>Write a collection to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.WriteComponent">
        <!-- Procedure -->
        <short>Stream a component to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.WriteChar">
        <!-- Procedure -->
        <short>Write a character to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.WriteDescendent">
        <!-- Procedure -->
        <short>Write a descendent component to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.WriteFloat">
        <!-- Procedure -->
        <short>Write a float to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.WriteSingle">
        <!-- Procedure -->
        <short>Write a single-type real to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.WriteDate">
        <!-- Procedure -->
        <short>Write a date to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.WriteIdent">
        <!-- Procedure -->
        <short>Write an identifier to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.WriteInteger">
        <!-- Procedure -->
        <short>Write an integer to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.WriteListBegin">
        <!-- Procedure -->
        <short>Write a start-of-list marker to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.WriteListEnd">
        <!-- Procedure -->
        <short>Write an end-of-list marker to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.WriteRootComponent">
        <!-- Procedure -->
        <short>Write a root component to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.WriteString">
        <!-- Procedure -->
        <short>Write a string to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.RootAncestor">
        <!-- Property -->
        <short>Ancestor of root component.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.OnFindAncestor">
        <!-- Property -->
        <short>Event occurring when an ancestor component must be found.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWriter.Driver">
        <!-- Property -->
        <short>Driver used when writing to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TParser">
        <!-- Class -->
        <short>Class to parse the contents of a stream containing text data.</short>
        <descr>
          <p>This class breaks a stream of text data in tokens. Its primary use is to help reading the contents of a form file (usually a file with dfm, xfm or lfm extension), and for this reason it isn't suitable to be used as a general parser.</p>
          <p>The parser is always positioned on a certain token, whose type is stored in the <link id="TParser.Token">Token</link> property. Various methods are provided to obtain the token value in the desired format.</p>
          <p>To advance to the next token, invoke <link id="TParser.NextToken">NextToken</link> method.</p>
        </descr>
        <seealso>
          <link id="TParser.Token"/>
          <link id="TParser.NextToken"/>
        </seealso>
      </element>
      <element name="TParser.Create">
        <!-- Constructor -->
        <short>Creates a new parser instance.</short>
        <descr>
          <p>
            <var>Create</var> creates a new 
            <var>TParser</var> instance, using 
            <var>Stream</var> as the stream to read data from, and reads the first token from the stream.</p>
        </descr>
        <errors>
          <p>If an error occours while parsing the first token, an <link id="EParserError"/> exception is raised.</p>
        </errors>
        <seealso>
          <link id="TParser.NextToken"/>
          <link id="TParser.Token"/>
        </seealso>
      </element>
      <element name="TParser.Destroy">
        <!-- Destructor -->
        <short>Destroys the parser instance.</short>
        <descr/>
        <errors>None.
</errors>
        <seealso/>
      </element>
      <element name="TParser.CheckToken">
        <!-- Procedure -->
        <short>Checks whether the token if of the given type.</short>
        <descr/>
        <errors>
          <p>If current token isn't of type <var>T</var>, an <link id="EParserError"/> exception is raised.</p>
        </errors>
        <seealso>
          <link id="TParser.Token"/>
        </seealso>
      </element>
      <element name="TParser.CheckTokenSymbol">
        <!-- Procedure -->
        <short>Checks whether the token equals the given symbol</short>
        <descr>
          <p>
            <var>CheckTokenSymbol</var> performs a case-insensitive comparison of current token value with 
            <var>S</var>.</p>
          <p>Current token must be of type <link id="toSymbol"/>, otherwise an <link id="EParserError"/> exception is raised.</p>
        </descr>
        <errors>
          <p>If the comparison fails, or current token isn't a symbol, an <link id="EParserError"/> exception is raised.</p>
        </errors>
        <seealso>
          <link id="TParser.TokenSymbolIs"/>
          <link id="toSymbol"/>
        </seealso>
      </element>
      <element name="TParser.Error">
        <!-- Procedure -->
        <short>Raises an <link id="EParserError"/> exception with the given message</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TParser.ErrorFmt">
        <!-- Procedure -->
        <short>Raises an <link id="EParserError"/> exception and formats the message.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TParser.ErrorStr">
        <!-- Procedure -->
        <short>Raises an <link id="EParserError"/> exception with the given message</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TParser.HexToBinary">
        <!-- Procedure -->
        <short>Writes hexadecimal data to a stream.</short>
        <descr>
          <p>
            <var>HexToBinary</var> reads a sequence of hexadecimal characters from the input stream and converts them to a sequence of bytes which is written to 
            <var>Stream</var>. Each byte is represented by two contiguous hexadecimal characters.</p>
          <p>Whitespace is allowed between hexadecimal characters if it doesn't appear between two characters that form the same byte.</p>
          <p>
            <var>HexToBinary</var> stops when the first non-hexadecimal and non-whitespace character is found, or the end of the input stream is reached.</p>
          <remark>
            <p>This method begins reading after the current token: that is, current token, even if it's a valid hexadecimal value, isn't included.</p>
          </remark>
        </descr>
        <errors>
          <p>If a single hexadecimal character is found, an <link id="EParserError"/> exception is raised.</p>
        </errors>
        <seealso/>
      </element>
      <element name="TParser.NextToken">
        <!-- Function -->
        <short>Reads the next token and returns its type.</short>
        <descr>
          <p>
            <var>NextToken</var> parses the next token in the stream and returns its type. The type of the token can also be retrieved later reading 
            <link id="TParser.Token">Token</link> property.</p>
          <p>If the end of the stream is reached, <link id="toEOF"/> is returned.</p>
          <p>For details about token types, see <link id="TParser.Token"/>
          </p>
        </descr>
        <errors>
          <p>If an error occours while parsing the token, an <link id="EParserError"/> exception is raised.</p>
        </errors>
        <seealso>
          <link id="TParser.Token"/>
        </seealso>
      </element>
      <element name="TParser.SourcePos">
        <!-- Function -->
        <short>Returns the current position in the stream.</short>
        <descr>
          <remark>This is not the character position relative to the current source line, but the byte offset from the beginning of the stream.</remark>
        </descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TParser.SourceLine"/>
        </seealso>
      </element>
      <element name="TParser.TokenComponentIdent">
        <!-- Function -->
        <short>Returns the path of a subcomponent starting from the current token.</short>
        <descr>
          <p>If current token is <link id="toSymbol"/>, <var>TokenComponentIdent</var> tries to find subcomponent names separated by a dot (<var>.</var>). The returned string is the longest subcomponent path found. If there are no subcomponents, current symbol is returned.</p>
          <remark>
            <p>After this method has been called, subsequent calls to <link id="TParser.TokenString">TokenString</link> or <link id="TParser.TokenWideString">TokenWideString</link> return the same value returned by <var>TokenComponentIdent</var>.</p>
          </remark>
          <p>
            <b>Example</b>
          </p>
          <p>If source stream contains <var>a.b.c</var> and <var>TParser</var> is positioned on the first token (<var>a</var>), this method returns <var>a.b.c</var>.</p>
        </descr>
        <errors>
          <p>If <link id="TParser.Token">Token</link> isn't <link id="toSymbol"/>, or no valid symbol is found after a dot, an <link id="EParserError"/> exception is raised.</p>
        </errors>
        <seealso>
          <link id="TParser.NextToken"/>
          <link id="TParser.Token"/>
          <link id="TParser.TokenString"/>
          <link id="TParser.TokenWideString"/>
          <link id="toSymbol"/>
        </seealso>
      </element>
      <element name="TParser.TokenFloat">
        <!-- Function -->
        <short>Returns the current token as a float.</short>
        <descr>
          <p>If current token type is <link id="toFloat"/>, this method returns the token value as a float.</p>
          <p>To specify a negative number, no space must exist between unary minus and number.</p>
          <p>Floating point numbers can be postfixed with a character that specifies the floating point type. See <link id="TParser.FloatType">FloatType</link> for further information.</p>
          <remark>
            <p>In the input stream the decimal separator, if present, must be a dot (<var>.</var>).</p>
          </remark>
        </descr>
        <errors>
          <p>If <link id="TParser.Token">Token</link> isn't <link id="toFloat"/>, an <link id="EParserError"/> exception is raised.</p>
        </errors>
        <seealso>
          <link id="TParser.FloatType"/>
          <link id="TParser.NextToken"/>
          <link id="TParser.Token"/>
          <link id="toFloat"/>
        </seealso>
      </element>
      <element name="TParser.TokenInt">
        <!-- Function -->
        <short>Returns the current token as an integer.</short>
        <descr>
          <p>If current token type is <link id="toInteger"/>, this method returns the token value as an integer.</p>
          <p>In the input stream an integer can be an hexadecimal (prefixed by <var>'$'</var> character) or decimal number. Decimal numbers can be prefixed by an unary minus: if this is the case, no space must exist between minus and number.</p>
        </descr>
        <errors>
          <p>If <link id="TParser.Token">Token</link> isn't <link id="toInteger"/>, an <link id="sysutils.EConvertError">EConvertError</link> exception is raised.</p>
        </errors>
        <seealso>
          <link id="TParser.NextToken"/>
          <link id="TParser.Token"/>
          <link id="toInteger"/>
        </seealso>
      </element>
      <element name="TParser.TokenString">
        <!-- Function -->
        <short>Returns the current token as a string.</short>
        <descr>
          <p>If current token type is <link id="toString"/> or <link id="toWString"/>, this method returns the contents of the string. That is, enclosing quotes are removed, embedded quotes are unescaped and control strings are converted to the appropriate sequence of characters.</p>
          <p>If current token type isn't a string, a string containing the token representation in the input stream is returned, without any conversion: hexadecimal integers are returned with the leading <var>$</var>, and floating point suffixes like <var>s</var>, <var>c</var> or <var>d</var> are kept. For tokens whose type isn't a special type, return value of <var>TokenString</var> equals <link id="TParser.Token">Token</link>.</p>
          <remark>
            <p>If <link id="TParser.Token">Token</link> is <link id="toWString"/>, <link id="TParser.TokenWideString">TokenWideString</link> should be used instead.</p>
          </remark>
        </descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TParser.NextToken"/>
          <link id="TParser.TokenWideString"/>
          <link id="TParser.Token"/>
          <link id="toString"/>
          <link id="toWString"/>
        </seealso>
      </element>
      <element name="TParser.TokenWideString">
        <short>Returns the current token as a widestring</short>
        <descr>
          <p>If current token type is <link id="toWString"/>, this method returns the contents of the string. That is, enclosing quotes are removed, embedded quotes are unescaped and control strings are converted to the appropriate sequence of characters.</p>
          <p>If current token isn't a widestring, <var>TokenWideString</var> behaviour is the same as <link id="TParser.TokenString">TokenString</link>.</p>
        </descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TParser.NextToken"/>
          <link id="TParser.TokenString">TokenString</link>
          <link id="TParser.Token"/>
          <link id="toWString"/>
        </seealso>
      </element>
      <element name="TParser.TokenSymbolIs">
        <!-- Function -->
        <short>Returns <var>True</var> if the token equals the given symbol.</short>
        <descr>
          <p>
            <var>TokenSymbolIs</var> performs a case-insensitive comparison of current token value with 
            <var>S</var>.</p>
          <p>If current token isn't of type <link id="toSymbol"/>, or comparison fails, <var>False</var> is returned.</p>
        </descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TParser.CheckTokenSymbol"/>
          <link id="TParser.Token"/>
        </seealso>
      </element>
      <element name="TParser.FloatType">
        <!-- Property -->
        <short>The type of a float token.</short>
        <descr>
          <p>Floating point numbers can be postfixed with a character specifying the type of floating point value. When specified, this property holds the character postfixed to the number.</p>
          <p>It can be one of the following values:</p>
          <table>
            <tr>
              <td>
                <var>s</var> or 
                <var>S</var>
              </td>
              <td>Value is a single.</td>
            </tr>
            <tr>
              <td>
                <var>c</var> or 
                <var>C</var>
              </td>
              <td>Value is a currency.</td>
            </tr>
            <tr>
              <td>
                <var>d</var> or 
                <var>D</var>
              </td>
              <td>Value is a date.</td>
            </tr>
          </table>
          <p>If <link id="TParser.Token">Token</link> isn't <link id="toFloat"/> or one of the above characters wasn't specified, <var>FloatType</var> is the null character (zero).</p>
        </descr>
        <seealso>
          <link id="TParser.NextToken"/>
          <link id="TParser.Token"/>
          <link id="TParser.TokenFloat"/>
          <link id="toFloat"/>
        </seealso>
      </element>
      <element name="TParser.SourceLine">
        <!-- Property -->
        <short>Current source line number.</short>
        <descr/>
        <seealso>
          <link id="TParser.SourcePos"/>
        </seealso>
      </element>
      <element name="TParser.Token">
        <!-- Property -->
        <short>The type of the current token.</short>
        <descr>
          <p>This property holds the type of the current token. When <var>Token</var> isn't one of the special token types (whose value can be retrieved with specific methods) it is the character representing the current token.</p>
          <p>Special token types:</p>
          <table>
            <tr>
              <td>
                <link id="toEOF"/>
              </td>
              <td>
                <printshort id="toEOF"/>
              </td>
            </tr>
            <tr>
              <td>
                <link id="toSymbol"/>
              </td>
              <td>
                <printshort id="toSymbol"/>
              </td>
            </tr>
            <tr>
              <td>
                <link id="toString"/>
              </td>
              <td>
                <printshort id="toString"/>
              </td>
            </tr>
            <tr>
              <td>
                <link id="toInteger"/>
              </td>
              <td>
                <printshort id="toInteger"/>
              </td>
            </tr>
            <tr>
              <td>
                <link id="toFloat"/>
              </td>
              <td>
                <printshort id="toFloat"/>
              </td>
            </tr>
            <tr>
              <td>
                <link id="toWString"/>
              </td>
              <td>
                <printshort id="toWString"/>
              </td>
            </tr>
          </table>
          <p>To advance to the next token, use <link id="TParser.NextToken">NextToken</link> method.</p>
        </descr>
        <seealso>
          <link id="TParser.CheckToken"/>
          <link id="TParser.NextToken"/>
          <link id="TParser.TokenComponentIdent"/>
          <link id="TParser.TokenFloat"/>
          <link id="TParser.TokenInt"/>
          <link id="TParser.TokenString"/>
          <link id="TParser.TokenWideString"/>
        </seealso>
      </element>
      <element name="EThread">
        <!-- Class -->
        <short>Thread error exception.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThreadMethod">
        <!-- Procedure type -->
        <short>Procedure variable used when synchronizing threads.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThreadPriority">
        <!-- Enumeration type -->
        <short>Enumeration specifying the priority at which a thread runs.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThreadPriority.tpIdle">
        <!-- Enumeration value -->
        <short>Thread only runs when other processes are idle.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThreadPriority.tpLowest">
        <!-- Enumeration value -->
        <short>Thread runs at the lowest priority.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThreadPriority.tpLower">
        <!-- Enumeration value -->
        <short>Thread runs at a lower priority.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThreadPriority.tpNormal">
        <!-- Enumeration value -->
        <short>Thread runs at normal process priority.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThreadPriority.tpHigher">
        <!-- Enumeration value -->
        <short>Thread runs at high priority</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThreadPriority.tpHighest">
        <!-- Enumeration value -->
        <short>Thread runs at highest possible priority.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThreadPriority.tpTimeCritical">
        <!-- Enumeration value -->
        <short>Thread runs at realtime priority.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread">
        <!-- Class -->
        <short>Abstract Thread class.</short>
        <descr>The <var>TThread</var> class encapsulates the native thread support of the
operating system. To create a thread, declare a descendent of the
<var>TThread</var> object and override the <link id="TThread.Execute">Execute</link> method. In this method, the tthread's
code should be executed. To run a thread, create an instance of the tthread
descendent, and call it's execute method.
</descr>
        <seealso>
          <link id="EThread"/>
          <link id="TThread.Execute"/>
        </seealso>
      </element>
      <element name="TThread.DoTerminate">
        <!-- Procedure -->
        <short>Terminates the thread.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.Execute">
        <!-- Procedure -->
        <short>Execute method. Should be overridden in a descendent thread.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.Synchronize">
        <!-- Procedure -->
        <short>Synchronizes the thread by executing the method in the main thread.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.ReturnValue">
        <!-- Property -->
        <short>Return value of the thread when it stops executing.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.Terminated">
        <!-- Property -->
        <short>Indicates whether the <link id="TThread.Terminate">Terminate</link>method was called by the user.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.FStackPointer">
        <!-- Variable -->
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.FStackSize">
        <!-- Variable -->
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.FCallExitProcess">
        <!-- Variable -->
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.Create">
        <!-- Constructor -->
        <short>Creates a new thread.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.Destroy">
        <!-- Destructor -->
        <short>Destroys the thread object.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.Resume">
        <!-- Procedure -->
        <short>Resumes the thread's execution.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.Suspend">
        <!-- Procedure -->
        <short>Suspends the thread's execution.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.Terminate">
        <!-- Procedure -->
        <short>Signals the thread it should terminate.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.WaitFor">
        <!-- Function -->
        <short>Waits for the thread to terminate and returns the exit status.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.FreeOnTerminate">
        <!-- Property -->
        <short>Indicates whether the thread should free itself when it stops executing.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.Handle">
        <!-- Property -->
        <short>Returns the thread handle.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.Priority">
        <!-- Property -->
        <short>Returns the thread priority.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.Suspended">
        <!-- Property -->
        <short>Indicates whether the thread is suspended.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.ThreadID">
        <!-- Property -->
        <short>Returns the thread ID.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TThread.OnTerminate">
        <!-- Property -->
        <short>Event called when the thread terminates.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TOperation">
        <!-- Enumeration type -->
        <short>Operation of which a component is notified.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TOperation.opInsert">
        <!-- Enumeration value -->
        <short>A new component is being inserted in the child component list.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TOperation.opRemove">
        <!-- Enumeration value -->
        <short>A component is being removed from the child component list.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TComponentState">
        <!-- Set type -->
        <short>Indicates the state of the component during the streaming process.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TComponentState.csLoading">
        <!-- Enumeration value -->
        <short>The component is being loaded from the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TComponentState.csReading">
        <!-- Enumeration value -->
        <short>Properties are being read from the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TComponentState.csWriting">
        <!-- Enumeration value -->
        <short>Properties are being written to the stream.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TComponentState.csDestroying">
        <!-- Enumeration value -->
        <short>The component is being destroyed.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TComponentState.csDesigning">
        <!-- Enumeration value -->
        <short>The component is being designed in an IDE.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TComponentState.csAncestor">
        <!-- Enumeration value -->
        <short>The component is being streamed as part of a frame (?) </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TComponentState.csUpdating">
        <!-- Enumeration value -->
        <short>The component is being updated.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TComponentState.csFixups">
        <!-- Enumeration value -->
        <short>The component's references to other components are being fixed.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TComponentState.csFreeNotification">
        <!-- Enumeration value -->
        <short>Indicates whether the component has freenotifications</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TComponentState.csInline">
        <!-- Enumeration value -->
        <short>Component is part of a frame (?).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TComponentState.csDesignInstance">
        <!-- Enumeration value -->
        <short>??</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TComponentStyle">
        <!-- Set type -->
        <short>Describes the style of the component.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TComponentStyle.csInheritable">
        <!-- Enumeration value -->
        <short>The component can be on inherited forms.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TComponentStyle.csCheckPropAvail">
        <!-- Enumeration value -->
        <short>??</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TGetChildProc">
        <!-- Procedure type -->
        <short>Callback used when obtaining child components.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TComponent">
        <!-- Class -->
        <short>Base class for all components that need owner-owned functionality.</short>
        <descr>
          <p>
            <var>TComponent</var> is the base class for any set of classes that needs
owner-owned functionality, and which needs support for property streaming.
All classes that should be handled by an IDE (Integrated Development 
Environment) must descend from 
            <var>TComponent</var>, as it includes all
support for streaming all its published properties.
</p>
          <p>Components can 'own' other components. <var>TComponent</var> introduces
methods for enumerating the child components. It also allows to name the
owned components with a unique name. Furthermore, functionality for 
sending notifications when a component is removed from the list or
removed from memory alltogether is also introduced in <var>TComponent</var>
          </p>
          <p>
            <var>TComponent</var> introduces a form of automatic memory management: When
a component is destroyed, all its child components will be destroyed first.
</p>
        </descr>
      </element>
      <element name="TComponent.FComponentStyle">
        <!-- Variable -->
        <short>Contains the component's style.</short>
        <descr>
          <var>FComponentStyle</var> is the location where the 
          <link id="TComponent.ComponentStyle">ComponentStyle</link> property is read from.
</descr>
        <seealso/>
        <link id="TComponent.ComponentStyle">ComponentStyle</link>
      </element>
      <element name="TComponent.ChangeName">
        <!-- Procedure -->
        <short>Actually sets the component name.</short>
        <descr>
          <p>
            <var>ChangeName</var> is called by the 
            <link id="TComponent.SetName">SetName</link> procedure when the component name is
set and the name has been verified. It actually sets  the name of the 
component to 
            <var>NewName</var>, and can be used to bypass the name checks which are done when the

            <link id="TComponent.Name">Name</link> property is set.
</p>
          <p>Application programmers should never use <var>SetName</var> directly.
</p>
        </descr>
        <seealso>
          <link id="TComponent.SetName">SetName</link>
          <link id="TComponent.Name">Name</link>
        </seealso>
      </element>
      <element name="TComponent.DefineProperties">
        <!-- Procedure -->
        <short>Defines fake top,left properties for handling in the IDE.</short>
        <descr>
          <var>DefineProperties</var> overrides the standard 
          <link id="TPersistent.DefineProperties"/> to store the top/left properties used to
display an icon for a non-visual component in an IDE.
</descr>
        <seealso>
          <link id="TPersistent.DefineProperties"/>
        </seealso>
      </element>
      <element name="TComponent.GetChildren">
        <!-- Procedure -->
        <short>Must be overridden by descendents to return all child components that must be streamed.</short>
        <descr>
          <p>
            <var>GetChildren</var> is called by the streaming system to determine which
child components should be streamed as well when the component is being 
streamed. 
By default, no child components are streamed, i.e. the 
            <var>TComponent</var>
implementation is empty.
</p>
          <p>
            <var>TComponent</var> descendents should override this method. For each
child that needs to be streamed, 
            <var>Proc</var> should be called with as
an argument the child component that must be streamed. The 
            <var>Root</var>
argument contains the root component relative to which all streaming is
done.
</p>
        </descr>
        <seealso>
          <link id="TComponent.WriteState"/>
        </seealso>
      </element>
      <element name="TComponent.GetChildOwner">
        <!-- Function -->
        <short>Returns the owner of any children.</short>
        <descr>
          <p>
            <var>GetChildOwner</var> returns the owner of the children that are read from the stream.
If the method returns 
            <var>Nil</var> (the default) this means that streamed
child components are owned by the root component of the streaming process
(usually a Form or Datamodule)
</p>
          <p>Application programmers should not call <var>GetChildOwner</var> directly,
it is called by the streaming system when needed.
</p>
        </descr>
        <seealso>
          <link id="TComponent.WriteState"/>
          <link id="TComponent.ReadState"/>
          <link id="TComponent.Owner"/>
          <link id="TComponent.GetChildParent"/>
        </seealso>
      </element>
      <element name="TComponent.GetChildParent">
        <!-- Function -->
        <short>Returns the parent of any children.</short>
        <descr>
          <p>
            <var>GetChildParent</var> returns the parent component of the child
components being streamed. The parent property is a visual property, which
is not always meaningful. If there is no parent component, the owner 
of child components that are streamed is returned. If 
            <var>Nil</var> is
returned, then the root component of the streaming operation is assumed.
The 
            <var>TComponent</var> implementation of this method returns

            <var>Self</var>. 
</p>
          <p>Application programmers should not call this method, it is called
automatically by the streaming mechanism.
</p>
        </descr>
        <seealso>
          <link id="TComponent.GetChildOwner"/>
        </seealso>
      </element>
      <element name="TComponent.GetNamePath">
        <!-- Function -->
        <short>Returns the name path of this component.</short>
        <descr>
          <p>
            <var>GetNamePath</var> returns the name of the component as it will be 
shown in the object inspector. 
</p>
          <p>
            <var>TComponent</var> overrides 
            <var>GetNamePath</var> so it returns the

            <link id="TComponent.Name">Name</link> property of the component.
</p>
        </descr>
        <seealso>
          <link id="TComponent.Name">Name</link>
          <link id="TPersistent.GetNamePath"/>
        </seealso>
      </element>
      <element name="TComponent.GetOwner">
        <!-- Function -->
        <short>Returns the owner of this component.</short>
        <descr>
          <var>GetOwner</var> returns the owner of this component as indicated by the 

          <link id="TComponent.Owner">Owner</link> property. The

          <var>GetOwner</var> call is introduced in 
          <link id="TPersistent"/>
and is used by the streaming system to determine the 'owner' of a component.
</descr>
        <seealso>
          <link id="TPersistent.GetOwner"/>
          <link id="TComponent.Owner"/>
        </seealso>
      </element>
      <element name="TComponent.Loaded">
        <!-- Procedure -->
        <short>Called when the component has finished loading.</short>
        <descr>
          <p>
            <var>Loaded</var> is called by the streaming system when a root
component was completely read from a stream and all properties and 
references to other objects have been resolved by the streaming 
system. Descendents of 
            <var>TComponent</var> should override this method to
do some additional processing of properties after all published 
properties have been set from values obtained from the stream.
</p>
          <p>Application programmers should never call <var>Loaded</var> directly, this
is done automatically by the streaming system.
</p>
        </descr>
        <seealso>
          <link id="TComponent.ReadState"/>
          <link id="TComponent.ComponentState"/>
        </seealso>
      </element>
      <element name="TComponent.Notification">
        <!-- Procedure -->
        <short>Called by components that are freed and which received a FreeNotification.</short>
        <descr>
          <p>
            <var>Notification</var> is called whenever a child component is destroyed,
inserted or removed from the list of owned component. Components that
were requested to send a notification when they are freed 
((with 
            <link id="TComponent.FreeNotification">FreeNotification</link>)
will also call 
            <var>Notification</var> when they are freed.
</p>
          <p>The <var>AComponent</var> parameter specifies which component sends the
notification, and <var>Operation</var> specifies whether the component is
being inserted into or removed from the child component list, or whether it
is being destroyed.
</p>
          <p>Descendents of <var>TComponent</var> can use <link id="TComponent.FreeNotification">FreeNotification</link> to request
notification of the destruction of another object. By overriding the
<var>Notification</var> method, they can do special processing (typically,
set a reference to this component to <var>Nil</var>) 
when this component is destroyed. The <var>Notification</var> method is
called quite often in the streaming process, so speed should be a
consideration when overriding this method.
</p>
        </descr>
        <seealso>
          <link id="TOperation"/>
          <link id="TComponent.FreeNotification"/>
        </seealso>
      </element>
      <element name="TComponent.ReadState">
        <!-- Procedure -->
        <short>Read the component's state from a stream.</short>
        <descr>
          <p>
            <var>ReadState</var> reads the component's state from a stream through the
reader object 
            <var>reader</var>. Values for all published properties of 
the component can be read from the stream. Normally there is no need to 
call 
            <var>ReadState</var> directly. The streaming system calls 

            <var>ReadState</var> itself. 
</p>
          <p>The <link id="TComponent"/> implementation of <var>ReadState</var> simply
calls <link id="TReader.ReadData"/> Descendent classes can, however, 
override  <var>ReadState</var>to provide additional processing of stream 
data.
</p>
        </descr>
        <seealso>
          <link id="TComponent.WriteState">WriteState</link>
          <link id="TStream.ReadComponent"/>
          <link id="TReader.ReadData"/>
        </seealso>
      </element>
      <element name="TComponent.SetAncestor">
        <!-- Procedure -->
        <short>Sets the <var>csAncestor</var> state of the component.</short>
        <descr>
          <p>
            <var>SetAncestor</var> includes or excludes the 
            <var>csAncestor</var> flag
in the 
            <link id="TComponent.ComponentState">ComponentState</link> set property, 
depending on the boolean 
            <var>Value</var>. The flag is set recursively for
all owned components as well.
</p>
          <p>This is normally only done during the streaming system, and should not be called 
directly by an application programmer.
</p>
        </descr>
        <seealso>
          <link id="TComponent.ComponentState">ComponentState</link>
        </seealso>
      </element>
      <element name="TComponent.SetDesigning">
        <!-- Procedure -->
        <short>Sets the <var>csDesigning</var> state of the component.</short>
        <descr>
          <p>
            <var>SetDesigning</var> includes or excludes the 
            <var>csDesigning</var> flag
in the 
            <link id="TComponent.ComponentState">ComponentState</link> set property, 
depending on the boolean 
            <var>Value</var>. The flag is set recursively for
all owned components as well.
</p>
          <p>This is normally only done during the streaming system, and should not be called 
directly by an application programmer.
</p>
        </descr>
        <seealso/>
      </element>
      <element name="TComponent.SetName">
        <!-- Procedure -->
        <short>Write handler for <link id="TComponent.Name">Name</link> property.</short>
        <descr>
          <var>SetName</var> is the write handler for the 
          <link id="TComponent.Name">Name</link> property. It checks whether the desired
name is valid (i.e is a valid identifier) and is unique among the children
of the owner component. If either conditions is not satisfied, an exception
is raised.
</descr>
        <seealso>
          <link id="TComponent.Name">Name</link>
          <link id="TComponent.ValidateRename">ValidateRename</link>
        </seealso>
      </element>
      <element name="TComponent.SetChildOrder">
        <!-- Procedure -->
        <short>Determines the order in which children are streamed/created.</short>
        <descr>This method does nothing. It can be used to change the order in which child
components are streamed and created. This can be used by descendent classes
to optimize or correct the order in which child components are streamed.
</descr>
        <seealso>
          <link id="TComponent.ReadState"/>
        </seealso>
      </element>
      <element name="TComponent.SetParentComponent">
        <!-- Procedure -->
        <short>Set the parent component.</short>
        <descr>
          <var>SetParentComponent</var> does nothing, but is called by the streaming
system to set the parent component of the current component. This method
can be overridden by descendent components to set the parent component of
the current component.
</descr>
        <seealso>
          <link id="TComponent.Owner">Owner</link>
        </seealso>
      </element>
      <element name="TComponent.Updating">
        <!-- Procedure -->
        <short>Sets the state to <var>csUpdating</var>
        </short>
        <descr>
          <p>
            <var>Updating</var> includes 
            <var>csUpdating</var> in the 
            <link id="TComponent.ComponentState">ComponentState</link> property of the
component.
</p>
          <p>Normally, an application programmer should not call this method directly, it
is called automatically by the streaming system.
</p>
        </descr>
        <seealso>
          <link id="TComponent.Updated">Updated</link>
          <link id="TComponent.ComponentState">ComponentState</link>
        </seealso>
      </element>
      <element name="TComponent.Updated">
        <!-- Procedure -->
        <short>Ends the <var>csUpdating</var> state.</short>
        <descr>
          <p>
            <var>Updated</var> excludes 
            <var>csUpdating</var> from the 
            <link id="TComponent.ComponentState">ComponentState</link> property of the
component.
</p>
          <p>Normally, an application programmer should not call this method directly, it
is called automatically by the streaming system.
</p>
        </descr>
        <seealso>
          <link id="TComponent.Updating">Updating</link>
          <link id="TComponent.ComponentState">ComponentState</link>
        </seealso>
      </element>
      <element name="TComponent.UpdateRegistry">
        <!-- Procedure -->
        <short>For compatibilty only.</short>
        <descr>This method does nothing, and is provided for compatibility only.
</descr>
        <seealso/>
      </element>
      <element name="TComponent.ValidateRename">
        <!-- Procedure -->
        <short>Called when a name change must be validated</short>
        <descr>
          <var>ValidateRename</var> checks whether 
          <var>NewName</var> is a valid 
replacement for 
          <var>CurName</var> for component 
          <var>AComponent</var>.
Two owned components of a component can not have the same name. 
If a child component with the same name is found, then an exception 
is raised.
</descr>
        <seealso>
          <link id="TComponent.SetName">SetName</link>
          <link id="TComponent.Name">Name</link>
        </seealso>
      </element>
      <element name="TComponent.ValidateContainer">
        <!-- Procedure -->
        <short>??</short>
        <descr>
          <var>ValidateContainer</var> is provided for compatibility only. 
It doesn't do anything in Free Pascal.
</descr>
      </element>
      <element name="TComponent.ValidateInsert">
        <!-- Procedure -->
        <short>Called when an insert must be validated.</short>
        <descr>
          <p>
            <var>ValidateInsert</var> should be implemented by descendent components to
see whether the 
            <var>AComponent</var> component may be inserted in the list
of owned components. 
</p>
          <p>This procedure does nothing in the <var>TComponent</var> implementation, it
should be overridden by descendant components.
</p>
        </descr>
        <seealso>
          <link id="TComponent.Insert">Insert</link>
        </seealso>
      </element>
      <element name="TComponent.WriteState">
        <!-- Procedure -->
        <short>Writes the component to a stream.</short>
        <descr>
          <p>
            <var>WriteState</var> writes the component's current state to a stream 
through the 
            <link id="TWriter">writer</link> object 
            <var>writer</var>. 
Values for all published properties of the component can be written to 
the stream. Normally there is no need to call 
            <var>WriteState</var> directly. 
The streaming system calls  
            <var>WriteState</var> itself. 
</p>
          <p>The <link id="TComponent"/> implementation of <var>WriteState</var> simply
calls <link id="TWriter.WriteData"/>. Descendent classes can, however, 
override  <var>WriteState</var>to provide additional processing of stream 
data.
</p>
        </descr>
        <seealso>
          <link id="TComponent.ReadState">ReadState</link>
          <link id="TStream.WriteComponent"/>
          <link id="TWriter.WriteData"/>
        </seealso>
      </element>
      <element name="TComponent.Create">
        <!-- Constructor -->
        <short>Creates a new instance of the component.</short>
        <descr>
          <var>Create</var> creates a new instance of a 
          <var>TComponent</var> class.
If 
          <var>AOwner</var> is not 
          <var>Nil</var>, the new component attempts to 
insert itself in the list of owned components of the owner.
</descr>
        <seealso>
          <link id="TComponent.Insert">Insert</link>
          <link id="TComponent.Owner">Owner</link>
        </seealso>
      </element>
      <element name="TComponent.SetSubComponent">
        <short>Sets the <var>csSubComponent</var> style.</short>
        <descr>
          <var>SetSubComponent</var> includes 
          <var>csSubComponent</var> in the

          <link id="TComponent.ComponentStyle">ComponentStyle</link> property
if 
          <var>ASubComponent</var> is 
          <var>True</var>, and 
excludes it again if 
          <var>ASubComponent</var> is 
          <var>False</var>.
</descr>
        <seealso>
          <link id="TComponent.ComponentStyle"/>
        </seealso>
      </element>
      <element name="TComponent.Destroy">
        <!-- Destructor -->
        <short>Destroys the instance of the component.</short>
        <descr>
          <var>Destroy</var> sends a 
          <var>opRemove</var> notification to all components 
in the free-notification list. After that, all owned components are
destroyed by calling 
          <link id="TComponent.DestroyComponents">DestroyComponents</link> 
(and hence removed from the list of owned components). When this
is done, the component removes itself from its owner's child component list.
After that, the parent's destroy method is called.
</descr>
        <seealso>
          <link id="TComponent.Notification">Notification</link>
          <link id="TComponent.Owner">Owner</link>
          <link id="TComponent.DestroyComponents">DestroyComponents</link>
          <link id="TComponent.Components">Components</link>
        </seealso>
      </element>
      <element name="TComponent.DestroyComponents">
        <!-- Procedure -->
        <short>Destroy child components.</short>
        <descr>
          <p>
            <var>DestroyComponents</var> calls the destructor of all owned components,
till no more components are left in the 
            <link id="TComponent.Components">Components</link> array.
</p>
          <p>Calling the destructor of an owned component has as the effect that the
component will remove itself from the list of owned components, if nothing
has disrupted the sequence of destructors.
</p>
        </descr>
        <errors>If an overridden 'destroy' method does not call it's intherited 
destructor or raises an exception, it's <link id="TComponent.Destroy"/> 
destructor will not be called, which may result in an endless loop.
</errors>
        <seealso>
          <link id="TComponent.Destroy">Destroy</link>
          <link id="TComponent.Components">Components</link>
        </seealso>
      </element>
      <element name="TComponent.Destroying">
        <!-- Procedure -->
        <short>Called when the component is being destroyed</short>
        <descr>
          <p>
            <var>Destroying</var> sets the 
            <var>csDestroying</var> flag in the
component's 
            <link id="TComponent.State">state</link> property, and does the
same for all owned components.
</p>
          <p>It is not necessary to call <var>Destroying</var> directly, the destructor <link id="TComponent.Destroy">Destroy</link> does this automatically.
</p>
        </descr>
        <seealso>
          <link id="TComponent.State">State</link>
          <link id="TComponent.Destroy">Destroy</link>
        </seealso>
      </element>
      <element name="TComponent.FindComponent">
        <!-- Function -->
        <short>Finds and returns the named component in the owned components.</short>
        <descr>
          <var>FindComponent</var> searches the component with name 
          <var>AName</var>
in the list of owned components. If 
          <var>AName</var> is empty, then

          <var>Nil</var> is returned.
</descr>
        <seealso>
          <link id="TComponent.Components">Components</link>
          <link id="TComponent.Name">Name</link>
        </seealso>
      </element>
      <element name="TComponent.FreeNotification">
        <!-- Procedure -->
        <short>Ask the component to notify called when it is being destroyed.</short>
        <descr>
          <var>FreeNotification</var> inserts 
          <var>AComponent</var> in the
freenotification list. When the component is destroyed, the 
          <link id="TComponent.Notification">Notification</link> method is called for all
components in the freenotification list.
</descr>
        <seealso>
          <link id="TComponent.Components">Components</link>
          <link id="TComponent.Notification">Notification</link>
        </seealso>
      </element>
      <element name="TComponent.FreeOnRelease">
        <!-- Procedure -->
        <short>Part of the <var>IVCLComObject</var> interface.</short>
        <descr>Provided for Delphi compatibility, but is not yet impltmentedd.
</descr>
      </element>
      <element name="TComponent.GetParentComponent">
        <!-- Function -->
        <short>Returns the parent component.</short>
        <descr>
          <var>GetParentComponent</var> can be implemented to return the parent
component of this component. The implementation of this method in

          <var>TComponent</var> always returns 
          <var>Nil</var>. Descendent classes must
override this method to return the visual parent of the component.
</descr>
        <seealso>
          <link id="TComponent.HasParent">HasParent</link>
          <link id="TComponent.Owner">Owner</link>
        </seealso>
      </element>
      <element name="TComponent.HasParent">
        <!-- Function -->
        <short>Does the component have a parent ?</short>
        <descr>
          <var>HasParent</var> can be implemented to return whether the parent of the
component exists. The implementation of this method in TComponent always
returns 
          <var>False</var>, and should be overridden by descendent classes to
return 
          <var>True</var> when a parent is available. If 
          <var>HasParent</var>
returns 
          <var>True</var>, then 
          <link id="TComponent.GetParentComponent">GetParentComponent</link> will return the
parent component.
</descr>
        <seealso>
          <link id="TComponent.HasParent">HasParent</link>
          <link id="TComponent.Owner">Owner</link>
        </seealso>
      </element>
      <element name="TComponent.InsertComponent">
        <!-- Procedure -->
        <short>Insert the given component in the list of owned components.</short>
        <descr>
          <var>InsertComponent</var> attempts to insert 
          <var>AComponent</var> in the
list with owned components. It first calls 
          <link id="TComponent">ValidateComponent</link> to see whether the component can be
inserted. It then checks whether there are no name conflicts by calling

          <link id="TComponent.ValidateRename">ValidateRename</link>. If neither of
these checks have raised an exception the component is inserted, and
notified of the insert.
</descr>
        <seealso>
          <link id="TComponent.RemoveComponent">RemoveComponent</link>
          <link id="TComponent.Insert">Insert</link>
          <link id="TComponent.ValidateContainer">ValidateContainer</link>
          <link id="TComponent.ValidateRename">ValidateRename</link>
          <link id="TComponent.Notification">Notification</link>
        </seealso>
      </element>
      <element name="TComponent.RemoveComponent">
        <!-- Procedure -->
        <short>Remove the given component from the list of owned components.</short>
        <descr>
          <var>RemoveComponent</var> will send an 
          <var>opRemove</var> notification to

          <var>AComponent</var> and will then proceed to remove 
          <var>AComponent</var> 
from the list of owned components. 
</descr>
        <seealso>
          <link id="TComponent.InsertComponent">InsertComponent</link>
          <link id="TComponent.Remove">Remove</link>
          <link id="TComponent.ValidateRename">ValidateRename</link>
          <link id="TComponent.Notification">Notification</link>
        </seealso>
      </element>
      <element name="TComponent.SafeCallException">
        <!-- Function -->
        <short>Part of the <var>IVCLComObject</var> Interface.</short>
        <descr>Provided for Delphi compatibility, but not implemented.
</descr>
        <seealso/>
      </element>
      <element name="TComponent.Components">
        <!-- Property -->
        <short>Indexed list (zero-based) of all owned components.</short>
        <descr>
          <var>Components</var> provides indexed access to the list of owned
components. 
          <var>Index</var> can range from 0 to 
          <link id="TComponent.ComponentCount">ComponentCount-1</link>.
</descr>
        <seealso>
          <link id="TComponent.ComponentCount">ComponentCount</link>
          <link id="TComponent.Owner">Owner</link>
        </seealso>
      </element>
      <element name="TComponent.ComponentCount">
        <!-- Property -->
        <short>Count of owned components</short>
        <descr>
          <var>ComponentCount</var> returns the number of components that the current
component owns. It can be used to determine the valid index range in the

          <link id="TComponent.Components">Component</link> array.
</descr>
        <seealso>
          <link id="TComponent.Components">Components</link>
          <link id="TComponent.Owner">Owner</link>
        </seealso>
      </element>
      <element name="TComponent.ComponentIndex">
        <!-- Property -->
        <short>Index of component in it's owner's list.</short>
        <descr>
          <var>ComponentIndex</var> is the index of the current component in its
owner's list of components. If the component has no owner, the value of this
property is -1.
</descr>
        <seealso>
          <link id="TComponent.Components">Components</link>
          <link id="TComponent.ComponentCount">ComponentCount</link>
          <link id="TComponent.Owner">Owner</link>
        </seealso>
      </element>
      <element name="TComponent.ComponentState">
        <!-- Property -->
        <short>Current component's state.</short>
        <descr>
          <p>
            <var>ComponentState</var> indicates the current state of the component. It
is a set of flags which indicate the various stages in the lifetime of a
component. The following values can occur in this set:
</p>
          <table>
            <caption>Component states</caption>
            <th>
              <td>Flag</td>
              <td>Meaning</td>
            </th>
            <tr>
              <td>csLoading</td>
              <td>The component is being loaded from stream</td>
            </tr>
            <tr>
              <td>csReading</td>
              <td>Component properties are being read from stream.</td>
            </tr>
            <tr>
              <td>csWriting</td>
              <td>Component properties are weing written to stream.</td>
            </tr>
            <tr>
              <td>csDestroying</td>
              <td>The component or one of it's owners is being destoyed.</td>
            </tr>
            <tr>
              <td>csAncestor</td>
              <td>The component is being streamed as part of a frame </td>
            </tr>
            <tr>
              <td>csUpdating</td>
              <td>The component is being updated</td>
            </tr>
            <tr>
              <td>csFixups</td>
              <td>References to other components are being resolved</td>
            </tr>
            <tr>
              <td>csFreeNotification</td>
              <td>The component has freenotifications.</td>
            </tr>
            <tr>
              <td>csInline</td>
              <td>The component is being loaded as part of a frame</td>
            </tr>
            <tr>
              <td>csDesignInstance</td>
              <td>? not used.</td>
            </tr>
          </table>
          <p>The component state is set by various actions such as reading it from stream,
destroying it etc.
</p>
        </descr>
        <seealso>
          <link id="TComponent.SetAncestor">SetAncestor</link>
          <link id="TComponent.SetDesigning">SetDesigning</link>
          <link id="TComponent.SetInline">SetInline</link>
          <link id="TComponent.SetDesignInstance">SetDesignInstance</link>
          <link id="TComponent.Updating">Updating</link>
          <link id="TComponent.Updated">Updated</link>
          <link id="TComponent.Loaded">Loaded</link>
        </seealso>
      </element>
      <element name="TComponent.ComponentStyle">
        <!-- Property -->
        <short>Current component's style.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TComponent.DesignInfo">
        <!-- Property -->
        <short>Information for IDE designer.</short>
        <descr>
          <var>DesignInformation</var> can be used by an IDE to store design
information in the component. It should not be used by an application
programmer. 
</descr>
        <seealso>
          <link id="TComponent.Tag">Tag</link>
        </seealso>
      </element>
      <element name="TComponent.Owner">
        <!-- Property -->
        <short>Owner of this component.</short>
        <descr>
          <var>Owner</var> returns the owner of this component. The owner cannot be
set except by explicitly inserting the component in another component's
owned components list using that component's 
          <link id="TComponent.InsertComponent">InsertComponent</link> method, or by
removing the component from it's owner's owned component list using the

          <link id="TComponent.RemoveComponent">RemoveComponent</link> method.
</descr>
        <seealso>
          <link id="TComponent.Components">Components</link>
          <link id="TComponent.InsertComponent">InsertComponent</link>
          <link id="TComponent.RemoveComponent">RemoveComponent</link>
        </seealso>
      </element>
      <element name="TComponent.VCLComObject">
        <!-- Property -->
        <short>Not implemented.</short>
        <descr>
          <var>VCLComObject</var> is not yet implemented in Free Pascal.
</descr>
      </element>
      <element name="TComponent.Name">
        <!-- Property -->
        <short>Name of the component.</short>
        <descr>
          <p>
            <var>Name</var> is the name of the component. This name should be a valid
identifier, i.e. must start with a letter or underscore, and can contain only letters,
numbers and the underscore character. When attempting to set the name of a
component, the name will be checked for validity. Furthermore, when a
component is owned by another component, the name must be either empty
or must be unique among the child component names.
</p>
          <p>By "letters", 7-bit letters are meant.
</p>
        </descr>
        <errors>Attempting to set the name to an invalid value will result in an exception
being raised.
</errors>
        <seealso>
          <link id="TComponent.ValidateRename">ValidateRename</link>
          <link id="TComponent.Owner">Owner</link>
        </seealso>
      </element>
      <element name="TComponent.Tag">
        <!-- Property -->
        <short>Tag value of the component.</short>
        <descr>
          <var>Tag</var> can be used to store an integer value in the component. This
value is streamed together with all other published properties. It can be
used for instance to quickly identify a component in an event handler.
</descr>
        <seealso>
          <link id="TComponent.Name">Name</link>
        </seealso>
      </element>
      <element name="TBasicAction">
        <short>Abstract base class for all Actions.</short>
        <descr>
          <p>
            <var>TBasicAction</var> implements a basic action class from which all
actions are derived. It introduces all basic methods of an action, and
implements functionality to maintain a list of clients, i.e. components that
are connected with this action.
</p>
          <p>Do not create instances of <var>TBasicAction</var>. Instead, create a
descendent class and create an instance of this class instead.
</p>
        </descr>
        <seealso>
          <link id="TBasicActionLink"/>
          <link id="TComponent"/>
        </seealso>
      </element>
      <element name="TBasicAction.FClients">
        <short>List with components linked to this action.
</short>
        <descr>
          <var>FClients</var> is a list of 
          <link id="TBasicActionLink"/> classes which
represent links to various components that are connected to this action.
The elements in this list should not be manipulated directly, but should be
managed with the 

          <link id="TBasicAction.RegisterChanges">RegisterChanges</link> and 

          <link id="TBasicAction.UnRegisterChanges">UnRegisterChanges</link> methods.
</descr>
        <seealso>
          <link id="TBasicAction.RegisterChanges">RegisterChanges</link>
          <link id="TBasicAction.UnRegisterChanges">UnRegisterChanges</link>
          <link id="TBasicActionLink"/>
        </seealso>
      </element>
      <element name="TBasicAction.Change">
        <short>Calls the <link id="TBasicAction.OnChange">OnChange</link> handler.</short>
        <descr>
          <p>
            <var>Change</var> calls the 
            <link id="TBasicAction.OnChange">OnChange</link>
handler if one is assigned.
</p>
          <p>Application programmers should not call <var>Change</var> directly.
It is called automatically if a property of an action component changes.
</p>
          <p>Descendent classes of <var>TBasicAction</var> should call explicitly call
<var>Change</var> if one of their properties that affect client controls
changes its value.
</p>
        </descr>
      </element>
      <element name="TBasicAction.SetOnExecute">
        <short>Assigns an <link id="TBasicAction.OnExecute">OnExecute</link> event
handler</short>
        <descr>
          <var>SetOnExecute</var> sets the 

          <link id="TBasicAction.OnExecute">OnExecute</link> handler of the component.
It also propagates this event to all client controls, and finally triggers
the 
          <link id="TBasicAction.OnChange">OnChange</link> event.
</descr>
        <seealso>
          <link id="TBasicAction.OnExecute">OnExecute</link>
          <link id="TBasicAction.OnChange">OnChange</link>
        </seealso>
      </element>
      <element name="TBasicAction.OnChange">
        <short>Occurs when one of the action's properties changes.
</short>
        <descr>
          <p>
            <var>OnChange</var> is the event that is triggered when one of the
action's properties changes. This event should be used by client 
controls or descendent classes to respond to these changes in the properties
of the action.
</p>
          <p>Application programmers should never use the <var>OnChange</var> event
directly.
</p>
        </descr>
      </element>
      <element name="TBasicAction.Create">
        <short>Creates a new instance of a <link id="TBasicAction"/> class.
</short>
        <descr>
          <p>
            <var>Create</var> calls the inherited constructor, and then initializes the 
list of clients controls (or action lists).
</p>
          <p>Under normal circumstances it should not be necessary to create a
<var>TBasicAction</var> descendent manually, actions are created in an IDE.
</p>
        </descr>
        <seealso>
          <link id="TBasicAction.Destroy">Destroy</link>
          <link id="TBasicAction.AssignClient">AssignClient</link>
        </seealso>
      </element>
      <element name="TBasicAction.Destroy">
        <short>Destroys the action.</short>
        <descr>
          <p>
            <var>Destroy</var> cleans up the list of client controls and then calls the
inherited destructor.
</p>
          <p>An application programmer should not call <var>Destroy</var> directly;
Instead <var>Free</var> should be called, if it needs to be called at all.
Normally the controlling class (e.g. a TActionList) will destroy the action.
</p>
        </descr>
      </element>
      <element name="TBasicAction.HandlesTarget">
        <short>Determines whether <var>Target</var> can be handled by this action
</short>
        <descr>
          <p>
            <var>HandlesTarget</var> returns 
            <var>True</var> if 
            <var>Target</var> is 
a valid client for this action and if so, if it is in a suitable state to
execute the action. An application programmer should never need to call

            <var>HandlesTarget</var> directly, it will be called by the action itself
when needed.
</p>
          <p>In <var>TBasicAction</var> this method is empty; descendent classes should
override this method to implement appropriate checks.
</p>
        </descr>
        <seealso>
          <link id="TBasicAction.UpdateTarget">UpdateTarget</link>
          <link id="TBasicAction.ExecuteTarget">ExecuteTarget</link>
        </seealso>
      </element>
      <element name="TBasicAction.UpdateTarget">
        <short>Notify client controls when the action updates itself.</short>
        <descr>
          <p>
            <var>UpdateTarget</var> should update the client control specified by

            <var>Target</var> when the action updates itself. 
In 
            <var>TBasicAction</var>, the implementation of 
            <var>UpdateTarget</var> 
is empty. Descendent classes should override and implement 

            <var>UpdateTarget</var> to actually update the 
            <var>Target</var> object.
</p>
          <p>An application programmer should never need to call
<var>HandlesTarget</var> directly, it will be called by the action itself
when needed.
</p>
        </descr>
        <seealso>
          <link id="TBasicAction.HandlesTarget">HandlesTarget</link>
          <link id="TBasicAction.ExecuteTarget">ExecuteTarget</link>
        </seealso>
      </element>
      <element name="TBasicAction.ExecuteTarget">
        <short>Executes the action on the <var>Target</var> object</short>
        <descr>
          <p>
            <var>ExecuteTarget</var> performs the action on the 
            <var>Target</var>
object. In 
            <var>TBasicAction</var> this method does nothing. Descendent
classes should implement the action to be performed. For instance an action
to post data in a dataset could call the 
            <var>Post</var> method of the
dataset.
</p>
          <p>An application programmer should never call <var>ExecuteTarget</var>
directly.
</p>
        </descr>
        <seealso>
          <link id="TBasicAction.HandlesTarget">HandlesTarget</link>
          <link id="TBasicAction.ExecuteTarget">UpdateTarget</link>
          <link id="TBasicAction.Execute">Execute</link>
        </seealso>
      </element>
      <element name="TBasicAction.Execute">
        <short>Triggers the <link id="TBasicAction.OnExecute">OnExecute</link> event</short>
        <descr>
          <var>Execute</var> triggers the 
          <var>OnExecute</var> event, if one is
assigned. It returns 
          <var>True</var> if the event handler was called,

          <var>False</var> otherwise.
</descr>
      </element>
      <element name="TBasicAction.RegisterChanges">
        <short>Registers a new client with the action.</short>
        <descr>
          <var>RegisterChanges</var> adds 
          <var>Value</var> to the list of clients. 
</descr>
        <seealso>
          <link id="TBasicAction.UnregisterChanges">UnregisterChanges</link>
        </seealso>
      </element>
      <element name="TBasicAction.UnregisterChanges">
        <short>Unregisters a client from the list of clients</short>
        <descr>
          <var>UnregisterChanges</var> removes 
          <var>Value</var> from the list of clients.
This is called for instance when the action is destroyed, or when the client
is assigned a new action.
</descr>
        <seealso>
          <link id="TBasicAction.UnregisterChanges">UnregisterChanges</link>
          <link id="TBasicAction.Destroy">Destroy</link>
        </seealso>
      </element>
      <element name="TBasicAction.Update">
        <short>Triggers the <link id="TBasicAction.OnUpdate">OnUpdate</link> event</short>
        <descr>
          <p>
            <var>Update</var> triggers the 
            <var>OnUpdate</var> event, if one is
assigned. It returns 
            <var>True</var> if the event was triggered, or

            <var>False</var> if no event was assigned.
</p>
          <p>Application programmers should never run <var>Update</var> directly. The
<var>Update</var> method is called automatically by the action mechanism;
Normally this is in the Idle time of an application. An application
programmer should assign the <link id="TBasicAction.OnUpdate">OnUpdate</link>
event, and perform any checks in that handler.
</p>
        </descr>
        <seealso>
          <link id="TBasicAction.OnUpdate">OnUpdate</link>
          <link id="TBasicAction.Execute">Execute</link>
          <link id="TBAsicAction.UpdateTarget">UpdateTarget</link>
        </seealso>
      </element>
      <element name="TBasicAction.ActionComponent">
        <short>Returns the component that initiated the action.</short>
        <descr>
          <var>ActionComponent</var> is set to the component that caused the action to
execute, e.g. a toolbutton or a menu item. 
The property is set just before the action executes, and is reset to nil 
after the action was executed.
</descr>
        <seealso>
          <link id="TBasicAction.Execute">Execute</link>
          <link id="TBasicAction.OnExecute">OnExecute</link>
        </seealso>
      </element>
      <element name="TBasicAction.OnExecute">
        <short>Event triggered when the action executes.</short>
        <descr>
          <p>
            <var>OnExecute</var> is the event triggered when the action is activated
(executed). The event is triggered e.g. when the user clicks e.g. on a menu
item or a button associated to the action. The application programmer 
should provide a 
            <var>OnExecute</var> event handler to execute whatever code
is necessary when the button is pressed or the menu item is chosen.
</p>
          <p>Note that assigning an <var>OnExecute</var> handler will result in the
<link id="TBasicAction.Execute">Execute</link> method returning a
<var>True</var> value. Predefined actions (such as dataset actions)
will check the result of <var>Execute</var> and will not perform their 
normal task if the <var>OnExecute</var> handler was called.
</p>
        </descr>
        <seealso>
          <link id="TBasicAction.Execute">Execute</link>
          <link id="TBasicAction.OnUpdate">OnUpdate</link>
        </seealso>
      </element>
      <element name="TBasicAction.OnUpdate">
        <short>Event trigged when the application is idle.</short>
        <descr>
          <var>OnUpdate</var> is the event triggered when the application is idle, and
the action is being updated. The 
          <var>OnUpdate</var> event can be used to
set the state of the action, for instance disable it if the action cannot be
executed at this point in time.
</descr>
        <seealso>
          <link id="TBasicAction.Update">Update</link>
          <link id="TBasicAction.OnExecute">OnExecute</link>
        </seealso>
      </element>
      <element name="TBasicActionLink">
        <short>Link between actions and action clients (e.g. controls)</short>
        <descr>
          <p>
            <var>TBasicActionLink</var> links an Action to its clients. With each client
for an action, a 
            <var>TBasicActionLink</var> class is instantiated to handle
the communication between the action and the client. It passes events
between the action and its clients, and thus presents the action with a
uniform interface to the clients.
</p>
          <p>An application programmer should never use a <var>TBasicActionLink</var>
instance directly; They are created automatically when an action is
associated with a component. Component programmers should create specialized
descendents of <var>TBasicActionLink</var> which communicate changes in the
action to the component.
</p>
        </descr>
        <seealso>
          <link id="TBasicAction"/>
        </seealso>
      </element>
      <element name="TBasicActionLink.FAction">
        <short>The action with which this link is associated</short>
        <descr>
          <var>FAction</var> contains a reference to the action with which this link
is associated. It should never be manipulated directly. It will be set
automatically by the 
          <link id="TBasicActionLink.SetAction">SetAction</link> write method
for the 
          <link id="TBasicActionLink.Action">Action</link> property.
</descr>
        <seealso>
          <link id="TBasicActionLink.SetAction">SetAction</link>
          <link id="TBasicActionLink.Action">Action</link>
        </seealso>
      </element>
      <element name="TBasicActionLink.AssignClient">
        <short>Assigns a control (client) to the action link.</short>
        <descr>
          <var>AssignClient</var> assigns a control to the actionlink and hence to the
action. Descendent classes can override 
          <var>AssignClient</var> to check
whether the new client is a suitable client for this action.
</descr>
        <seealso>
          <link id="TBasicActionLink.Action">Action</link>
        </seealso>
      </element>
      <element name="TBasicActionLink.Change">
        <short>Executed whenever the Action is changed.</short>
        <descr>
          <p>
            <var>Change</var> is executed whenever the action changes. 
It executes the 
            <link id="TBasicActionLink.OnChange">OnChange</link>
handler, if one is assigned.
</p>
          <p>Component programmers may decide to override the <var>Change</var>
procedure in descendent classes to perform aditional actions when 
the properties of the action changes.
</p>
        </descr>
        <seealso>
          <link id="TBasicActionLink.OnChange">OnChange</link>
          <link id="TBasicAction.Change"/>
        </seealso>
      </element>
      <element name="TBasicActionLink.IsOnExecuteLinked">
        <short>Returns whether the client has it's OnExecute property linked.</short>
        <descr>
          <var>IsOnExecuteLinked</var> always returns true in 
          <var>TBasicActionLink</var>. 
Descendent classes can override this method to provide a different result.
</descr>
        <link id="TBasicActionLink.OnExecute">OnExecute</link>
      </element>
      <element name="TBasicActionLink.SetAction">
        <short>Sets the action with which the actionlink is associated.</short>
        <descr>
          <var>SetAction</var> is the write handler for the 
          <link id="TBasicActionLink.Action">Action</link> property. It sets the

          <var>Action</var> property to it's new value, after unregistering itself 
with the old action, if there was one.
</descr>
        <seealso>
          <link id="TBasicActionLink.Action">Action</link>
          <link id="TBasicAction"/>
        </seealso>
      </element>
      <element name="TBasicActionLink.SetOnExecute">
        <short>Assigns the <link id="TBasicAction.OnExecute">OnExecute</link> handler
to the client</short>
        <descr>
          <var>SetOnExecute</var> must be overridden by descendent classes to pass the

          <var>OnExecute</var> handler of the associated action to the client control.
It will attach the 
          <var>OnExecute</var> handler to whatever handler is
appropriate for the client control.
</descr>
        <seealso>
          <link id="TBasicAction.OnExecute">OnExecute</link>
          <link id="TBasicAction"/>
        </seealso>
      </element>
      <element name="TBasicActionLink.Create">
        <short>Creates a new instance of the TBasicActionLink class</short>
        <descr>
          <p>
            <var>Create</var> creates a new instance of a 
            <var>TBasicActionLink</var>
and assigns 
            <var>AClient</var> as the client of the link.
</p>
          <p>Application programmers should never instantiate <var>TBasicActionLink</var>
classes directly. An instance is created automatically when an action is
assigned to a control (client).
</p>
          <p>Component programmers can override the create constructor to initialize
further properties. 
</p>
        </descr>
        <seealso>
          <link id="TBasicActionLink.Destroy">Destroy</link>
        </seealso>
      </element>
      <element name="TBasicActionLink.Destroy">
        <short>Destroys the TBasicActionLink instance.</short>
        <descr>
          <p>
            <var>Destroy</var> unregisters the 
            <var>TBasicActionLink</var> with the
action, and then calls the inherited destructor.
</p>
          <p>Application programmers should never call <var>Destroy</var> directly. If a
link should be destroyed at all, the <var>Free</var> method should be called
instead.
</p>
        </descr>
        <seealso>
          <link id="TBasicActionLink.Create">Create</link>
        </seealso>
      </element>
      <element name="TBasicActionLink.Execute">
        <short>Calls the action's Execute method.</short>
        <descr>
          <p>
            <var>Execute</var> sets the 
            <link id="TBasicAction.ActionComponent">ActionComponent</link> 
property of the associated 
            <link id="TBasicActionLink.Action">Action</link> to 

            <var>AComponent</var> and then calls the Action's  
            <link id="TBasicAction.Execute">execute</link> method. After the action has 
executed, the 
            <var>ActionComponent</var> property is cleared again.
</p>
          <p>The return value of the function is the return value of the Action's execute
method.
</p>
          <p>Application programmers should never call <var>Execute</var> directly. This
method will be called automatically when the associated control is
activated. (e.g. a button is clicked on)
</p>
          <p>Component programmers should call <var>Execute</var> whenever the action
should be activated.
</p>
        </descr>
        <seealso>
          <link id="TBasicActionLink.Action">Action</link>
          <link id="TBasicAction.ActionComponent"/>
          <link id="TBasicAction.Execute"/>
          <link id="TBasicAction.onExecute"/>
        </seealso>
      </element>
      <element name="TBasicActionLink.Update">
        <short>Calls the action's Update method</short>
        <descr>
          <p>
            <var>Update</var> calls the associated Action's 
            <link id="TBasicAction.Update">Update</link> methoda.
</p>
          <p>Component programmers can override the <var>Update</var> method to provide
additional processing when the <var>Update</var> method occurs.
</p>
        </descr>
      </element>
      <element name="TBasicActionLink.Action">
        <short>The action to which the link was assigned.</short>
        <descr>
          <var>Action</var> represents the 
          <link id="TBasicAction">Action</link> which
was assigned to the client. Setting this property will unregister the client
at the old action (if one existed) and registers the client at the new
action.
</descr>
        <seealso>
          <link id="TBasicAction"/>
        </seealso>
      </element>
      <element name="TBasicActionLink.OnChange">
        <short>Event handler triggered when the action's properties change</short>
        <descr>
          <p>
            <var>OnChange</var> is the event triggered when the action's properties
change.
</p>
          <p>Application programmers should never need to assign this event. Component
programmers can assign this event to have a client control reflect any
changes in an Action's properties.
</p>
        </descr>
        <seealso>
          <link id="TBasicActionLink.Change">Change</link>
          <link id="TBasicAction.Change"/>
        </seealso>
      </element>
      <element name="TActiveXRegType">
        <!-- Enumeration type -->
        <short>Used when registering ActveX component types.</short>
        <descr>This type is provided for compatibility only, and is currently not used in
Free Pascal.
</descr>
        <seealso/>
      </element>
      <element name="TActiveXRegType.axrComponentOnly">
        <!-- Enumeration value -->
        <short/>
      </element>
      <element name="TActiveXRegType.axrIncludeDescendants">
        <!-- Enumeration value -->
        <short/>
      </element>
      <element name="RegisterComponentsProc">
        <!-- Variable -->
        <short>Callback procedure used when handling component registration.</short>
        <descr>
          <var>RegisterComponentsProc</var> can be set by an IDE to be notified when
new components are being registered. Application programmers should never
have to set 
          <var>RegisterComponentsProc</var>
        </descr>
        <seealso>
          <link id="RegisterNoIconProc"/>
          <link id="RegisterComponents"/>
        </seealso>
      </element>
      <element name="RegisterNoIconProc">
        <!-- Variable -->
        <short>Callback procedure used when handling iconless component registration.</short>
        <descr>
          <var>RegisterNoIconProc</var> can be set by an IDE to be notified when
new components are being registered, and which do not need an Icon in the
component palette. Application programmers should never
have to set 
          <var>RegisterComponentsProc</var>
        </descr>
        <seealso/>
      </element>
      <element name="Point">
        <!-- Function -->
        <short>Returns a <var>TPoint</var> record with the given coordinates.</short>
        <descr>
          <var>Point</var> returns a 
          <link id="TPoint"/> record with the given
coordinates 
          <var>AX</var> and 
          <var>AY</var> filled in.
</descr>
        <seealso>
          <link id="TPoint"/>
          <link id="SmallPoint"/>
          <link id="Rect"/>
          <link id="Bounds"/>
        </seealso>
      </element>
      <element name="SmallPoint">
        <!-- Function -->
        <short>Returns a <var>TSmallPoint</var> record with the given coordinates.</short>
        <descr>
          <var>SmallPoint</var> returns a 
          <link id="TSmallPoint"/> record with the given
coordinates 
          <var>AX</var> and 
          <var>AY</var> filled in.
</descr>
        <seealso>
          <link id="TSmallPoint"/>
          <link id="Point"/>
          <link id="Rect"/>
          <link id="Bounds"/>
        </seealso>
      </element>
      <element name="Rect">
        <!-- Function -->
        <short>Returns a <var>TRect</var> record with the given coordinates.</short>
        <descr>
          <p>
            <var>Rect</var> returns a 
            <link id="TRect"/> record with the given
top-left 
            <var>(ALeft,ATop)</var> and bottom-right 
            <var>(ABottom,ARight)</var>
corners filled in.
</p>
          <p>No checking is done to see whether the coordinates are valid.
</p>
        </descr>
        <seealso>
          <link id="TRect"/>
          <link id="Point"/>
          <link id="SmallPoint"/>
          <link id="Bounds"/>
        </seealso>
      </element>
      <element name="Bounds">
        <!-- Function -->
        <short>Returns a <var>TRect</var> structure with the bounding rect of the
given location and size.</short>
        <descr>
          <var>Bounds</var> returns a 
          <link id="TRect"/> record with the given
origin 
          <var>(ALeft,ATop)</var> and dimensions 
          <var>(AWidth,AHeight)</var> 
filled in.
</descr>
        <seealso/>
      </element>
      <element name="RegisterClass">
        <!-- Procedure -->
        <short>Registers a class with the streaming system.</short>
        <descr>
          <var>RegisterClass</var> registers the class 
          <var>AClass</var> in the
streaming system. After the class has been registered, it can be read from
a stream when a reference to this class is encountered.
</descr>
        <seealso>
          <link id="RegisterClasses"/>
          <link id="RegisterClassAlias"/>
          <link id="RegisterComponents"/>
          <link id="UnregisterClass"/>
        </seealso>
      </element>
      <element name="RegisterClasses">
        <!-- Procedure -->
        <short>Registers multiple classes with the streaming system.</short>
        <descr>
          <var>RegisterClasses</var> registers the specified classes 
          <var>AClass</var> in the
streaming system. After the classes have been registered, they can be read from
a stream when a reference to this class is encountered.
</descr>
        <seealso>
          <link id="RegisterClass"/>
          <link id="RegisterClassAlias"/>
          <link id="RegisterComponents"/>
          <link id="UnregisterClass"/>
        </seealso>
      </element>
      <element name="RegisterClassAlias">
        <!-- Procedure -->
        <short>Registers a class alias with the streaming system.</short>
        <descr>
          <var>RegisterClassAlias</var> registers a class alias in the streaming
system. If a reference to a class 
          <var>Alias</var> is encountered in a
stream, then an instance of the class 
          <var>AClass</var> will be created 
instead by the streaming code.
</descr>
        <seealso>
          <link id="RegisterClass"/>
          <link id="RegisterClasses"/>
          <link id="RegisterComponents"/>
          <link id="UnregisterClass"/>
        </seealso>
      </element>
      <element name="UnRegisterClass">
        <!-- Procedure -->
        <short>Unregisters a class from the streaming system.</short>
        <descr>
          <var>UnregisterClass</var> removes the class 
          <var>AClass</var> from the
class definitions in the streaming system.
</descr>
        <seealso>
          <link id="UnRegisterClasses"/>
          <link id="UnRegisterModuleClasses"/>
          <link id="RegisterClass"/>
        </seealso>
      </element>
      <element name="UnRegisterClasses">
        <!-- Procedure -->
        <short>Unregisters multiple classes from the streaming system.</short>
        <descr>
          <var>UnregisterClasses</var> removes the classes in 
          <var>AClasses</var> from the
class definitions in the streaming system.
</descr>
        <link id="UnRegisterClass"/>
        <link id="UnRegisterModuleClasses"/>
        <link id="RegisterClasses"/>
        <seealso/>
      </element>
      <element name="UnRegisterModuleClasses">
        <!-- Procedure -->
        <short>Unregisters classes registered by module.</short>
        <descr>
          <var>UnRegisterModuleClasses</var> unregisters all classes which reside in 
the module 
          <var>Module</var>. For each registered class, the definition
pointer is checked to see whether it resides in the module, and if it does,
the definition is removed.
</descr>
        <seealso>
          <link id="UnRegisterClass"/>
          <link id="UnRegisterClasses"/>
          <link id="RegisterClasses"/>
        </seealso>
      </element>
      <element name="FindClass">
        <!-- Function -->
        <short>Returns the class pointer of a class with given name.</short>
        <descr>
          <p>
            <var>FindClass</var> searches for the class named 
            <var>ClassName</var>
in the list of registered classes and returns a class pointer to the
definition. If no class with the given name could be found, an exception is
raised.
</p>
          <p>The <link id="GetClass"/> function does not raise an exception when it
does not find the class, but returns a <var>Nil</var> pointer instead.
</p>
        </descr>
        <seealso>
          <link id="RegisterClass"/>
          <link id="GetClass"/>
        </seealso>
      </element>
      <element name="GetClass">
        <!-- Function -->
        <short>Returns the class pointer of a class with given name.</short>
        <descr>
          <p>
            <var>GetClass</var> searches for the class named 
            <var>ClassName</var>
in the list of registered classes and returns a class pointer to the
definition. If no class with the given name could be found, 
            <var>Nil</var>
is returned.
</p>
          <p>The <link id="FindClass"/> function will raise an exception if the 
does not find the class.
</p>
        </descr>
        <seealso>
          <link id="RegisterClass"/>
          <link id="GetClass"/>
        </seealso>
      </element>
      <element name="RegisterComponents">
        <!-- Procedure -->
        <short>Registers components for the component palette.</short>
        <descr>
          <p>
            <var>RegisterComponents</var> registers the component on the appropriate
component page. The component pages can be used by an IDE to display the
known components so an application programmer may pick and use the
components in his programs.
</p>
          <p>Registercomponents inserts the component class in the correct component
page. If the <var>RegisterComponentsProc</var> procedure is set, this is
called as well. Note that this behaviour is different from Delphi's
behaviour where an exception will be raised if the procedural variable is
not set.
</p>
        </descr>
        <seealso>
          <link id="RegisterClass"/>
          <link id="RegisterNoIcon"/>
        </seealso>
      </element>
      <element name="RegisterNoIcon">
        <!-- Procedure -->
        <short>Registers components that have no icon on the component palette.</short>
        <descr>
          <var>RegisterNoIcon</var> performs the same function as 
          <link id="RegisterComponents"/> except that it calls 
          <link id="RegisterNoIconProc"/>
instead of 
          <link id="RegisterComponentsProc"/>
        </descr>
        <seealso>
          <link id="RegisterNoIconProc"/>
          <link id="RegisterComponents"/>
        </seealso>
      </element>
      <element name="RegisterNonActiveX">
        <!-- Procedure -->
        <short>Register non-activex component.</short>
        <descr>Not yet implemented in Free Pascal
</descr>
        <seealso/>
      </element>
      <element name="TIdentMapEntry">
        <!-- Record type -->
        <short>Record used when associating names with integer values.</short>
        <descr>
          <var>TIdentMapEntry</var> is used internally by the 
          <link id="IdentToInt"/>
and 
          <link id="IntToIdent"/> calls to store the mapping between the
identifiers and the integers they represent.
</descr>
        <seealso>
          <link id="IntToIdent"/>
          <link id="IdentToInt"/>
        </seealso>
      </element>
      <element name="TIdentMapEntry.Value">
        <!-- Variable -->
        <short>Integer value</short>
      </element>
      <element name="TIdentMapEntry.Name">
        <!-- Variable -->
        <short>Name of the integer value.</short>
      </element>
      <element name="TIdentToInt">
        <!-- Function type -->
        <short>Callback for converting identifiers to integers.</short>
        <descr>
          <p>
            <var>TIdentToInt</var> is a callback used to look up identifiers 
(
            <var>Ident</var>) and return an integer value corresponding to this
identifier (
            <var>Int</var>). The callback should return 
            <var>True</var> if a
value corresponding to integer 
            <var>Ident</var> was found, 
            <var>False</var>
if not.
</p>
          <p>A callback of type <var>TIdentToInt</var> should be specified when an
integer is registered using the <link id="RegisterIntegerConsts"/> call.
</p>
        </descr>
        <seealso>
          <link id="RegisterIntegerConsts"/>
          <link id="TIntToIdent"/>
        </seealso>
      </element>
      <element name="TIntToIdent">
        <!-- Function type -->
        <short>Callback for converting integers to identifiers.</short>
        <descr>
          <p>
            <var>TIdentToInt</var> is a callback used to look up integers 
(
            <var>Ident</var>) and return an identifier (
            <var>Ident</var>) 
that can be used to represent this integer value in an IDE.
The callback should return 
            <var>True</var> if a value corresponding 
to integer 
            <var>Ident</var> was found, 
            <var>False</var> if not.
</p>
          <p>A callback of type <var>TIntToIdent</var> should be specified when an
integer is registered using the <link id="RegisterIntegerConsts"/> call.
</p>
        </descr>
        <seealso>
          <link id="RegisterIntegerConsts"/>
          <link id="TIdentToInt"/>
        </seealso>
      </element>
      <element name="TFindGlobalComponent">
        <!-- Function type -->
        <short>Callback type to search for a component.</short>
        <descr>
          <p>
            <var>TFindGlobalComponent</var> is a callback used to find a component in a
global scope. It is used when the streaming system needs to find a component
which is not part of the component which is currently being streamed. It
should return the component with name 
            <var>Name</var>, or 
            <var>Nil</var> if
none is found.
</p>
          <p>The variable <link id="FindGlobalComponent"/> is a callback of type
<var>TFindGlobalComponent</var>. It can be set by the IDE when an unknown
reference is found, to offer the designer to redirect the link to a new
component.
</p>
        </descr>
        <seealso>
          <link id="FindGlobalComponent"/>
        </seealso>
      </element>
      <element name="MainThreadID">
        <!-- Variable -->
        <short>ID of main thread. Unused at this point.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="FindGlobalComponent">
        <!-- Variable -->
        <short>Callback used when a component must be found.</short>
        <descr>
          <p>
            <var>FindGlobalComponent</var> is a callback of type

            <link id="TFindGlobalComponent"/>. It can be set by the IDE when an unknown
reference is found, to offer the user to redirect the link to a new
component.
</p>
          <p>It is a callback used to find a component in a
global scope. It is used when the streaming system needs to find a component
which is not part of the component which is currently being streamed. It
should return the component with name <var>Name</var>, or <var>Nil</var> if
none is found.
</p>
        </descr>
        <seealso>
          <link id="TFindGlobalComponent"/>
        </seealso>
      </element>
      <element name="RegisterIntegerConsts">
        <!-- Procedure -->
        <short>Registers some integer-to-identifier mappings.</short>
        <descr>
          <p>
            <var>RegisterIntegerConsts</var> registers a pair of callbacks to be used
when an integer of type 
            <var>IntegerType</var> must be mapped to an
identifier (using 
            <var>IntToIdentFn</var>) or when an identifier must be
mapper to an integer (using 
            <var>IdentToIntFn</var>). 
</p>
          <p>Component programmers can use <var>RegisterIntegerConsts</var> to associate
a series of identifier strings with integer values for a property. A
necessary condition is that the property should have a separate type
declared using the <var>type integer</var> syntax. If a type of integer is
defined in this way, an IDE can show symbolic names for the values of these 
properties.
</p>
          <p>The <var>IntegerType</var> should be a pointer to the type information of
the integer type. The <var>IntToIdentFn</var> and <var>IdentToIntFn</var>
are two callbacks that will be used when converting between the identifier
and integer value and vice versa. The functions <link id="IdentToInt"/>
and <link id="IntToIdent"/> can be used to implement these callback
functions.
</p>
        </descr>
        <seealso>
          <link id="TIdentToInt"/>
          <link id="TIntToIdent"/>
          <link id="IdentToInt"/>
          <link id="IntToIdent"/>
        </seealso>
      </element>
      <element name="IdentToInt">
        <!-- Function -->
        <short>Looks up an integer value in a integer-to-identifier map list.</short>
        <descr>
          <var>IdentToInt</var> searches 
          <var>Map</var> for an entry whose

          <var>Name</var> field matches 
          <var>Ident</var> and returns the corresponding
integer value in 
          <var>Int</var>. If a match was found, the function returns

          <var>True</var>, otherwise, 
          <var>False</var> is returned.
</descr>
        <seealso>
          <link id="TIdentToInt"/>
          <link id="TIntToIdent"/>
          <link id="IntToIdent"/>
          <link id="TIdentMapEntry"/>
        </seealso>
      </element>
      <element name="IntToIdent">
        <!-- Function -->
        <short>Looks up an identifier for an integer value in a identifier-to-integer map list.</short>
        <descr>
          <var>IdentToInt</var> searches 
          <var>Map</var> for an entry whose

          <var>Value</var> field matches 
          <var>Int</var> and returns the corresponding
identifier in 
          <var>Ident</var>. If a match was found, the function returns

          <var>True</var>, otherwise, 
          <var>False</var> is returned.
</descr>
        <seealso>
          <link id="TIdentToInt"/>
          <link id="TintToIdent"/>
          <link id="IdentToInt"/>
          <link id="TIdentMapEntry"/>
        </seealso>
      </element>
      <element name="InitInheritedComponent">
        <!-- Function -->
        <short>Initializes a component descending from <var>RootAncestor</var>
        </short>
        <descr>
          <p>
            <var>InitInheritedComponent</var> should be called from a constructor to
read properties of the component 
            <var>Instance</var> from the streaming
system. The 
            <var>RootAncestor</var> class is the root class from which

            <var>Instance</var> is a descendent. This must be one of

            <var>TDatamodule</var>, 
            <var>TCustomForm</var> or 
            <var>TFrame</var>.
</p>
          <p>The function returns <var>True</var> if the properties were successfully
read from a stream or <var>False</var> if some error occurred.
</p>
        </descr>
        <seealso>
          <link id="ReadComponentRes"/>
          <link id="ReadComponentResEx"/>
          <link id="ReadComponentResFile"/>
        </seealso>
      </element>
      <element name="InitComponentRes">
        <!-- Function -->
        <short>Provided for Delphi compatibility only</short>
        <descr>This function is provided for Delphi compatibility. 
It always returns <var>false</var>.
</descr>
        <seealso>
          <link id="ReadComponentRes"/>
        </seealso>
      </element>
      <element name="ReadComponentRes">
        <!-- Function -->
        <short>Read component properties from a resource in the current module</short>
        <descr>This function is provided for Delphi compatibility. 
It always returns <var>Nil</var>.
</descr>
      </element>
      <element name="ReadComponentResEx">
        <!-- Function -->
        <short>Read component properties from a resource in the specified module</short>
        <descr>This function is provided for Delphi compatibility. 
It always returns <var>Nil</var>.
</descr>
      </element>
      <element name="ReadComponentResFile">
        <!-- Function -->
        <short>Read component properties from a specified resource file</short>
        <descr>
          <var>ReadComponentResFile</var> starts reading properties for

          <var>Instance</var> from the file 
          <var>FileName</var>. It creates a
filestream from 
          <var>FileName</var> and then calls the 
          <link id="TStream.ReadComponentRes"/> method to read the state of the component from the
stream.
</descr>
        <seealso>
          <link id="TStream.ReadComponentRes"/>
          <link id="WriteComponentResFile"/>
        </seealso>
      </element>
      <element name="WriteComponentResFile">
        <!-- Procedure -->
        <short>Write component properties to a specified resource file</short>
        <descr>
          <var>WriteComponentResFile</var> starts writing properties of

          <var>Instance</var> to the file 
          <var>FileName</var>. It creates a
filestream from 
          <var>FileName</var> and then calls 
          <link id="TStream.WriteComponentRes"/> method to write the state of 
the component to the stream.
</descr>
        <seealso>
          <link id="TStream.WriteComponentRes"/>
          <link id="ReadComponentResFile"/>
        </seealso>
      </element>
      <element name="GlobalFixupReferences">
        <!-- Procedure -->
        <short>Called to resolve unresolved references after forms are loaded.</short>
        <descr>
          <var>GlobalFixupReferences</var> runs over the list of unresolved references
and tries to resolve them. This routine should under normal circumstances
not be called in an application programmer's code. It is called
automatically by the streaming system after a component has been
instantiated and its properties read from a stream. It will attempt to
resolve references to other global components. 
</descr>
        <seealso>
          <link id="GetFixupReferenceNames"/>
          <link id="GetFixupInstanceNames"/>
        </seealso>
      </element>
      <element name="GetFixupReferenceNames">
        <!-- Procedure -->
        <short>Returns the names of elements that need to be resolved for the
<var>root</var> component.</short>
        <descr>
          <var>GetFixupReferenceNames</var> examines the list of unresolved references
and returns the names of properties that must be resolved for the
component 
          <var>Root</var> in the list 
          <var>Names</var>. The list is not
cleared prior to filling it.
</descr>
        <seealso>
          <link id="GetFixupInstanceNames"/>
          <link id="GlobalFixupReferences"/>
        </seealso>
      </element>
      <element name="GetFixupInstanceNames">
        <!-- Procedure -->
        <short>Returns the names of elements that need to be resolved for the
<var>root</var> component, whose reference contains <var>ReferenceRootName</var>
        </short>
        <descr>
          <var>GetFixupInstanceNames</var> examines the list of unresolved references
and returns the names of classes that contain unresolved references to the

          <var>Root</var> component in the list 
          <var>Names</var>. The list is not
cleared prior to filling it.
</descr>
        <seealso>
          <link id="GetFixupReferenceNames"/>
          <link id="GlobalFixupReferences"/>
        </seealso>
      </element>
      <element name="RedirectFixupReferences">
        <!-- Procedure -->
        <short>Redirects references under the <var>root</var> object from
<var>OldRootName</var> to <var>NewRootName</var>
        </short>
        <descr>
          <p>
            <var>RedirectFixupReferences</var> examines the list of unresolved
references and replaces references to a root object named

            <var>OldRootName</var> with references to root object 

            <var>NewRootName</var>.
</p>
          <p>An application programmer should never need to call 
<var>RedirectFixupReferences</var>.
This function can be used by an IDE to support redirection of broken
component links.
</p>
        </descr>
        <seealso>
          <link id="RemoveFixupReferences"/>
        </seealso>
      </element>
      <element name="RemoveFixupReferences">
        <!-- Procedure -->
        <short>Removes references to rootname from the fixup list.</short>
        <descr>
          <p>
            <var>RemoveFixupReferences</var> examines the list of unresolved
references and removes references to a root object pointing at

            <var>Root</var> or a root component named 
            <var>RootName</var>.
</p>
          <p>An application programmer should never need to call 
<var>RemoveFixupReferences</var>.
This function can be used by an IDE to support removal of broken
component links.
</p>
        </descr>
        <seealso>
          <link id="RedirectFixupReferences"/>
        </seealso>
      </element>
      <element name="RemoveFixups">
        <!-- Procedure -->
        <short>Removes <var>Instance</var> from the fixup list.</short>
        <descr>
          <var>RemoveFixups</var> removes all entries for component

          <var>Instance</var> from the list of unresolved references.a
</descr>
        <seealso>
          <link id="RedirectFixupReferences"/>
          <link id="RemoveFixupReferences"/>
        </seealso>
      </element>
      <element name="FindNestedComponent">
        <!-- Function -->
        <short>Finds the component with name path starting at the indicated root
component.</short>
        <descr>
          <var>FindNestedComponent</var> will descend through the list of owned
components (starting at 
          <var>Root</var>) and will return the component whose
name path matches 
          <var>NamePath</var>. As a path separator the characters .
(dot), - (dash) and &gt; (greater than) can be used
</descr>
        <seealso>
          <link id="GlobalFixupReferences"/>
        </seealso>
      </element>
      <element name="BeginGlobalLoading">
        <!-- Procedure -->
        <short>Not yet implemented</short>
        <descr/>
        <seealso/>
      </element>
      <element name="NotifyGlobalLoading">
        <!-- Procedure -->
        <short>Not yet implemented.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="EndGlobalLoading">
        <!-- Procedure -->
        <short>Not yet implemented.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="CollectionsEqual">
        <!-- Function -->
        <short>Returns <var>True</var> if two collections are equal.</short>
        <descr>
          <var>CollectionsEqual</var> is not yet implemented. It simply returns

          <var>False</var>
        </descr>
      </element>
      <element name="ObjectBinaryToText">
        <!-- Procedure -->
        <short>Converts an object stream from a binary to a text format.</short>
        <descr>
          <var>ObjectBinaryToText</var> reads an object stream in binary format from

          <var>Input</var> and writes the object stream in text format to

          <var>Output</var>. No components are instantiated during the process, 
this is a pure conversion routine.
</descr>
        <seealso>
          <link id="ObjectTextToBinary"/>
        </seealso>
      </element>
      <element name="ObjectTextToBinary">
        <!-- Procedure -->
        <short>Converts an object stream from a text to a binary format.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="ObjectResourceToText">
        <!-- Procedure -->
        <short>Converts an object stream from a (windows) resource to a text format.</short>
        <descr>
          <var>ObjectResourceToText</var> reads the resource header from the

          <var>Input</var> stream and then passes the streams to

          <link id="ObjectBinaryToText"/>
        </descr>
        <seealso>
          <link id="ObjectBinaryToText"/>
          <link id="ObjectTextToResource"/>
        </seealso>
      </element>
      <element name="ObjectTextToResource">
        <!-- Procedure -->
        <short>Converts an object stream from a text to a (windows) resource  format.</short>
        <descr>
          <p>
            <var>ObjectTextToResource</var> reads an object stream in text format from

            <var>Input</var> and writes a resource stream to 
            <var>Output</var>.
</p>
          <p>Note that for the current implementation of this method in Free Pascal, 
the output stream should support positioning. (e.g. it should not be a pipe)
</p>
        </descr>
        <seealso>
          <link id="ObjectBinaryToText"/>
          <link id="ObjectResourceToText"/>
        </seealso>
      </element>
      <element name="LineStart">
        <!-- Function -->
        <short>Finds the start of a line in <var>Buffer</var> before
<var>BufPos</var>.</short>
        <descr>
          <var>LineStart</var> reversely scans 
          <var>Buffer</var> starting at

          <var>BufPos</var> for a linefeed character. It returns a pointer at the
linefeed character.
</descr>
      </element>
      <element name="TPointerList">
        <short>Type for an Array of pointers.</short>
      </element>
      <element name="PPointerList">
        <short>Pointer to an array of pointers.</short>
      </element>
      <element name="THelpContext">
        <short>Range type to specify help contexts.</short>
      </element>
      <element name="THelptype">
        <short>Enumeration type specifying the kind of help requested.</short>
      </element>
      <element name="PStringItemList">
        <short>Pointer to a <link id="TStringItemList"/>.</short>
      </element>
      <element name="TBasicActionClass">
        <short>
          <link id="TBasicAction"/> class reference.</short>
      </element>
      <element name="TBAsicActionLinkClass">
        <short>
          <link id="TBasicActionLink"/> class reference.</short>
      </element>
      <element name="TListNotification">
        <short>Kind of list notification event.</short>
      </element>
      <element name="TListSortCompare">
        <short>Callback type for the list sort algorithm.</short>
      </element>
      <element name="TSeekOrigin">
        <short>Specifies the origin of the <link id="TStream.Seek"/> method.</short>
      </element>
      <element name="TSeekOrigin.soBeginning">
        <short>Offset is interpreted relative to the start of the stream.</short>
      </element>
      <element name="TSeekOrigin.SoEnd">
        <short>Offset is interpreted relative to the end of the stream.</short>
      </element>
      <element name="TSeekOrigin.soCurrent">
        <short>Offset is interpreted relative to the current position in the stream.</short>
      </element>
      <element name="TShortCut">
        <short>Enumeration type to identify shortcut key combinations.</short>
      </element>
      <element name="TStringListSortCompare">
        <short>Callback type used in stringlist compares.</short>
      </element>
      <element name="sysutils">
        <short>System routines</short>
      </element>
      <element name="types">
        <short>System types</short>
      </element>
      <element name="typinfo">
        <short>RTTI information</short>
      </element>
      <element name="rtlconsts">
        <short>Resource strings with messages</short>
      </element>
      <element name="TShiftStateEnum">
        <short>Keyboard/Mouse shift state enumerator</short>
      </element>
      <element name="TShiftStateEnum.ssShift">
        <short>Shift key pressed</short>
      </element>
      <element name="TShiftStateEnum.ssAlt">
        <short>Alt key pressed</short>
      </element>
      <element name="TShiftStateEnum.ssCtrl">
        <short>Ctrl key pressed</short>
      </element>
      <element name="TShiftStateEnum.ssLeft">
        <short>Left mouse button pressed.</short>
      </element>
      <element name="TShiftStateEnum.ssRight">
        <short>Right mouse button pressed.</short>
      </element>
      <element name="TShiftStateEnum.ssMiddle">
        <short>Middle mouse button pressed.</short>
      </element>
      <element name="TShiftStateEnum.ssDouble">
        <short>Double mouse click.</short>
      </element>
      <element name="TShiftStateEnum.ssMeta">
        <short>Meta key pressed.</short>
      </element>
      <element name="TShiftStateEnum.ssSuper">
        <short>Super key pressed.</short>
      </element>
      <element name="TShiftStateEnum.ssHyper">
        <short>Hyper key pressed.</short>
      </element>
      <element name="TShiftStateEnum.ssAltGr">
        <short>Alt-GR key pressed.</short>
      </element>
      <element name="TShiftStateEnum.ssCaps">
        <short>Caps lock key pressed</short>
      </element>
      <element name="TShiftStateEnum.ssNum">
        <short>Num lock key pressed</short>
      </element>
      <element name="TShiftStateEnum.ssScroll">
        <short>Scroll lock key pressed</short>
      </element>
      <element name="TShiftStateEnum.ssTriple">
        <short>Triple mouse click</short>
      </element>
      <element name="TShiftStateEnum.ssQuad">
        <short>Quadruple mouse click</short>
      </element>
      <element name="TShiftStateEnum.ssExtra1">
        <short>Extra key 1</short>
      </element>
      <element name="TShiftStateEnum.ssExtra2">
        <short>Extra key 2</short>
      </element>
      <element name="THelpType.htKeyword">
        <short>Help type: Keyword help</short>
      </element>
      <element name="THelpType.htContext">
        <short>Help type: Context ID help.</short>
      </element>
      <element name="TListNotification.lnAdded">
        <short>List change notification: Element added to the list.</short>
      </element>
      <element name="TListNotification.lnExtracted">
        <short>List change notification: Element extracted from the list.</short>
      </element>
      <element name="TListNotification.lnDeleted">
        <short>List change notification: Element deleted from the list.</short>
      </element>
      <element name="TList.Extract">
        <short>Remove the first occurrence of a pointer from the list.</short>
        <descr>
          <var>Extract</var> searched for an occurence of 
          <var>item</var>, and if a
match is found, the match is deleted from the list. If no match is found,
nothing is deleted. If 
          <var>Item</var> was found, the result is

          <var>Item</var>. If 
          <var>Item</var> was not found, the result is

          <var>Nil</var>. A 
          <var>lnExtracted</var> notification event is triggered if
an element is extracted from the list. 
</descr>
        <seealso>
          <link id="TList.Delete"/>
          <link id="TList.IndexOf"/>
          <link id="TList.Remove"/>
        </seealso>
      </element>
      <element name="TList.Assign">
        <short>Copy the contents of other lists.</short>
        <descr>
          <var>Assign</var> can be used to merge or assign lists It is an extended
version of the usual 
          <var>TPersistent.Assign</var> mechanism. The arguments

          <var>ListA</var> and 
          <var>ListB</var> are used as sources of pointers to 
add or remove elements from the current list, depending on the operation 

          <var>AOperation</var>. The available operations are documented in the 

          <link id="TListAssignOp"/> type.
</descr>
        <seealso>
          <link id="TList.Clear"/>
        </seealso>
      </element>
      <element name="TRecall">
        <short>Helper class for storing published properties</short>
        <descr>
          <p>
            <var>TRecall</var> is a helper class used to copy published 
properties of a class (the reference object) in another class
(the storage object). The reference object and storage object must be
assignable to each other. 
</p>
          <p>The <var>TRecall</var> can be used to store the state of a persistent class,
and restore it at a later time.
</p>
          <p>When a <var>TRecall</var> object is created, it gets passed a reference
instance and a storage instance. It immediatly stores the properties of
the reference object in the storage object. 
</p>
          <p>The <link id="TRecall.Store">Store</link> method can be called throughout
the lifetime of the reference object to update the stored properties.
</p>
          <p>When the <var>TRecall</var> instance is destroyed then the properties are
copied from the storage object to the reference object. The storage object
is freed automatically.
</p>
          <p>If the properties should not be copied back from the storage to the
reference object, the <link id="TRecall.Forget">Forget</link> can be called.
</p>
        </descr>
        <seealso>
          <link id="TRecall.Create"/>
          <link id="TRecall.Destroy"/>
          <link id="TRecall.Forget"/>
          <link id="TRecall.Store"/>
          <link id="TPersistent.Assign"/>
        </seealso>
      </element>
      <element name="TRecall.Create">
        <short>Creates a new instance of <var>TRecall</var>.</short>
        <descr>
          <var>Create</var> creates a new instance of 
          <var>TRecall</var> and
initializes the Reference and Storage instances. It calls 
          <link id="TRecall.Store">Store</link> to assign the reference object properties to
the storage instance.
</descr>
        <seealso>
          <link id="TRecall.Store"/>
          <link id="TRecall.Destroy"/>
        </seealso>
      </element>
      <element name="TRecall.Destroy">
        <short>Copies the stored properties to the reference object and destroys the
<var>TRecall</var> instance.</short>
        <descr>
          <var>Destroy</var> assigns the storage instance to the reference instance,
if the latter is still valid. After this, it frees the storage and calls the
inherited destroy.
</descr>
        <errors>
          <var>Destroy</var> does not check whether the 
          <link id="TRecall.Reference">reference</link> instance is still valid. If the
reference pointer was invalidated, call 
          <link id="TRecall.Forget"/> to clear
the reference instance.
</errors>
        <seealso>
          <link id="TRecall.Store"/>
          <link id="TRecall.Forget"/>
        </seealso>
      </element>
      <element name="TRecall.Store">
        <short>Assigns the reference instance to the storage instance.</short>
        <descr>
          <p>
            <var>Store</var> assigns the reference instance to the storage instance.
This will only work if the two classes can be assigned to each other.
</p>
          <p>This method can be used to refresh the storage.
</p>
        </descr>
        <errors>
          <var>Store</var> does not check whether the 
          <link id="TRecall.Reference">reference</link> instance is still valid. If the
reference pointer was invalidated, call 
          <link id="TRecall.Forget"/> to clear
the reference instance.
</errors>
        <seealso/>
      </element>
      <element name="TRecall.Forget">
        <short>Clear the reference property.</short>
        <descr>
          <p>
            <var>Forget</var> sets the 
            <link id="Reference">Reference</link> property to

            <var>Nil</var>. When the 
            <var>TRecall</var> instance is destroyed, the
reference instance will not be restored. 
</p>
          <p>Note that after a call to <var>Forget</var>, a call to <link id="TRecall.Store">Store</link> has no effect.
</p>
        </descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TRecall.Reference"/>
          <link id="TRecall.Store"/>
          <link id="TRecall.Destroy"/>
        </seealso>
      </element>
      <element name="TRecall.Reference">
        <short>The reference object.</short>
        <descr>
          <var>Reference</var> is the instance of the reference object. Do not free
the reference directly. 
Call 
          <link id="TRecall.Forget">Forget</link> to clear the reference and then
free the reference object.
</descr>
        <seealso>
          <link id="TRecall.Forget"/>
        </seealso>
      </element>
      <element name="TCollectionNotification">
        <short>Collection change notifcation enumeration.</short>
        <descr>
          <var>TCollectionNotification</var> is used in the 
          <link id="TCollection"/>
class to send notifications about changes to the collection.
</descr>
      </element>
      <element name="TCollectionNotification.cnAdded">
        <short>An item is added to the collection.</short>
      </element>
      <element name="TCollectionNotification.cnExtracting">
        <short>An item is extracted from the collection.</short>
      </element>
      <element name="TCollectionNotification.cnDeleting">
        <short>An item is deleted from the collection.</short>
      </element>
      <element name="TCollection.Owner">
        <short>Owner of the collection.</short>
        <descr>
          <var>Owner</var> returns a reference to the owner of the collection. This
property is required by the object inspector to be able to show the
collection.
</descr>
      </element>
      <element name="TCollection.Delete">
        <short>Delete an item from the collection.</short>
        <descr>
          <var>Delete</var> deletes the item at (zero based) position 

          <var>Index</var> from the collection. This will result in a

          <var>cnDeleted</var> notification.
</descr>
        <errors>If an invalid index is specified, an <var>EListError</var> exception is raised.
</errors>
        <seealso>
          <link id="TCollection.Items"/>
          <link id="TCollection.Insert"/>
          <link id="TCollection.Clear"/>
        </seealso>
      </element>
      <element name="TCollection.Insert">
        <short>Insert an item in the collection.</short>
        <descr>
          <p>
            <var>Insert</var> creates a new item instance and inserts it in 
the collection at position 
            <var>Index</var>, and returns the new instance.
</p>
          <p>In contrast, <link id="TCollection.Add"/> adds a new item at the end.
</p>
        </descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TCollection.Add"/>
          <link id="TCollection.Delete"/>
          <link id="TCollection.Items"/>
        </seealso>
      </element>
      <element name="TOwnedCollection">
        <short>
          <link id="#rtl.classes.TCollection">TCollection</link> descendent
which maintains owner information.</short>
        <descr>
          <var>TOwnedCollection</var> automatically maintains owner information, so it
can be displayed in an IDE. Collections that should be displayed in an
IDE should descend from 
          <var>TOwnedCollection</var> or must implement a

          <var>GetOwner</var> function.
</descr>
        <seealso>
          <link id="TCollection"/>
        </seealso>
      </element>
      <element name="TOwnedCollection.Create">
        <short>Create a new <var>TOwnerCollection</var> instance.</short>
        <descr>
          <var>Create</var> creates a new instance of 
          <var>TOwnedCollection</var> and
stores the 
          <var>AOwner</var> references. It will the value returned in the 
          <link id="TCollection.Owner"/> property of the collection. The

          <var>ItemClass</var> class reference is passed on to the inherited
constructor, and will be used to create new instances in the 
          <link id="TCollection.Insert">Insert</link> and 
          <link id="TCollection.Add">Add</link> methods.
</descr>
        <seealso>
          <link id="TCollection.Create"/>
          <link id="TCollection.Owner"/>
        </seealso>
      </element>
      <element name="TOwnerStream">
        <short>Stream which uses a second stream as a source</short>
        <descr>
          <var>TOwnerStream</var> can be used when creating stream chains 
such as when using encryption and compression streams. It keeps a reference
to the source stream and will automatically free the source stream when
ready (if the 
          <link id="TOwnerStream.SourceOwner">SourceOwner</link>
property is set to 
          <var>True</var>).
</descr>
        <seealso>
          <link id="TStream"/>
          <link id="TOwnerStream.Source"/>
          <link id="TOwnerStream.SourceOwner"/>
        </seealso>
      </element>
      <element name="TOwnerStream.Create">
        <short>Create a new instance of <var>TOwnerStream</var>. </short>
        <descr>
          <var>Create</var> instantiates a new instance of 
          <var>TOwnerStream</var> and
stores the reference to 
          <var>AStream</var>. If 
          <var>SourceOwner</var> is

          <var>True</var>, the soure stream will also be freed when the instance is
destroyed.
</descr>
        <seealso>
          <link id="TOwnerStream.Destroy"/>
          <link id="TOwnerStream.Source"/>
          <link id="TOwnerStream.SourceOwner"/>
        </seealso>
      </element>
      <element name="TOwnerStream.Destroy">
        <short>Destroys the <var>TOwnerStream</var> instance and the source stream.</short>
        <descr>
          <var>Destroy</var> frees the source stream if the 
          <var>SourceOwner</var>
property is 
          <var>True</var>.
</descr>
        <errors/>
        <seealso>
          <link id="TOwnerStream.Create"/>
          <link id="TOwnerStream.Source"/>
          <link id="TOwnerStream.SourceOwner"/>
        </seealso>
      </element>
      <element name="TOwnerStream.Source">
        <short>Reference to the source stream.</short>
        <descr>
          <p>
            <var>Source</var> is the source stream. It should be used by descendent
streams to access the source stream to read from or write to.
</p>
          <p>Do not free the <var>Source</var> reference directly if
<var>SourceOwner</var> is <var>True</var>. In that case the owner
stream instance will free the source stream itself.
</p>
        </descr>
        <seealso>
          <link id="TOwnerStream.Create"/>
        </seealso>
      </element>
      <element name="TOwnerStream.SourceOwner">
        <short>Indicates whether the ownerstream owns it's source</short>
        <descr>
          <var>SourceOwner</var> indicates whether the 
          <var>TOwnerStream</var> owns
it's 
          <var>Source</var> stream or not. If this property is 
          <var>True</var>
then the 
          <var>Source</var> stream is freed when the 
          <var>TOwnerStream</var>
instance is freed.
</descr>
        <seealso>
          <link id="TOwnerStream.Source"/>
          <link id="TOwnerStream.Destroy"/>
        </seealso>
      </element>
      <element name="THandleStream.Seek">
        <short>Overrides the Seek method.</short>
        <descr>
          <var>seek</var> uses the 
          <link id="#rtl.SysUtils.FileSeek">FileSeek</link>
method to position the stream on the desired position. Note that handle
stream descendents (notably pipes) can override the method to prevent the
seek.
</descr>
      </element>
      <element name="TCustomMemoryStream.GetSize">
        <short>return the size of the stream.</short>
        <descr>
          <var>GetSize</var> returns the size of the reseved memory. It should not be
used directly.
</descr>
        <seealso>
          <link id="TStream.Size"/>
        </seealso>
      </element>
      <element name="TValueType.vaUTF8String">
        <short>UTF8 encoded unicode string.</short>
      </element>
      <element name="TBinaryObjectReader.NextValue">
        <short>Return the type of the next value.</short>
        <descr>
          <p>
            <var>NextValue</var> returns the type of the next value in a binary stream,
but does not read the value.
</p>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.ReadValue">
        <short>Read the next value in the stream</short>
        <descr>
          <p>
            <var>NextValue</var> reads the next value in a binary stream and returns 
the type of the read value.
</p>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.BeginRootComponent">
        <short>Start reading the root component.</short>
        <descr>
          <p>
            <var>BeginRootComponent</var> starts reading the root component in a binary
stream.
</p>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.BeginComponent">
        <short>Start reading a component.</short>
        <descr>
          <p/>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.BeginProperty">
        <short>Start reading a property.</short>
        <descr>
          <p/>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.ReadBinary">
        <short>Start reading a binary value.</short>
        <descr>
          <p>
            <var>ReadBinary</var> reads a binary valye from a binary stream.
</p>
          <p>This method is simply the implementation for a binary stream  of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.ReadFloat">
        <short>Read a float value</short>
        <descr>
          <p>
            <var>ReadFloat</var> reads a float value from a binary stream.
</p>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.ReadSingle">
        <short>Read a single-size float value</short>
        <descr>
          <p>
            <var>ReadSingle</var> reads a single-sized float value from a binary stream.
</p>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.ReadDate">
        <short>Read a date.</short>
        <descr>
          <p>
            <var>ReadDate</var> reads a date value from a binary stream.
</p>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.ReadIdent">
        <short>Read an identifier</short>
        <descr>
          <p>
            <var>ReadIdent</var> reads an identifier from a binary stream.
</p>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.ReadInt8">
        <short>Read an 8-bits integer.</short>
        <descr>
          <p>
            <var>Read8Int</var> reads an 8-bits signed integer from a binary stream.
</p>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.ReadInt16">
        <short>Read a 16-bits integer.</short>
        <descr>
          <p>
            <var>Read16Int</var> reads a 16-bits signed integer from a binary stream.
</p>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.ReadInt32">
        <short>Read a 32-bits integer.</short>
        <descr>
          <p>
            <var>Read32Int</var> reads a 32-bits signed integer from a binary stream.
</p>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.ReadInt64">
        <short>Read a 64-bits integer.</short>
        <descr>
          <p>
            <var>Read64Int</var> reads a 64-bits signed integer from a binary stream.
</p>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.ReadSet">
        <short>Read a set</short>
        <descr>
          <p>
            <var>ReadSet</var> reads a set from a binary stream.
</p>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.ReadStr">
        <short>Read a short string</short>
        <descr>
          <p>
            <var>ReadStr</var> reads a short string from a binary stream.
</p>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.ReadString">
        <short>Read a string</short>
        <descr>
          <p>
            <var>ReadStr</var> reads a string of type 
            <var>StringType</var> from a binary stream.
</p>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.SkipComponent">
        <short>Skip a component's data</short>
        <descr>
          <p>
            <var>SkipComponent</var> skips the data of a component in a binary stream.
</p>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>.
</p>
        </descr>
      </element>
      <element name="TBinaryObjectReader.SkipValue">
        <short>Skip a value's data</short>
        <descr>
          <p>
            <var>SkipComponent</var> skips the data of the next value in a binary stream.
</p>
          <p>This method is simply the implementation for a binary stream of the abstract method introduced
in <link id="TAbstractObjectReader"/>
          </p>
        </descr>
      </element>
      <element name="TSetMethodPropertyEvent">
        <short>Callback for the <link id="TReader.OnSetMethodProperty"/> event.</short>
        <descr>
          <var>TSetMethodPropertyEvent</var> is the prototype for the 
          <link id="TReader.OnSetMethodProperty"/> event. 
          <var>Reader</var> is the sender of
the event, 
          <var>Instance</var> is the instance that is being streamed.

          <var>PropInfo</var> is a pointer to the RTTI information for the property
being read, and 
          <var>TheMethodName</var> is the name of the method that 
the property should be set to. 
          <var>Handled</var> should be set to

          <var>True</var> if the handler set the property succesfully. 
</descr>
      </element>
      <element name="TPropertyNotFoundEvent">
        <short>Callback for the <link id="TReader.OnPropertyNotFound"/> event.</short>
        <descr>
          <var>TPropertyNotFoundEvent</var> is the prototype for the 
          <link id="TReader.OnPropertyNotFound"/> event. 
          <var>Reader</var> is the sender of
the event, 
          <var>Instance</var> is the instance that is being streamed.

          <var>PropInfo</var> is a pointer to the RTTI information for the property
being read. 
          <var>Handled</var> should be set to 
          <var>True</var> if
the handler redirected the unknown property succesfully, and 
          <var>Skip</var>
should be set to 
          <var>True</var> if the value should be skipped.

          <var>IsPath</var> determines whether the property refers to a sub-property.
</descr>
        <seealso>
          <link id="TReader.OnPropertyNotFound"/>
        </seealso>
      </element>
      <element name="TReadWriteStringPropertyEvent">
        <short>Callback for the <link id="TReader.OnReadStringProperty"/> event handler</short>
        <descr>
          <var>TReadWriteStringPropertyEvent</var> is the prototype for the 
          <link id="TReader.OnReadStringProperty"/> event handler.  
          <var>Reader</var> is the
sender of
the event, 
          <var>Instance</var> is the instance that is being streamed.

          <var>PropInfo</var> is a pointer to the RTTI information for the property
being read. 
          <var>Content</var> is the string as it was read from the stream.
</descr>
        <seealso>
          <link id="TReader.OnReadStringProperty"/>
        </seealso>
      </element>
      <element name="TReader.OnPropertyNotFound">
        <short>Handler for treating missing properties.</short>
        <descr>
          <p>
            <var>OnPropertyNotFound</var> can be used to take appropriate action when a
property is read from a stream and no such property is found in the RTTI
information of the Instance that is being read from the stream. It can be
set at runtime, or at designtime by an IDE.
</p>
          <p>For more information about the meaning of the various arguments to the event
handler, see <link id="TPropertyNotFoundEvent"/>.
</p>
        </descr>
        <seealso>
          <link id="TPropertyNotFoundEvent"/>
          <link id="TReader.OnSetMethodProperty"/>
          <link id="TReader.OnReadStringProperty"/>
        </seealso>
      </element>
      <element name="TReader.OnSetMethodProperty">
        <short>Handler for setting method properties.</short>
        <descr>
          <var>OnSetMethodProperty</var> can be set to handle the setting of method
properties. This handler can be used by an IDE to prevent methods from
actually being assigned when an object is being streamed in the designer.
</descr>
        <seealso>
          <link id="TReader.OnReadStringProperty"/>
          <link id="TReader.OnPropertyNotFound"/>
        </seealso>
      </element>
      <element name="TReader.OnReadStringProperty">
        <short>Handler for translating strings when read from the stream.</short>
        <descr>
          <var>OnReadStringProperty</var> is called whenever a string property is read
from the stream. It can be used e.g. by a translation mechanism to translate the
strings on the fly, when a form is loaded. See 
          <link id="TReadWriteStringPropertyEvent"/> for a description of the various
parameters.
</descr>
        <seealso>
          <link id="TReader.OnPropertyNotFound"/>
          <link id="TReader.OnSetMethodProperty"/>
          <link id="TReadWriteStringPropertyEvent"/>
        </seealso>
      </element>
      <element name="TWriteMethodPropertyEvent">
        <short>Callback for the <link id="TWriter.OnWriteMethodProperty"/> event.</short>
        <descr>
          <var>TWriteMethodPropertyEvent</var> is the prototype for the 
          <link id="TWriter.OnWriteMethodProperty"/> event. 
          <var>Writer</var> is the sender of
the event, 
          <var>Instance</var> is the instance that is being streamed.

          <var>PropInfo</var> is a pointer to the RTTI information for the property
being written, and 
          <var>MethodValue</var> is the value of the method that
the property was set to. 
          <var>DefMethodCodeValue</var> is set to the default
value of the property (Nil or the parent value).

          <var>Handled</var> should be set to 
          <var>True</var> if the handler set the property succesfully.
</descr>
        <seealso>
          <link id="TWriter.OnWriteMethodProperty"/>
        </seealso>
      </element>
      <element name="TWriter.OnWriteMethodProperty">
        <short>Handler from writing method properties.</short>
        <descr>
          <var>OnWriteMethodProperty</var> can be set by an IDE or some streaming
mechanism which handles dummy values for method properties; It can be used
to write a real value to the stream which will be interpreted correctly when
the stream is read. See 
          <link id="TWriteMethodPropertyEvent"/> for a description of the arguments.
</descr>
        <seealso>
          <link id="TWriteMethodPropertyEvent"/>
          <link id="TReader.OnSetMethodProperty"/>
        </seealso>
      </element>
      <element name="TWriter.OnWriteStringProperty">
        <short>Event handler for translating strings written to stream.</short>
        <descr>
          <var>OnWriteStringProperty</var> is called whenever a string property is
written to the stream. It can be used e.g. by a translation mechanism to 
translate the strings on the fly, when a form is written. See 
          <link id="TReadWriteStringPropertyEvent"/> for a description of the various
parameters.
</descr>
        <seealso>
          <link id="TReader.OnPropertyNotFound"/>
          <link id="TReader.OnSetMethodProperty"/>
          <link id="TReadWriteStringPropertyEvent"/>
        </seealso>
      </element>
      <element name="EThreadDestroyCalled">
        <short>Exception raised when a thread is destroyed illegally.</short>
      </element>
      <element name="TSynchronizeProcVar">
        <short>Synchronize callback type</short>
      </element>
      <element name="TThread.FatalException">
        <short>Exception that occured during thread execution</short>
        <descr>
          <var>FatalException</var> contains the exception that occurred during the
thread's execution.
</descr>
      </element>
      <element name="TComponent.BeforeDestruction">
        <short>Overrides standard BeforeDestruction.</short>
        <descr>
          <var>BeforeDestruction</var> is overridden by 
          <var>TComponent</var> to set
the 
          <var>csDestroying</var> flag in 
          <link id="ComponentState"/>
        </descr>
        <seealso>
          <link id="ComponentState"/>
        </seealso>
      </element>
      <element name="TComponent.ExecuteAction">
        <short>Standard action execution method.</short>
        <descr>
          <var>ExecuteAction</var> checks whether 
          <var>Action</var> handles the
current component, and if yes, calls the 
          <var>ExecuteAction</var> method,
passing itself as a parameter. The function returns 
          <var>True</var> if the
action handles the current component.
</descr>
        <seealso>
          <link id="TBasicAction"/>
          <link id="TBasicAction.ExecuteAction"/>
          <link id="TBasicAction.HandlesTarget"/>
          <link id="UpdateAction"/>
        </seealso>
      </element>
      <element name="TComponent.RemoveFreeNotification">
        <short>Remove a component from the Free Notification list.</short>
        <descr>
          <var>RemoveFreeNotification</var> removes 
          <var>AComponent</var> from the
freenotification list. 
</descr>
        <seealso>
          <link id="FreeNotification"/>
        </seealso>
      </element>
      <element name="TComponent.UpdateAction">
        <short>Updates the state of an action.</short>
        <descr>
          <var>UpdateAction</var> checks whether 
          <var>Action</var> handles the
current component, and if yes, calls the 
          <var>UpdateTarget</var> method,
passing itself as a parameter. The function returns 
          <var>True</var> if the
action handles the current component.
</descr>
        <seealso>
          <link id="TBasicAction"/>
          <link id="TBasicAction.UpdateTarget"/>
          <link id="TBasicAction.HandlesTarget"/>
          <link id="ExecuteAction"/>
        </seealso>
      </element>
      <element name="TDataModule">
        <short>Container for non-visual components.</short>
        <descr>
          <p>
            <var>TDataModule</var> is a container for non-visual objects which can be
used in an IDE to group non-visual objects which can be used by various
other containers (forms) in a project. Notably, data access components are
typically stored on a datamodule. Web components and services can also be 
implemented as descendents of datamodules.
</p>
          <p>
            <var>TDataModule</var> introduces some events which make it easier to
program, and provides the needed streaming capabilities for persistent
storage.
</p>
          <p>An IDE will typically allow to create a descendent of <var>TDataModule</var>
which contains non-visual components in it's published property list.
</p>
        </descr>
        <seealso>
          <link id="TDataModule.OnCreate"/>
        </seealso>
      </element>
      <element name="TDataModule.Create">
        <short>Create a new instance of a <var>TDataModule</var>.</short>
        <descr>
          <var>Create</var> creates a new instance of the 
          <var>TDatamodule</var>
and calls 
          <link id="TDatamodule.CreateNew"/>. After that it reads the 
published properties from a stream using 
          <link id="InitInheritedComponent"/>
if a descendent class is instantiated. If the 
          <link id="TDataModule.OldCreateOrder">OldCreateOrder</link>
property is 
          <var>True</var>, the 
          <link id="OnCreate"/> event is called.
</descr>
        <errors>An exception can be raised during the streaming operation.
</errors>
        <seealso>
          <link id="TDataModule.CreateNew"/>
        </seealso>
      </element>
      <element name="TDataModule.CreateNew">
        <short/>
        <descr>
          <var>CreateNew</var> creates a new instance of the class, but bypasses the
streaming mechanism. The 
          <var>CreateMode</var> parameter (by default zero)
is not used in 
          <var>TDataModule</var>. If the 
          <link id="AddDataModule"/>
handler is set, then it is called, with the newly created instance as an
argument.
</descr>
        <seealso>
          <link id="TDataModule.Create"/>
          <link id="AddDataModule"/>
          <link id="TDataModule.OnCreate"/>
        </seealso>
      </element>
      <element name="TDataModule.Destroy">
        <short>Destroys the <var>TDataModule</var> instance.</short>
        <descr>
          <p>
            <var>Destroy</var> destroys the 
            <var>TDataModule</var> instance. If the

            <link id="TDataModule.OldCreateOrder">OldCreateOrder</link> property is

            <var>True</var> the 
            <link id="TDataModule.OnDestroy">OnDestroy</link> event
handler is called prior to destroying the data module.
</p>
          <p>Before calling the inherited destroy, the <link id="RemoveDataModule"/>
handler is called if it is set, and <var>Self</var> is passed as a
parameter.
</p>
        </descr>
        <errors>An event can be raised during the <var>OnDestroy</var> event handler.
</errors>
        <seealso>
          <link id="TDataModule.OnDestroy"/>
          <link id="RemoveDataModule"/>
        </seealso>
      </element>
      <element name="TDataModule.AfterConstruction">
        <short>Overrides standard <link id="rtl.objpas.TObject">TObject</link> behaviour.</short>
        <descr>
          <var>AfterConstruction</var> calls the 
          <link id="TDataModule.OnCreate">OnCreate</link> handler if the 
          <link id="TDataModule.OldCreateOrder">OldCreateOrder</link> property is

          <var>False</var>.
</descr>
        <seealso>
          <link id="TDataModule.OldCreateOrder"/>
          <link id="TDataModule.OnCreate"/>
        </seealso>
      </element>
      <element name="TDataModule.BeforeDestruction">
        <short/>
        <descr>
          <var>BeforeDestruction</var> calls the 
          <link id="TDataModule.OnCreate">OnDestroy</link> 
handler if the 
          <link id="TDataModule.OldCreateOrder">OldCreateOrder</link> property is

          <var>False</var>.
</descr>
        <seealso>
          <link id="TDataModule.OldCreateOrder"/>
          <link id="TDataModule.OnDestroy"/>
        </seealso>
      </element>
      <element name="TDataModule.DesignOffset">
        <short>Position property needed for manipulation in an IDE.</short>
        <descr>
          <var>DesignOffset</var> is the position of the datamodule when displayed in
an IDE. It is streamed to the form file, and should not be used at run-time.
</descr>
        <seealso>
          <link id="TDataModule.DesignSize"/>
        </seealso>
      </element>
      <element name="TDataModule.DesignSize">
        <short>Size property needed for manipulation in an IDE.</short>
        <descr>
          <var>DesignSize</var> is the size of the datamodule when displayed in
an IDE. It is streamed to the form file, and should not be used at run-time.
</descr>
        <seealso>
          <link id="TDataModule.DesignOffset"/>
        </seealso>
      </element>
      <element name="TDataModule.OnCreate">
        <short>Event handler, called when the datamodule is created.</short>
        <descr>The <var>OnCreate</var> event is triggered when the datamodule is created
and streamed. The exact moment of triggering is dependent on the value of
the <link id="TDataModule.OldCreateOrder">OldCreateOrder</link> property.
</descr>
        <seealso>
          <link id="TDataModule.Create"/>
          <link id="TDataModule.CreateNew"/>
          <link id="TDataModule.OldCreateOrder"/>
        </seealso>
      </element>
      <element name="TDataModule.OnDestroy">
        <short>Event handler, called when the datamodule is destroyed.</short>
        <descr>The <var>OnDestroy</var> event is triggered when the datamodule is destroyed
The exact moment of triggering is dependent on the value of the 
<link id="TDataModule.OldCreateOrder">OldCreateOrder</link> property.
</descr>
        <seealso>
          <link id="TDataModule.Destroy"/>
          <link id="TDataModule.OnCreate"/>
          <link id="TDataModule.Create"/>
          <link id="TDataModule.CreateNew"/>
          <link id="TDataModule.OldCreateOrder"/>
        </seealso>
      </element>
      <element name="TDataModule.OldCreateOrder">
        <short>Determines when <var>OnCreate</var> and <var>OnDestroy</var> are
triggered.</short>
        <descr>
          <p>
            <var>OldCreateOrder</var> determines when exactly the 
            <link id="TDataModule.OnCreate">OnCreate</link> and 
            <link id="TDataModule.OnDestroy">OnDestroy</link> event handlers are called.
</p>
          <p>If set to <var>True</var>, then the <var>OnCreate</var> event handler is called
after the data module was streamed. If it is set to <var>False</var>, then
the handler is called prior to the streaming process.
</p>
          <p>If set to <var>True</var>, then the <var>OnDestroy</var> event handler is called
before the data module is removed from the streaming system. If it is set to <var>False</var>, then
the handler is called after the data module was removed from the streaming process.
</p>
        </descr>
        <seealso>
          <link id="TDataModule.OnDestroy"/>
          <link id="TDataModule.OnCreate"/>
          <link id="TDataModule.Destroy"/>
          <link id="TDataModule.Create"/>
          <link id="TDataModule.CreateNew"/>
          <link id="TDataModule.OldCreateOrder"/>
        </seealso>
      </element>
      <element name="AddDataModule">
        <short>Handler called when a new <link id="#rtl.classes.TDataModule">TDataModule</link> instance is created.</short>
        <descr>
          <var>AddDataModule</var> can be set by an IDE or a streaming mechanism to
receive notification when a new instance of a 
          <link id="TDataModule"/>
descendent is created.
</descr>
        <seealso>
          <link id="RemoveDataModule"/>
          <link id="TDataModule"/>
        </seealso>
      </element>
      <element name="RemoveDataModule">
        <short>Handler called when a <link id="#rtl.classes.TDataModule">TDataModule</link> instance is freed.</short>
        <descr>
          <var>RemoveDataModule</var> can be set by an IDE or a streaming mechanism to
receive notification when an instance of a 
          <link id="TDataModule"/>
descendent is freed.
</descr>
        <seealso>
          <link id="AddDataModule"/>
          <link id="TDataModule"/>
        </seealso>
      </element>
      <element name="ApplicationHandleException">
        <short>Handler for exceptions when a <link id="#rtl.classes.TDataModule">TDataModule</link> streaming error occurs.</short>
        <descr>
          <var>ApplicationHandleException</var> can be set by an application object to
handle any exceptions that may occur when a 
          <link id="TDataModule"/> is
created.
</descr>
        <seealso>
          <link id="TDataModule"/>
        </seealso>
      </element>
      <element name="ApplicationShowException">
        <short>Unused.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="CheckSynchronize">
        <short>Check whether there are any synchronize calls in the synchronize queue.</short>
        <descr>
          <var>CheckSynchronize</var> should be called regularly by the main application
thread to handle any 
          <link id="TThread.synchronize"/> calls that may be waiting for
execution by the main thread.
</descr>
        <seealso>
          <link id="TThread.synchronize"/>
        </seealso>
      </element>
      <element name="WakeMainThread">
        <short>Handler which is called if a thread wants to synchronize with the main application thread.</short>
        <descr>
          <var>WakeMainThread</var> is called by the 
          <link id="TThread.synchronize"/> call.
It should alert the main program thread that a thread is waiting for
synchronization. The call is executed by the thread, and should therefore
NOT synchronize the thread, but should somehow signal the main thread that a
thread is waiting for synchronization. For example, by sending a message.
</descr>
        <seealso>
          <link id="CheckSynchronize"/>
          <link id="TThread.synchronize"/>
        </seealso>
      </element>
      <element name="StartClassGroup">
        <short>Start new class group.</short>
        <descr>
          <p>
            <var>StartClassGroup</var> starts a new class group and adds 
            <var>AClass</var> to
it.
</p>
          <p>The class registration and streaming mechanism allows to organize the classes in
groups. This allows an IDE to form groups of classes, which can be enabled
or disabled. It is not needed at Run-Time.
</p>
        </descr>
        <seealso>
          <link id="GroupDescendentsWith"/>
          <link id="ActivateClassGroup"/>
          <link id="ClassGroupOf"/>
        </seealso>
      </element>
      <element name="GroupDescendentsWith">
        <short>Add class to the group of another class.</short>
        <descr>
          <p>
            <var>GroupDescendentsWith</var> adds 
            <var>AClass</var> to the group that

            <var>AClassGroup</var> belongs to. If 
            <var>AClassGroup</var> belongs to more
than 1 group, then it is added to the group which contains the nearest
ancestor.
</p>
          <p>The class registration and streaming mechanism allows to organize the classes in
groups. This allows an IDE to form groups of classes, which can be enabled
or disabled. It is not needed at Run-Time.
</p>
        </descr>
        <errors/>
        <seealso>
          <link id="StartClassGroup"/>
          <link id="ActivateClassGroup"/>
          <link id="ClassGroupOf"/>
        </seealso>
      </element>
      <element name="ActivateClassGroup">
        <short>Activates a class group</short>
        <descr>
          <p>
            <var>ActivateClassGroup</var> activates the group of classes to which

            <var>AClass</var> belongs. The function returns the class that was last used
to activate the class group.
</p>
          <p>The class registration and streaming mechanism allows to organize the classes in
groups. This allows an IDE to form groups of classes, which can be enabled
or disabled. It is not needed at Run-Time.
</p>
        </descr>
        <errors>If <var>AClass</var> does not belong to a class group, an exception is
raised.
</errors>
        <seealso>
          <link id="StartClassGroup"/>
          <link id="GroupDescendentsWith"/>
          <link id="ClassGroupOf"/>
        </seealso>
      </element>
      <element name="ClassGroupOf">
        <short>Returns the class group to which an instance or class belongs</short>
        <descr>
          <var>ClassGroupOf</var> returns the class group to which 
          <var>AClass</var>
or 
          <var>Instance</var> belongs.
</descr>
        <errors>The result is <var>Nil</var> if no matching class group is found.
</errors>
        <seealso>
          <link id="StartClassGroup"/>
          <link id="ActivateClassGroup"/>
          <link id="GroupDescendentsWith"/>
        </seealso>
      </element>
      <element name="TInitComponentHandler">
        <short>Callback type for <link id="rtl.classes.RegisterInitComponentHandler">RegisterInitComponentHandler</link>
        </short>
        <descr>
          <var>TInitComponentHandler</var> is a callback type. It is used in the

          <link>InitInheritedComponent</link> call to initialize a component.
Callbacks of this type are registered with the 
          <link id="RegisterInitComponentHandler"/> call.
</descr>
      </element>
      <element name="RegisterFindGlobalComponentProc">
        <short>Register a component searching handler</short>
        <descr>
          <var>RegisterFindGlobalComponentProc</var> registers a global component
search callback 
          <var>AFindGlobalComponent</var>. When 
          <link id="FindGlobalComponent"/> is called, then this callback will be used to
search for the component.
</descr>
        <errors>None.
</errors>
        <seealso>
          <link id="FindGlobalComponent"/>
          <link id="UnRegisterFindGlobalComponentProc"/>
        </seealso>
      </element>
      <element name="UnregisterFindGlobalComponentProc">
        <short>Remove a previously registered component searching handler.</short>
        <descr>
          <var>UnRegisterFindGlobalComponentProc</var> unregisters the previously
registered global component search callback 
          <var>AFindGlobalComponent</var>. 
After this call, when 
          <link id="FindGlobalComponent"/> is called, then this 
callback will be no longer be used to search for the component.
</descr>
        <errors>None.
</errors>
        <seealso>
          <link id="FindGlobalComponent"/>
          <link id="RegisterFindGlobalComponentProc"/>
        </seealso>
      </element>
      <element name="RegisterInitComponentHandler">
        <short>Register a component initialization handler</short>
        <descr>
          <var>RegisterInitComponentHandler</var> registers a component initialization
handler 
          <var>Handler</var> for the component 
          <var>ComponentClass</var>. This
handler will be used to initialize descendents of

          <var>ComponentClass</var> in the 
          <link id="InitInheritedComponent"/> call. 
</descr>
        <seealso>
          <link id="InitInheritedComponent"/>
          <link id="TInitComponentHandler"/>
        </seealso>
      </element>
      <element name="BinToHex">
        <short>Convert a binary buffer to a hexadecimal string</short>
        <descr>
          <p>
            <var>BinToHex</var> converts the byte values in 
            <var>BinValue</var> 
to a string consisting of 2-charachter hexadecimal strings in

            <var>HexValue</var>.

            <var>BufSize</var> specifies the length of 
            <var>BinValue</var>, which means
that 
            <var>HexValue</var> must have size 
            <var>2*BufSize</var>.
</p>
          <p>For example a buffer containing the byte values 255 and 0 will be converted to
FF00.
</p>
        </descr>
        <errors>No length checking is done, so if an invalid size is specified, an exception
may follow.
</errors>
        <seealso>
          <link id="HexToBin"/>
        </seealso>
      </element>
      <element name="HexToBin">
        <short>Convert a hexadecimal string to a binary buffer</short>
        <descr>
          <var>HexToBin</var> scans the hexadecimal string representation in

          <var>HexValue</var> and transforms every 2 character hexadecimal 
number to a byte and stores it in 
          <var>BinValue</var>. The buffer size is
the size of the binary buffer. Scanning will stop if the size of the binary
buffer is reached or when an invalid character is encountered. The return
value is the number of stored bytes.
</descr>
        <errors>No length checking is done, so if an invalid size is specified, an exception
may follow.
</errors>
        <seealso>
          <link id="BinToHex"/>
        </seealso>
      </element>
      <element name="TSmallPoint.x">
        <short>X coordinate</short>
      </element>
      <element name="TSmallPoint.y">
        <short>Y coordinate</short>
      </element>
      <element name="TLeftRight">
        <short>Subrange type based on <link id="#rtl.classes.TAlignment">TAlignment</link>
        </short>
        <descr>
          <var>TLeftRight</var> is a subrange type based on the 
          <link id="TAlignment"/> enumerated type.
It contains only the left and right alignment constants.
</descr>
        <seealso>
          <link id="TAlignment"/>
        </seealso>
      </element>
      <element name="TBiDiMode">
        <short>BIDI description</short>
        <descr>
          <var>TBiDiMode</var> describes bi-directional support for displaying texts.
</descr>
      </element>
      <element name="TBiDiMode.bdLeftToRight">
        <short>Texts read from left to right.</short>
      </element>
      <element name="TBiDiMode.bdRightToLeft">
        <short>Texts read from right to left.</short>
      </element>
      <element name="TBiDiMode.bdRightToLeftNoAlign">
        <short>Texts read from right to left, but not right-aligned</short>
      </element>
      <element name="TBiDiMode.bdRightToLeftReadingOnly">
        <short>Texts read from right to left</short>
      </element>
      <element name="TListCallback">
        <short>Method callback type for <link id="#rtl.classes.TFPList.ForEachCall">TFPList.ForEachCall</link>
        </short>
        <descr>
          <var>TListCallback</var> is the method callback prototype for the function that is passed to the

          <link id="TFPList.ForEachCall"/> call. The 
          <var>data</var> argument will be filled with 
all the pointers in the list (one per call) and the 
          <var>arg</var> argument is the 

          <var>Arg</var> argument passed to the 
          <var>ForEachCall</var> call.
</descr>
        <seealso>
          <link id="TFPList.ForEachCall"/>
          <link id="TListStaticCallback"/>
        </seealso>
      </element>
      <element name="TListCallback.data">
        <short>Data pointer from the list.</short>
      </element>
      <element name="TListCallback.arg">
        <short>Parameter passed to the <var>ForEachCall</var> call.</short>
      </element>
      <element name="TListStaticCallback">
        <short>Static method callback type  for <link id="#rtl.classes.TFPList.ForEachCall">TFPList.ForEachCall</link>
        </short>
        <descr>
          <var>TListCallback</var> is the procedurald callback prototype for the function that is passed to the

          <link id="TFPList.ForEachCall"/> call. The 
          <var>data</var> argument will be filled with 
all the pointers in the list (one per call) and the 
          <var>arg</var> argument is the 

          <var>Arg</var> argument passed to the 
          <var>ForEachCall</var> call.
</descr>
        <seealso>
          <link id="TFPList.ForEachCall"/>
          <link id="TListCallback"/>
        </seealso>
      </element>
      <element name="TFPList.ForEachCall">
        <short>Call a procedure or method for each pointer in the list.</short>
        <descr>
          <var>ForEachCall</var> iterates over all pointers in the list and calls 

          <var>proc2call</var>, passing it the pointer and the additional 
          <var>arg</var> data pointer.

          <var>Proc2Call</var> can be a method or a static procedure.
</descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TListStaticCallback"/>
          <link id="TListCallback"/>
        </seealso>
      </element>
      <element name="TThreadList.Duplicates">
        <short>Describes what to do with duplicates</short>
        <descr>
          <var>Duplicates</var> describes what the threadlist should do when a duplicate pointer is added to the list.
It is identical in behaviour to the 
          <link id="TStringList.Duplicates">Duplicates</link> property of 
          <link id="TStringList"/>.
</descr>
        <seealso>
          <link id="TDuplicates"/>
        </seealso>
      </element>
      <element name="TInterfacedPersistent">
        <short>
          <var>TPersistent</var> descendent which implements the 
          <var>IInterface</var> interface</short>
        <descr>
          <var>TInterfacedPersistent</var> is a direct descendent of 
          <link id="TPersistent"/> which  implements 
the 
          <link id="#rtl.system.IInterface"/> interface. In particular, it implements the 
          <var>QueryInterface</var> 
as a public method.
</descr>
        <seealso>
          <link id="rtl.system.IInterface">IInterface</link>
        </seealso>
      </element>
      <element name="TInterfacedPersistent.QueryInterface">
        <short>Implementation of <var>IInterface.QueryInterface</var>
        </short>
        <descr>
          <var>QueryInterface</var> simply calls 
          <var>GetInterface</var> using the specified 
          <var>IID</var>, and returns the 
correct values.
</descr>
        <seealso>
          <link id="#rtl.system.tobject.GetInterface">TObject.GetInterface</link>
        </seealso>
      </element>
      <element name="TInterfacedPersistent.AfterConstruction">
        <short>Overrides the standard <var>AfterConstruction</var> method.</short>
        <descr>
          <var>AfterConstruction</var> is overridden to do some extra interface
housekeeping: a reference to the 
          <var>IInterface</var> interface of the owning class is obtained (if it exists).
</descr>
      </element>
      <element name="IStringsAdapter.ReferenceStrings">
        <short>Add a reference to the indicated strings.</short>
      </element>
      <element name="IStringsAdapter.ReleaseStrings">
        <short>Release the reference to the strings.</short>
      </element>
      <element name="IStreamPersist">
        <short>Persistence streaming interface.</short>
        <descr>
          <var>IStreamPersist</var> defines an interface for object persistence streaming to a stream.
Any class implementing this interface is expected to be able to save or load it's state from
or to a stream.
</descr>
        <seealso>
          <link id="TPersistent"/>
          <link id="TComponent"/>
          <link id="TStream"/>
        </seealso>
      </element>
      <element name="IStreamPersist.LoadFromStream">
        <short>Load persistent data from stream.</short>
        <descr>
          <var>LoadFromStream</var> is the method called when the object should load it's state from the stream 
          <var>stream</var>.
It should be able to read the data which was written using the 
          <var>SavetoStream</var> method.
</descr>
        <seealso>
          <link id="TPersistent"/>
          <link id="TComponent"/>
          <link id="TStream"/>
          <link id="IStreamPersist.SaveToStream"/>
        </seealso>
      </element>
      <element name="IStreamPersist.SaveToStream">
        <short>Save persistent data to stream.</short>
        <descr>
          <var>SaveFromStream</var> is the method called when the object should load it's state from the stream 
          <var>stream</var>.
The data written by this method should be readable by the 
          <var>LoadFromStream</var> method.
</descr>
        <seealso>
          <link id="TPersistent"/>
          <link id="TComponent"/>
          <link id="TStream"/>
          <link id="IStreamPersist.LoadFromStream"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.ReadCurrency">
        <short>Read a currency value from the stream.</short>
        <descr>
          <var>ReadCurrency</var> is called when a currency-typed value should be read from the stream.
This abstract method should be overidden by descendent classes, and should return the currency 
value read from the stream.
</descr>
        <seealso>
          <link id="TAbstractObjectWriter.WriteCurrency"/>
        </seealso>
      </element>
      <element name="TAbstractObjectReader.ReadWideString">
        <short>Read a widestring value from the stream.</short>
        <descr>
          <var>ReadWideString</var> is called when a widestring-typed value should be read from the stream.
This abstract method should be overidden by descendent classes.
</descr>
        <seealso>
          <link id="TAbstractObjectWriter.WriteWideString"/>
        </seealso>
      </element>
      <element name="TBinaryObjectReader.ReadCurrency">
        <short>Read a currency value from the stream.</short>
        <descr>
          <var>var&gt;ReadCurrency</var> reads a currency-typed value from a binary stream.
It is the implementation of the method introduced in 
          <link id="TAbstractObjectReader"/>.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadCurrency"/>
          <link id="TBinaryObjectWriter.WriteCurrency"/>
        </seealso>
      </element>
      <element name="TBinaryObjectReader.ReadWideString">
        <short>Read a widestring value from the stream.</short>
        <descr>
          <var>var&gt;ReadWideString</var> reads a widestring-typed value from a binary stream.
It is the implementation of the method introduced in 
          <link id="TAbstractObjectReader"/>.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadWideString"/>
          <link id="TBinaryObjectWriter.WriteWideString"/>
        </seealso>
      </element>
      <element name="TReader.ReadCurrency">
        <short>Read a currency value from the stream.</short>
        <descr>
          <var>ReadCurrency</var> reads a currency typed value from the stream and returns the result.
This method does nothing except call the driver method of the driver being used.
</descr>
        <seealso>
          <link id="TWriter.WriteCurrency"/>
        </seealso>
      </element>
      <element name="TReader.ReadWideString">
        <short>Read a WideString value from the stream.</short>
        <descr>
          <var>ReadWidestring</var> reads a widestring typed value from the stream and returns the result.
This method does nothing except call the driver method of the driver being used.
</descr>
        <seealso>
          <link id="TWriter.WriteWideString"/>
        </seealso>
      </element>
      <element name="TAbstractObjectWriter.WriteCurrency">
        <short>Write a currency value to the stream</short>
        <descr>
          <var>WriteCurrency</var> is called when a currency-typed value should be written to the stream.
This abstract method should be overidden by descendent classes.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadCurrency"/>
        </seealso>
      </element>
      <element name="TAbstractObjectWriter.WriteWideString">
        <short>Write a widestring value to the stream</short>
        <descr>
          <var>WriteCurrency</var> is called when a currency-typed value should be written to the stream.
This abstract method should be overidden by descendent classes.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadWideString"/>
        </seealso>
      </element>
      <element name="TBinaryObjectWriter.WriteCurrency">
        <short>Write a currency-valued type to a stream</short>
        <descr>
          <var>WriteCurrency</var> writes a currency-typed value to a binary stream.
It is the implementation of the method introduced in 
          <link id="TAbstractObjectWriter"/>.
</descr>
        <seealso>
          <link id="TAbstractObjectWriter.WriteCurrency"/>
        </seealso>
      </element>
      <element name="TBinaryObjectWriter.WriteWideString">
        <short>Write a widestring-valued type to a stream</short>
        <descr>
          <var>WriteWidestring</var> writes a widestring-typed value to a binary stream.
It is the implementation of the method introduced in 
          <link id="TAbstractObjectWriter"/>.
</descr>
        <seealso>
          <link id="TAbstractObjectWriter.WriteWidestring"/>
        </seealso>
      </element>
      <element name="TWriter.WriteCurrency">
        <short>Write a currency value to the stream</short>
        <descr>
          <var>WriteCurrency</var> writes a currency typed value to the stream.
This method does nothing except call the driver method of the driver being used.
</descr>
        <seealso>
          <link id="TReader.ReadCurrency"/>
        </seealso>
      </element>
      <element name="TWriter.WriteWideString">
        <short>Write a widestring value to the stream</short>
        <descr>
          <var>WriteWidestring</var> writes a currency typed value to the stream.
This method does nothing except call the driver method of the driver being used.
</descr>
        <seealso>
          <link id="TReader.ReadWideString"/>
        </seealso>
      </element>
      <element name="TComponentStyle.csSubComponent">
        <short>Subcomponent - streamed as part of the owning component</short>
      </element>
      <element name="TComponentStyle.csTransient">
        <short>Transient component</short>
      </element>
      <element name="IDesignerNotify">
        <short>Designer notification interface</short>
        <descr>
          <var>IDesignerNotify</var> is an interface that can be used to communicate
changes to a designer mechanism. It offers functionality for detecting changes, 
and notifications when the component is destroyed.
</descr>
        <seealso/>
      </element>
      <element name="IDesignerNotify.Modified">
        <short>Notify that the component is modified.</short>
        <descr>
          <var>Modified</var> can be used to notify a designer of changes, indicating that 
components should be streamed.
</descr>
      </element>
      <element name="IDesignerNotify.Notification">
        <short>Notification of owner changes </short>
        <descr>
          <var>Notification</var> is the interface counterpart of 
          <link id="TComponent.Notification"/>
which is used to communicate adds to the components.
</descr>
        <seealso>
          <link id="TComponent.Notification"/>
        </seealso>
      </element>
      <element name="IInterfaceList">
        <short>Interface for maintaining a list of interfaces.</short>
        <descr>
          <p>
            <var>IInterfaceList</var> is an interface for maintaining a list of
interfaces, strongly resembling the standard 
            <link id="TList"/> class.
It offers the same list of public methods as 
            <var>TList</var>, with 
the exception that it uses interfaces instead of pointers.
</p>
          <p>All interfaces in the list should descend from <var>IUnknown</var>.
</p>
          <p>More detailed descriptions of how the various methods behave can be found in the <var>TList</var> reference.
</p>
        </descr>
        <seealso>
          <link id="TList"/>
        </seealso>
      </element>
      <element name="IInterfaceList.Get">
        <short>Retrieve an interface pointer from the list.</short>
        <descr>
          <var>Get</var> returns the interface pointer at position 
          <var>i</var> in the list. 
It serves as the 
          <var>Read</var> method for the 

          <link id="IInterfaceList.Items">Items</link> property.
</descr>
        <seealso>
          <link id="IInterfaceList.Items"/>
          <link id="TList.Items"/>
        </seealso>
      </element>
      <element name="IInterfaceList.GetCapacity">
        <short>Return the capacity of the list.</short>
        <descr>
          <var>GetCapacity</var> returns the current capacity of the list.
It serves as the 
          <var>Read</var> method for the

          <link id="IInterfaceList.Capacity">Capacity</link> property.
</descr>
        <seealso>
          <link id="IInterfaceList.Capacity"/>
          <link id="TList.Capacity"/>
        </seealso>
      </element>
      <element name="IInterfaceList.GetCount">
        <short>Return the current number of elements in the list.</short>
        <descr>It serves as the <var>Read</var> method for the
<link id="IInterfaceList.Count">Count</link> property.
</descr>
        <seealso>
          <link id="IInterfaceList.Count"/>
          <link id="TList.Count"/>
        </seealso>
      </element>
      <element name="IInterfaceList.Put">
        <short>Write an item to the list</short>
        <descr>
          <var>Put</var> writes the interface 
          <var>Item</var> at position 
          <var>I</var> in the list.
It servers as the 
          <var>Write</var> method for the 
          <link id="IInterfaceList.Items">Items</link> 
property.
</descr>
        <seealso>
          <link id="IInterfaceList.Items"/>
          <link id="TList.Items"/>
        </seealso>
      </element>
      <element name="IInterfaceList.SetCapacity">
        <short>Set the capacity of the list</short>
        <descr>
          <var>SetCapacity</var> sets the capacity of the list to 
          <var>NewCapacity</var>. 
It serves as the 
          <var>Write</var> method for the 
          <link id="IInterfaceList.Capacity">Capacity</link>
property.
</descr>
        <seealso>
          <link id="IInterfaceList.Capacity"/>
          <link id="TList.Capacity"/>
        </seealso>
      </element>
      <element name="IInterfaceList.SetCount">
        <short>Set the number of items in the list</short>
        <descr>
          <var>SetCount</var> sets the count of the list to 
          <var>NewCount</var>.
It serves as the 
          <var>Write</var> method for the 
          <link id="IInterfaceList.Capacity">Capacity</link>
        </descr>
        <seealso>
          <link id="IInterfaceList.Count"/>
          <link id="TList.Count"/>
        </seealso>
      </element>
      <element name="IInterfaceList.Clear">
        <short>Clear the list</short>
        <descr>
          <var>Clear</var> removes all interfaces from the list. All interfaces in the list will be cleared
(i.e. their reference count will decrease with 1)
</descr>
        <seealso>
          <link id="TList.Clear"/>
        </seealso>
      </element>
      <element name="IInterfaceList.Delete">
        <short>Remove an interface from the list</short>
        <descr>
          <var>Delete</var> removes the interface at position 
          <var>Index</var> from the list.
It does this by explicitly clearing the interface and then removing the slot.
</descr>
        <seealso>
          <link id="TList.Clear"/>
          <link id="IInterfaceList.Add"/>
          <link id="IInterfaceList.Delete"/>
          <link id="IInterfaceList.Insert"/>
        </seealso>
      </element>
      <element name="IInterfaceList.Exchange">
        <short>Exchange 2 interfaces in the list</short>
        <descr>
          <var>Exchange</var> exchanges 2 interfaces in the list at locations 
          <var>index1</var> and 
          <var>Index2</var>.
</descr>
        <seealso>
          <link id="TList.Exchange"/>
          <link id="IInterfaceList.Add"/>
          <link id="IInterfaceList.Delete"/>
          <link id="IInterfaceList.Insert"/>
        </seealso>
      </element>
      <element name="IInterfaceList.First">
        <short>Return the first non-empty interface in the list.</short>
        <descr>
          <var>First</var> returns the first non-empty interface in the list.
</descr>
        <seealso>
          <link id="TList.First"/>
          <link id="IInterfaceList.IndexOf"/>
          <link id="IInterfaceList.Last"/>
        </seealso>
      </element>
      <element name="IInterfaceList.IndexOf">
        <short>Return the index of an interface.</short>
        <descr>
          <var>IndexOf</var> returns the location in the list of the interface 
          <var>Item</var>. 
If there is no such interface in the list, then -1 is returned.
</descr>
        <seealso>
          <link id="TList.IndexOf"/>
          <link id="IInterfaceList.First"/>
          <link id="IInterfaceList.Last"/>
        </seealso>
      </element>
      <element name="IInterfaceList.Add">
        <short>Add an interface to the list</short>
        <descr>
          <var>Add</var> adds the interface 
          <var>Item</var> to the list, 
and returns the position at which it has been added.
</descr>
        <seealso>
          <link id="TList.Add"/>
          <link id="IInterfaceList.Insert"/>
          <link id="IInterfaceList.Delete"/>
        </seealso>
      </element>
      <element name="IInterfaceList.Insert">
        <short>Insert an interface in the list.</short>
        <descr>
          <var>Insert</var> inserts the interface 
          <var>Item</var> in the list, at position 
          <var>I</var>, shifting all items one position.
</descr>
        <seealso>
          <link id="TList.Insert"/>
          <link id="IInterfaceList.Add"/>
          <link id="IInterfaceList.Delete"/>
        </seealso>
      </element>
      <element name="IInterfaceList.Last">
        <short>Returns the last non-nil interface in the list.</short>
        <descr>
          <var>Last</var> returns the last non-empty interface in the list.
</descr>
        <seealso>
          <link id="TList.Last"/>
          <link id="IInterfaceList.First"/>
          <link id="IInterfaceList.IndexOf"/>
        </seealso>
      </element>
      <element name="IInterfaceList.Remove">
        <short>Remove an interface from the list</short>
        <descr>
          <var>Remove</var> searches for the first occurrence of 
          <var>Item</var> in the list and deletes it.
</descr>
        <seealso>
          <link id="TList.Remove"/>
          <link id="IInterfaceList.Delete"/>
          <link id="IInterfaceList.IndexOf"/>
        </seealso>
      </element>
      <element name="IInterfaceList.Lock">
        <short>Lock the list</short>
        <descr>
          <var>Lock</var> locks the list. 
After a call to lock, the object list can only be accessed by the current
thread, untill 
          <link id="IInterfaceList.Unlock">UnLock</link> is called.
</descr>
        <seealso>
          <link id="TList.Lock"/>
          <link id="IInterfaceList.Unlock"/>
        </seealso>
      </element>
      <element name="IInterfaceList.Unlock">
        <short>Unlock the list.</short>
        <descr>
          <var>Unlock</var> unlocks a locked list. After a call to 
          <var>UnLock</var>,
other threads are again able to access the list.
</descr>
        <seealso>
          <link id="TList.UnLock"/>
          <link id="IInterfaceList.Lock"/>
        </seealso>
      </element>
      <element name="IInterfaceList.Capacity">
        <short>Capacity of the list</short>
        <descr>
          <var>Capacity</var> is the maximum number of elements the list can hold without needing to reallocate memory for the list.
It can be set to improve speed when adding a lot of items to the list.
</descr>
        <seealso>
          <link id="TList.Capacity"/>
          <link id="IInterfaceList.Count"/>
        </seealso>
      </element>
      <element name="IInterfaceList.Count">
        <short>Current number of elements in the list.</short>
        <descr>
          <var>Count</var> is the current number of elements in the list. Setting it to a larger number will allocate empty slots. 
Setting it to a smaller number will clear any interfaces that fall outside the new border.
</descr>
        <seealso>
          <link id="IInterfaceList.Capacity"/>
          <link id="TList.Count"/>
        </seealso>
      </element>
      <element name="IInterfaceList.Items">
        <short>Provides Index-based, sequential, access to the interfaces in the list.</short>
        <descr>
          <var>Items</var> is the default property of the interface list and provides index-based array access to the 
interfaces in the list. Allowed values for 
          <var>Index</var> include 0 to 
          <var>Count-1</var>
        </descr>
        <seealso>
          <link id="IInterfaceList.Count"/>
          <link id="TList.Items"/>
        </seealso>
      </element>
      <element name="TInterfaceList">
        <short>Standard implementation of the <link id="#rtl.classes.IInterfaceList">IInterfaceList</link> interface.</short>
        <descr>
          <p>
            <var>TInterfaceList</var> is a standard implementation of the 
            <link id="IInterfaceList"/> interface. It uses a 
            <link id="TThreadList"/> instance to
store the list of interfaces.
</p>
          <p/>
        </descr>
        <seealso>
          <link id="IInterfaceList"/>
          <link id="TList"/>
        </seealso>
      </element>
      <element name="TInterfaceList.Create">
        <short>Create a new instance of <var>TInterfaceList</var>
        </short>
        <descr>
          <var>Create</var> creates a new instance of the 
          <var>TInterfaceList</var>
class. It sets up the internal structures needed to store the list of
interfaces.
</descr>
        <seealso>
          <link id="TInterfaceList.Destroy">Destroy</link>
        </seealso>
      </element>
      <element name="TInterfaceList.Destroy">
        <short>Destroys the list of interfaces</short>
        <descr>
          <p>
            <var>Destroy</var> first calls 
            <link id="TInterfaceList.Clear">Clear</link>
and then frees the 
            <var>TInterfaceList</var> instance from memory.
</p>
          <p>Note that the <var>Clear</var> method decreases the reference count of all 
interfaces.
</p>
        </descr>
        <seealso>
          <link id="TInterfaceList.Create">Create</link>
          <link id="TInterfaceList.Clear">Clear</link>
        </seealso>
      </element>
      <element name="TInterfaceList.Clear">
        <short>Removes all interfaces from the list.</short>
        <descr>
          <var>Clear</var> is the implementation of the 
          <link id="IInterfaceList.Clear"/> method. 
It removes all interfaces from the list. It does this by
setting each element in the list to 
          <var>Nil</var>, in this way the
reference count of each interface in the list is descreased.
</descr>
        <seealso>
          <link id="IInterfaceList.Clear"/>
          <link id="TInterfaceList.Add">Add</link>
          <link id="TInterfaceList.Destroy">Destroy</link>
          <link id="TList.Clear"/>
          <link id="TFPList.Clear"/>
        </seealso>
      </element>
      <element name="TInterfaceList.Delete">
        <short>Delete an interface from the list.</short>
        <descr>
          <var>Delete</var> is the implementation of the 
          <link id="IInterfaceList.Delete"/> method. It clears the slot first and then removes
the element from the list.
</descr>
        <seealso>
          <link id="IInterfaceList.Delete"/>
          <link id="TInterfaceList.Remove"/>
          <link id="TInterfaceList.Add"/>
          <link id="TList.Delete"/>
          <link id="TFPList.Delete"/>
        </seealso>
      </element>
      <element name="TInterfaceList.Exchange">
        <short>Exchange 2 interfaces in the list</short>
        <descr>
          <var>Exchange</var> is the implementation of the 
          <link id="IInterfaceList.Exchange"/> method. It exchanges the position of 
2 interfaces in the list.
</descr>
        <seealso>
          <link id="IInterfaceList.Exchange"/>
          <link id="TInterfaceList.Delete"/>
          <link id="TInterfaceList.Add"/>
          <link id="TList.Exchange"/>
          <link id="TFPList.Exchange"/>
        </seealso>
      </element>
      <element name="TInterfaceList.First">
        <short>Returns the first non-<var>Nil</var> element in the list.</short>
        <descr>
          <var>First</var> is the implementation of the 
          <link id="IInterfaceList.First"/> method. It returns the first non-
          <var>Nil</var>
element from the list.
</descr>
        <seealso>
          <link id="IInterfaceList.First"/>
          <link id="TList.First"/>
        </seealso>
      </element>
      <element name="TInterfaceList.IndexOf">
        <short>Returns the index of an interface.</short>
        <descr>
          <var>IndexOf</var> is the implementation of the 
          <link id="IInterfaceList.IndexOf"/> method. It returns the zero-based index in the
list of the indicated interface, or -1 if the index is not in the list.
</descr>
        <seealso>
          <link id="IInterfaceList.IndexOf"/>
          <link id="TList.IndexOf"/>
        </seealso>
      </element>
      <element name="TInterfaceList.Add">
        <short>Add an interface to the list</short>
        <descr>
          <var>Add</var> is the implementation of the 
          <link id="IInterfaceList.Add"/> method. It
adds an interface to the list, and returns the location of the new element
in the list. This operation will increment the reference
count of the interface.
</descr>
        <seealso>
          <link id="IInterfaceList.Add"/>
          <link id="TInterfaceList.Delete"/>
          <link id="TInterfaceList.Insert"/>
          <link id="TList.Add"/>
          <link id="TFPList.Add"/>
        </seealso>
      </element>
      <element name="TInterfaceList.Insert">
        <short>Insert an interface to the list </short>
        <descr>
          <var>Insert</var> is the implementation of the 
          <link id="IInterfaceList.Insert"/> method. It inserts an 
interface in the list at the indicated position. 
This operation will increment the reference count of the interface.
</descr>
        <seealso>
          <link id="IInterfaceList.Insert"/>
          <link id="TInterfaceList.Delete"/>
          <link id="TInterfaceList.Add"/>
          <link id="TList.Insert"/>
          <link id="TFPList.Insert"/>
        </seealso>
      </element>
      <element name="TInterfaceList.Last">
        <short>Returns the last non-<var>Nil</var> element in the list.</short>
        <descr>
          <var>Last</var> is the implementation of the 
          <link id="IInterfaceList.Last"/> method. 
It returns the last non-
          <var>Nil</var> element from the list.
</descr>
        <seealso>
          <link id="IInterfaceList.Last"/>
          <link id="TInterfaceList.First"/>
          <link id="TList.Last"/>
          <link id="TFPList.Last"/>
        </seealso>
      </element>
      <element name="TInterfaceList.Remove">
        <short>Remove an interface from the list</short>
        <descr>
          <var>Remove</var> is the implementation of the 
          <link id="IInterfaceList.Remove"/> method. It removes the first occurrence of the
interface from the list.
</descr>
        <seealso>
          <link id="IInterfaceList.Remove"/>
          <link id="TInterfaceList.Delete"/>
          <link id="TInterfaceList.IndexOf"/>
          <link id="TList.Remove"/>
          <link id="TFList.Remove"/>
        </seealso>
      </element>
      <element name="TInterfaceList.Lock">
        <short>Lock the list</short>
        <descr>
          <var>Lock</var> locks the list. It is the implementation of the 
          <link id="IInterfaceList.Lock"/> method. It limits access to the list to the
current thread.
</descr>
        <seealso>
          <link id="IInterfaceList.Lock"/>
          <link id="TInterfaceList.UnLock"/>
          <link id="TThreadList.LockList"/>
        </seealso>
      </element>
      <element name="TInterfaceList.Unlock">
        <short>UnLocks a locked list</short>
        <descr>
          <var>UnLock</var> unlocks the list. It is the implementation of the 
          <link id="IInterfaceList.UnLock"/> method. After a call to unlock, the current
thread releases the list for manipulation by other threads.
</descr>
        <seealso>
          <link id="IInterfaceList.UnLock"/>
          <link id="TInterfaceList.Lock"/>
          <link id="TThreadList.UnLockList"/>
        </seealso>
      </element>
      <element name="TInterfaceList.Expand">
        <short>Expands the list</short>
        <descr>
          <var>Expand</var> calls the expand method from the internally used list. It returns itself.
</descr>
        <seealso>
          <link id="TList.Expand"/>
        </seealso>
      </element>
      <element name="TInterfaceList.Capacity">
        <short>The current capacity of the list.</short>
        <descr>
          <var>Capacity</var> is the number of elements that the list can contain
without needing to allocate more memory.
</descr>
        <seealso>
          <link id="IInterfaceList.Capacity"/>
          <link id="TInterfaceList.Count"/>
          <link id="TList.Capacity"/>
          <link id="TFPList.Capacity"/>
        </seealso>
      </element>
      <element name="TInterfaceList.Count">
        <short>The current number of elements in the list.</short>
        <descr>
          <var>Count</var> is the number of elements in the list. This can include

          <var>Nil</var> elements. Note that the elements are zero-based, and thus 
are indexed from 0 to 
          <var>Count-1</var>.
</descr>
        <seealso>
          <link id="IInterfaceList.Count"/>
          <link id="TInterfaceList.Items"/>
          <link id="TInterfaceList.Capacity"/>
          <link id="TList.Count"/>
          <link id="TFPList.Count"/>
        </seealso>
      </element>
      <element name="TInterfaceList.Items">
        <short>Array-based access to the list's items.</short>
        <descr>
          <var>Items</var> provides indexed access to the elements in the list. Note
that the elements are zero-based, and thus are indexed from 0 to

          <var>Count-1</var>. The items are read-write. It is not possible to add
elements to the list by accessing an element with index larger or equal to

          <link id="TInterfaceList.Count">Count</link>.
</descr>
        <seealso>
          <link id="IInterfaceList.Items"/>
          <link id="TInterfaceList.Count"/>
          <link id="TList.Items"/>
          <link id="TFPList.Items"/>
        </seealso>
      </element>
      <element name="PointsEqual">
        <short>Check whether two <var>TPoint</var> variables are equal.</short>
        <descr>
          <var>PointsEqual</var> compares the 
          <var>P1</var> and 
          <var>P2</var> points
(of type 
          <link id="TPoint"/> or 
          <link id="TSmallPoint"/>) and returns

          <var>True</var> if the 
          <var>X</var> and 
          <var>Y</var> coordinates of the 
points are equal, or 
          <var>False</var> otherwise.
</descr>
        <seealso>
          <link id="TPoint"/>
          <link id="TSmallPoint"/>
          <link id="InvalidPoint"/>
        </seealso>
      </element>
      <element name="InvalidPoint">
        <short>Check whether a point is invalid.</short>
        <descr>
          <var>InvalidPoint</var> returns 
          <var>True</var> if the 
          <var>X</var> and

          <var>Y</var> coordinates (of the 
          <var>TPoint</var> or 
          <var>TSmallPoint</var>
records, if one of these versions is used) are -1.
</descr>
        <seealso>
          <link id="TPoint"/>
          <link id="TSmallPoint"/>
          <link id="PointsEqual"/>
        </seealso>
      </element>
      <element name="GlobalNameSpace">
        <short>Global namespace</short>
        <descr>An interface protecting the global namespace. Used when reading/writing to
the global namespace list during streaming of forms.
</descr>
        <seealso/>
      </element>
      <element name="ExtractStrings">
        <short>Split a string in different words.</short>
        <descr>
          <var>ExtractStrings</var> splits 
          <var>Content</var> (a null-terminated string)
into words, and adds the words to the 
          <var>Strings</var> stringlist. The
words are separated by 
          <var>Separators</var> and any characters in

          <var>whitespace</var> are stripped from the strings. The space and CR/LF characters
are always considered whitespace.
</descr>
        <errors>No length checking is performed on <var>Content</var>. If no
null-termination character is present, an access violation may occur.
Likewise, if <var>Strings</var> is not valid, an access violation may occur.
</errors>
        <seealso/>
      </element>
      <element name="TAbstractObjectReader.Read">
        <short>Read raw data from stream</short>
        <descr>
          <var>Read</var> is introduced for Delphi compatibility to read raw data
from the component stream. This should not be used in production code as
it will totally mess up the streaming.
</descr>
        <seealso>
          <link id="TBinaryObjectReader.Read"/>
          <link id="TReader.Read"/>
        </seealso>
      </element>
      <element name="TBinaryObjectReader.Read">
        <short>Read raw data from stream</short>
        <descr>
          <var>Read</var> is introduced for Delphi compatibility to read raw data
from the component stream. This should not be used in production code as
it will totally mess up the streaming.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.Read"/>
          <link id="TReader.Read"/>
        </seealso>
      </element>
      <element name="TReader.Read">
        <short>Read raw data from stream</short>
        <descr>
          <var>Read</var> is introduced for Delphi compatibility to read raw data
from the component stream. This should not be used in new production code 
as it will totally mess up the streaming.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.Read"/>
          <link id="TBinaryObjectReader.Read"/>
        </seealso>
      </element>
      <element name="TReader.ReadWideChar">
        <short>Read widechar from the stream</short>
        <descr>
          <var>TReader.ReadWideChar</var> reads a widechar from the stream. This
actually reads a widestring and returns the first character.
</descr>
        <seealso>
          <link id="TReader.ReadWideString"/>
          <link id="TWriter.WriteWideChar"/>
        </seealso>
      </element>
      <element name="TAbstractObjectWriter.Write">
        <short>Write raw data to stream</short>
        <descr>
          <var>Write</var> is introduced for Delphi compatibility to write raw data
to the component stream. This should not be used in new production code
as it will totally mess up the streaming.
</descr>
        <seealso>
          <link id="TBinaryObjectWriter.Write"/>
          <link id="TWriter.Write"/>
        </seealso>
      </element>
      <element name="TBinaryObjectWriter.Write">
        <short>Write raw data to stream</short>
        <descr>
          <var>Write</var> is introduced for Delphi compatibility to write raw data
to the component stream. This should not be used in new production code
as it will totally mess up the streaming.
</descr>
        <seealso>
          <link id="TAbstractObjectWriter.Write"/>
          <link id="TWriter.Write"/>
        </seealso>
      </element>
      <element name="TWriter.Write">
        <short>Write raw data to stream</short>
        <descr>
          <var>Write</var> is introduced for Delphi compatibility to write raw data
to the component stream. This should not be used in new production code
as it will totally mess up the streaming.
</descr>
        <seealso>
          <link id="TBinaryObjectWriter.Write"/>
          <link id="TAbstractObjectWriter.Write"/>
        </seealso>
      </element>
      <element name="TWriter.WriteWideChar">
        <short>Write widechar to stream</short>
        <descr>
          <var>WriteWideChar</var> writes a widechar to the stream. This
actually writes a widestring of length 1.
</descr>
        <seealso>
          <link id="TReader.ReadWideChar"/>
          <link id="TWriter.WriteWideString"/>
        </seealso>
      </element>
      <element name="TThread.AfterConstruction">
        <short>Code to be executed after construction but before execute.</short>
        <descr>
          <var>AfterConstruction</var> is overridden in 
          <var>TThread</var> but
currently does not do anything useful.
</descr>
      </element>
      <element name="TListAssignOp">
        <short>List assign operation</short>
        <descr>This type determines what operation <link id="TList.Assign"/> or <link id="TFPList.assign"/> performs.
</descr>
        <seealso>
          <link id="TList.Assign"/>
          <link id="TFPList.assign"/>
        </seealso>
      </element>
      <element name="TListAssignOp.laCopy">
        <short>Clear list and copy all strings from second list.</short>
      </element>
      <element name="TListAssignOp.laAnd">
        <short>Remove all elements not first second list </short>
      </element>
      <element name="TListAssignOp.laOr">
        <short>Add all elements from second (and optional third) list, eliminate duplicates</short>
      </element>
      <element name="TListAssignOp.laXor">
        <short>Remove elements in second lists, Add all elements from second list not in first list</short>
      </element>
      <element name="TListAssignOp.laSrcUnique">
        <short>Just keep all elements that exist only in source list</short>
      </element>
      <element name="TListAssignOp.laDestUnique">
        <short>Keep all elements that exists only in list2</short>
      </element>
      <element name="TFPList.AddList">
        <short>Add all pointers from another list</short>
        <descr>
          <var>AddList</var> adds all pointers from 
          <var>AList</var> to the list.
If a pointer is already present, it is added a second time.
</descr>
        <seealso>
          <link id="TFPList.Assign"/>
          <link id="TList.AddList"/>
        </seealso>
      </element>
      <element name="TList.AddList">
        <short>Add all pointers from another list</short>
        <descr>
          <var>AddList</var> adds all pointers from 
          <var>AList</var> to the list.
If a pointer is already present, it is added a second time.
</descr>
        <seealso>
          <link id="TList.Assign"/>
          <link id="TFPList.AddList"/>
        </seealso>
      </element>
      <element name="TStrings.ExtractName">
        <short>Returns the name part of an name-value pair string.</short>
        <descr>
          <var>ExtractName</var> returns the name part (the part before the 
          <link id="TStrings.NameValueSeparator">NameValueSeparator</link> character) of the
string. If the character is not present, an empty string is returned. The
resulting string is not trimmed, it can end or start with spaces.</descr>
        <seealso>
          <link id="TStrings.NameValueSeparator">NameValueSeparator</link>
        </seealso>
      </element>
      <element name="TStrings.TextLineBreakStyle">
        <short>Determines which line breaks to use in the <link id="#rtl.classes.TStrings.Text">Text</link> property</short>
        <descr>
          <p>
            <var>TextLineBreakStyle</var> determines which linebreak style is used when
constructing the Text property: the same rules are used as in the writing to
text files:
</p>
          <dl>
            <dt>tlbsLF</dt>
            <dd>Lines are separated with a linefeed character #10.</dd>
            <dt>tlbsCRLF</dt>
            <dd>Lines are separated with a carriage-return/linefeed character
pair: #13#10.</dd>
            <dt>tlbsCR</dt>
            <dd>Lines are separated with a carriage-return character #13.</dd>
          </dl>
          <p>It has no effect when setting the text property.
</p>
        </descr>
        <seealso>
          <link id="#rtl.classes.TStrings.Text">Text</link>
        </seealso>
      </element>
      <element name="TStreamOwnership">
        <short>Determines the ownership of a TStreamAdapter</short>
        <descr>The ownership of a streamadapter determines what happens with the stream
on which a <link id="TStreamAdapter"/> acts, when the adapter is freed.
</descr>
        <seealso>
          <link id="TStreamAdapter"/>
          <link id="IStream"/>
        </seealso>
      </element>
      <element name="TStreamOwnership.soReference">
        <short>Stream is referenced only, it is not freed by the adapter</short>
      </element>
      <element name="TStreamOwnership.soOwned">
        <short>Stream is owned: it will be freed when the adapter is freed.</short>
      </element>
      <element name="TStreamAdapter">
        <short>Implements IStream for <link id="#rtl.classes.TSTream">TStream</link> descendents</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TStreamAdapter.Create">
        <short>Create a new instance of <var>TStreamAdapter</var>
        </short>
        <descr>
          <p>
            <var>Create</var> creates a new instance of 
            <var>TStreamAdaptor</var>. It
initializes 
            <link id="TStreamAdapter.Stream"/> with 
            <var>Stream</var> and initializes 
            <link id="TStreamAdapter.StreamOwnerShip">StreamOwnerShip</link> with

            <var>Ownership</var>.
</p>
          <p>
            <var>TStreamAdapter</var> is an abstract class: descendents must be created
that implement the actual functionality.
</p>
        </descr>
        <errors/>
        <seealso>
          <link id="TStreamAdapter.StreamOwnerShip">StreamOwnerShip</link>
          <link id="TStreamAdapter.Stream"/>
        </seealso>
      </element>
      <element name="TStreamAdapter.Destroy">
        <short>Free the <var>TStreamAdapter</var> instance</short>
        <descr>Explicitly free the <var>TStreamAdapter</var> instance. Normally, this is
done automatically if a reference to the <var>IStream</var> interface is freed.
</descr>
      </element>
      <element name="TStreamAdapter.Read">
        <short>Read from the stream.</short>
        <descr>
          <var>Read</var> implements 
          <link id="IStream.Read"/> by reading from the stream
specified at creation.
</descr>
        <errors>This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
        <seealso>
          <link id="IStream.Read"/>
        </seealso>
      </element>
      <element name="TStreamAdapter.Write">
        <short>Write to the stream</short>
        <descr>
          <var>Write</var> implements 
          <link id="IStream.Write"/> by writing to the
stream specified at creation.
</descr>
        <errors>This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
        <seealso>
          <link id="IStream.Write"/>
        </seealso>
      </element>
      <element name="TStreamAdapter.Seek">
        <short>Set the stream position</short>
        <descr>
          <var>Seek</var> implements 
          <link id="IStream.Seek"/> by setting the
position of the stream specified at creation.
</descr>
        <errors>This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
        <seealso>
          <link id="IStream.Seek"/>
        </seealso>
      </element>
      <element name="TStreamAdapter.SetSize">
        <short>Set the stream size</short>
        <descr>
          <var>SetSize</var> implements 
          <link id="IStream.Setsize"/> by setting the
size of the stream specified at creation.
</descr>
        <errors>This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
        <seealso>
          <link id="IStream.Setsize"/>
        </seealso>
      </element>
      <element name="TStreamAdapter.CopyTo">
        <short>Copy data to destination stream</short>
        <descr>
          <var>CopyTo</var> implements 
          <link id="IStream.CopyTo"/>.
</descr>
        <errors>This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
        <seealso/>
      </element>
      <element name="TStreamAdapter.Commit">
        <short>Commit data to the stream</short>
        <descr>
          <var>Commit</var> implements 
          <link id="IStream.Commit"/>.
</descr>
        <errors>This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
        <seealso>
          <link id="IStream.Commit"/>
        </seealso>
      </element>
      <element name="TStreamAdapter.Revert">
        <short>Revert operations on the stream</short>
        <descr>
          <var>Revert</var> implements 
          <link id="IStream.Revert"/>.
</descr>
        <errors>This function must be overridden and will raise a runerror 217 when called
directly.
</errors>
        <seealso>
          <link id="IStream.Revert"/>
        </seealso>
      </element>
      <element name="TStreamAdapter.LockRegion">
        <short>Lock a region of the stream</short>
        <descr>
          <var>LockRegion</var> implements 
          <link id="IStream.LockRegion"/>.
</descr>
        <errors>This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
        <seealso>
          <link id="IStream.LockRegion"/>
        </seealso>
      </element>
      <element name="TStreamAdapter.UnlockRegion">
        <short>Unlock a region of the stream</short>
        <descr>
          <var>UnLockRegion</var> implements 
          <link id="IStream.UnLockRegion"/>.
</descr>
        <errors>This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
        <seealso>
          <link id="IStream.UnLockRegion"/>
        </seealso>
      </element>
      <element name="TStreamAdapter.Stat">
        <short>Return statistical data about the stream</short>
        <descr>
          <var>Stat</var> implements 
          <link id="IStream.Stat"/>.
</descr>
        <errors>This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
        <seealso>
          <link id="IStream.Stat"/>
        </seealso>
      </element>
      <element name="TStreamAdapter.Clone">
        <short>Clone the stream</short>
        <descr>
          <var>Clone</var> implements 
          <link id="IStream.Clone"/>.
</descr>
        <errors>This function  must be overridden and will raise a runerror 217 when called
directly.
</errors>
        <seealso>
          <link id="IStream.Clone"/>
        </seealso>
      </element>
      <element name="TStreamAdapter.Stream">
        <short>Stream on which adaptor works</short>
        <descr>This is the stream on which the adaptor works. It was specified at
rreation.
</descr>
      </element>
      <element name="TStreamAdapter.StreamOwnership">
        <short>Determines what happens with the stream when the adaptor is freed</short>
        <descr>
          <var>StreamOwnership</var> determines what happens when the adaptor
</descr>
        <seealso/>
      </element>
      <element name="TWriter.PropertyPath">
        <short>Path to the property that is currently being written</short>
        <descr>
          <var>PropertyPath</var> is set to the property name of the class currently
being written to stream. This is only done when 
          <link id="TPersistent"/>
descendent class properties are written.
</descr>
        <seealso/>
      </element>
      <element name="IInterfaceComponentReference">
        <short>Interface for checking component references</short>
        <descr>
          <var>IInterfaceComponentReference</var> is an interface to return the
component that implements a given interface. 
It is implemented by 
          <link id="TComponent"/>.
</descr>
        <seealso>
          <link id="TComponent"/>.
</seealso>
      </element>
      <element name="IInterfaceComponentReference.GetComponent">
        <short>Return component instance</short>
        <descr>
          <var>GetComponent</var> returns the component instance.
</descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TComponent"/>
        </seealso>
      </element>
      <element name="TComponent.IsImplementorOf">
        <short>Checks if the current component is the implementor of the interface</short>
        <descr>
          <var>IsImplementorOf</var> returns 
          <var>True</var> if the current component
implements the given interface. The interface should descend from

          <link id="IInterfaceComponentReference"/> and the 
          <var>GetComponent</var>
method should return the current instance.
</descr>
        <seealso>
          <link id="IInterfaceComponentReference"/>
        </seealso>
      </element>
      <element name="TComponent.ReferenceInterface">
        <short>Interface implementation of Notification</short>
        <descr>
          <var>ReferenceInterface</var> can be used to notify an interface of
a component operation: it is the equivalent of the 
          <link id="TComponent.Notification"/> method of 
          <var>TComponent</var> for
interfaces. If the interface implements 
          <link id="IInterfaceComponentReference"/>, then the component that implements the
interface is notified of the given operation 
          <var>Op</var>.
</descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TComponent.Notification"/>
          <link id="IInterfaceComponentReference"/>
        </seealso>
      </element>
      <element name="FindIntToIdent">
        <short>Return the integer to string converter for an integer type</short>
        <descr>
          <var>FindIntToIdent</var> returns the handler that handles the conversion of
an integer to a string representation that can be used in component
streaming, when 
          <link id="IntToIdent"/> is called.
</descr>
        <errors>Nil is returned if no handler is registered for the given type.
</errors>
        <seealso>
          <link id="IntToIdent"/>
          <link id="TIntToIdent"/>
          <link id="FindIdentToInt"/>
        </seealso>
      </element>
      <element name="FindIdentToInt">
        <short>Return the string to integer converter for an integer type</short>
        <descr>
          <var>FindIdentToInt</var> returns the handler that handles the conversion of
a string representation to an integer that can be used in component
streaming, when 
          <link id="IdentToInt"/> is called.
</descr>
        <errors>Nil is returned if no handler is registered for the given type.
</errors>
        <seealso/>
      </element>
      <element name="TCollectionSortCompare">
        <short>Callback to sort collection items</short>
        <descr>
          <p>
            <var>TCollectionSortCompare</var> is the prototype for a callback used in
the 
            <link id="TCollection.Sort"/> method. The procedure should compare

            <var>Item1</var> and 
            <var>Item2</var> and return an integer:
</p>
          <dl>
            <dt>Result &lt; 0</dt>
            <dd>if <var>Item1</var> comes before <var>Item2</var>
            </dd>
            <dt>Result = 0</dt>
            <dd>if <var>Item1</var> is at the same level as <var>Item2</var>
            </dd>
            <dt>Result &gt; 0</dt>
            <dd>if <var>Item1</var> comes after <var>Item2</var>
            </dd>
          </dl>
        </descr>
        <seealso>
          <link id="TCollection.Sort"/>
        </seealso>
      </element>
      <element name="TCollection.Sort">
        <short>Sort the items in the collection</short>
        <descr>
          <p>
            <var>Sort</var> sorts the items in the collection, and uses the 
            <var>Compare</var>
procedure to compare 2 items in the collection. It is more efficient do use
this method than to perform the sort manually, because the list items are
manipulated directly.
</p>
          <p>For more information on how the <var>Compare</var> function should behave,
see the <link id="TCollectionSortCompare"/> type.
</p>
        </descr>
        <seealso>
          <link id="TCollectionSortCompare"/>
        </seealso>
      </element>
      <element name="TStrings.StrictDelimiter">
        <short>Should only the delimiter character be considered a field delimiter?</short>
        <descr>If <var>True</var>, only the specificed <link id="TStrings.Delimiter">Delimiter</link> character is treated as field delimiter.

If <var>False</var> (default), special characters (like spaces) also are treated as field delimiters.

<var>StrictDelimiter</var> can be used to indicate that only the delimiter
character should be considered a delimiter when setting <link id="TStrings.DelimitedText">DelimitedText</link>;
under normal circumstances, quotes and spaces are considered specially (see the <link id="TStrings.DelimitedText"/>
property for more information). 
When <var>StrictDelimiter</var> is set to <var>True</var> then only the <link id="TStrings.Delimiter">Delimiter</link>
character is considered when splitting the text in items.</descr>
        <seealso>
          <link id="TStrings.DelimitedText">DelimitedText</link>
          <link id="TStrings.CommaText">CommaText</link>
          <link id="TStrings.Delimiter">Delimiter</link>
        </seealso>
      </element>
      <element name="TValueType.vaUString">
        <short>UnicodeString value</short>
      </element>
      <element name="TValueType.vaQWord">
        <short>QWord (64-bit word) value</short>
      </element>
      <element name="TAbstractObjectReader.ReadUnicodeString">
        <short>Read a unicode string value</short>
        <descr>
          <p>
            <var>ReadUnicodeString</var> should read a UnicodeString value from the
stream. (indicated by the 
            <var>vaUString</var> value type).
</p>
          <p>Descendent classes should override this method to actually read a
UnicodeString value.
</p>
        </descr>
        <seealso>
          <link id="TBinaryObjectWriter.WriteUnicodeString"/>
          <link id="TAbstractObjectReader.ReadWideString"/>
        </seealso>
      </element>
      <element name="TBinaryObjectReader.ReadUnicodeString">
        <short>Read a unicode string value</short>
        <descr>
          <var>ReadUnicodeString</var> is overridden by 
          <var>TBinaryObjectReader</var>to 
read a UnicodeString value from the binary stream.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadUnicodeString"/>
        </seealso>
      </element>
      <element name="TReader.ReadUnicodeChar">
        <short>Read unicode character</short>
        <descr>
          <var>ReadUnicodeChar</var> reads a single unicode character from the stream.
It does this by reading a 
          <var>UnicodeString</var> string from the stream
and returning the first character.
</descr>
        <errors>If the string has a length different from 1, an <var>EReadError</var>
exception will occur.
</errors>
        <seealso>
          <link id="TReader.ReadUnicodeString"/>
        </seealso>
      </element>
      <element name="TReader.ReadVariant">
        <short>Read a variant from the stream</short>
        <descr>
          <var>ReadVariant</var> reads the next value from the stream and returns it
as a variant. No variant array can be read from the stream, only single
values.
</descr>
        <errors>If no variant manager is installed, the function will raise an
<var>EReadError</var> exception. If the next value is not a simple 
value, again an  <var>EReadError</var> exception is raised.
exception is 
</errors>
        <seealso>
          <link id="TBinaryObjectWriter.WriteVariant"/>
        </seealso>
      </element>
      <element name="TReader.ReadUnicodeString">
        <short>Read a UnicodeString value from the stream</short>
        <descr>
          <var>ReadUnicodeString</var> reads a 
          <var>UnicodeString</var> string from
the stream. The stream can contain a string from any type, it will be
converted to UniCodeString.
</descr>
        <seealso>
          <link id="TAbstractObjectReader.ReadUnicodeString"/>
          <link id="TWriter.WriteUnicodeString"/>
        </seealso>
      </element>
      <element name="TAbstractObjectWriter.WriteUInt64">
        <short>Write an unsigned 64-bit integer</short>
        <descr>
          <var>WriteUInt64</var> must be overridden by descendent classes to write
a 64-bit unsigned 
          <var>Value</var> (valuetype 
          <var>vaQWord</var>) to the stream.
</descr>
        <errors>None.
</errors>
        <seealso>
          <link id="TBinaryObjectWriter.WriteUInt64"/>
        </seealso>
      </element>
      <element name="TAbstractObjectWriter.WriteVariant">
        <short>Write a variant to the stream</short>
        <descr>
          <var>WriteVariant</var> must be overridden by descendent classes to write a
simple variant type to the stream. 
          <var>WriteVariant</var> does not write
arrays types or complex types.
</descr>
        <seealso>
          <link id="TBinaryObjectWriter.WriteVariant"/>
        </seealso>
      </element>
      <element name="TAbstractObjectWriter.WriteUnicodeString">
        <short>Write a unicode string to the stream.</short>
        <descr>
          <var>WriteUnicodeString</var> must be overridden by descendent classes to
write a unicodestring (valuetype 
          <var>vaUString</var>) value to the stream. 
</descr>
        <seealso>
          <link id="TBinaryObjectWriter.WriteUnicodeString"/>
        </seealso>
      </element>
      <element name="TBinaryObjectWriter.WriteUInt64">
        <short>Write an unsigned 64-bit integer</short>
        <descr>
          <var>WriteUInt64</var> is overridden by 
          <var>TBinaryObjectWriter</var> to write 
an unsigned 64-bit integer (QWord) to the stream. It tries to use the smallest 
possible storage for the value that is passed. 
(largest valuetype will be 
          <var>vaQWord</var>). 
</descr>
        <seealso>
          <link id="TAbstractObjectWriter.WriteUInt64"/>
        </seealso>
      </element>
      <element name="TBinaryObjectWriter.WriteUnicodeString">
        <short>Write a unicode string to the stream.</short>
        <descr>
          <var>WriteUnicodeString</var> is overridden 
          <var>TBinaryObjectWriter</var>
to write a unicodestring (valuetype 
          <var>vaUString</var>) value to the stream.
It simply writes the character length and then all widecharacters.
</descr>
        <seealso>
          <link id="TAbstractObjectWriter.WriteUnicodeString"/>
        </seealso>
      </element>
      <element name="TBinaryObjectWriter.WriteVariant">
        <short>Write a variant to the stream</short>
        <descr>
          <var>WriteVariant</var> is overridden by 
          <var>TBinaryObjectWriter</var> to write a
simple variant type to the stream. 
          <var>WriteVariant</var> does not write
arrays types or complex types. Only null, integer (ordinal) float and string types are
written.
</descr>
        <errors>If a non-supported type is written, then an <var>EWriteError</var> exception is.
</errors>
      </element>
      <element name="TWriter.WriteUnicodeString">
        <short>Write a unicode string to the stream.</short>
        <descr>
          <var>WriteUnicodeString</var> writes 
          <var>Value</var>, a UnicodeString string to the
stream.  It simply passes the string on to the 
          <var>WriteUnicodeString</var>
method of the writer driver class.
</descr>
        <seealso>
          <link id="TBinaryObjectWriter.WriteUnicodeString"/>
          <link id="TReader.ReadUnicodeString"/>
        </seealso>
      </element>
      <element name="TWriter.WriteVariant">
        <short>Write a variant to the stream</short>
        <descr>
          <var>WriteVariant</var> writes 
          <var>Value</var>, a simple variant, o the
stream.  It simply passes the string on to the 
          <var>WriteVariant</var>
method of the writer driver class.
</descr>
        <seealso>
          <link id="TBinaryObjectWriter.WriteVariant"/>
          <link id="TReader.ReadVariant"/>
        </seealso>
      </element>
      <element name="TStrings.DoCompareText">
        <short>Compares two strings.</short>
        <descr>This method is used in sorting and searching the string list.

The default implementation does an case insensitive comparison of ASCII strings. Override for other string encodings.</descr>
      </element>
      <element name="Tstrings.CheckSpecialChars">
        <short>Assures that the special characters are specified, which are used to e.g. split strings.</short>
      </element>
      <topic name="Save and Load TStrings">
        <short>How stringlists are saved and loaded</short>
        <descr>A TStrings object holds a couple of strings and (optional) associated objects. The strings can be accessed by index (<link id="TStrings.Strings"/>) or as a single string (<link id="TStrings.Text"/>).

Typical implementations hold the strings in an array, and construct the Text string from that array on the fly, concatenating the strings separated by newline markers.

When a stringlist is stored in an file or stream, the Text string is constructed and written. The resulting file can e.g. be loaded into an text editor, where every string of the list will occur as a distinct line. Likewise a textfile can be loaded into a stringlist, with every line in the file placed into an distinct entry.

These methods can be used to store and load the strings of a stringlist at once:
<ul>
            <li>File: <link id="TStrings.SaveToFile"/><link id="TStrings.LoadFromFile"/>
            </li>
            <li>Stream: <link id="TStrings.SaveToStream"/><link id="TStrings.LoadFromStream"/>
            </li>
            <li>String: <link id="TStrings.Text"/><link id="TStrings.GetTextString"/><link id="TStrings.SetTextString"/>
            </li>
          </ul>

Please note that the associated <link id="TStrings.Objects">Objects</link> can not be saved or reloaded by any standard method.

There exist more TStrings methods to split or concatenate strings. A common file format is "Comma Separated Values" (CSV), where the string fields are separated by commas. When a string contains commas or spaces, it must be enclosed in double quotes. Strings formatted in this way can be split into the string fields by loading the string into the <link id="TStrings.CommaText">CommaText</link> property of a stringlist, where every field can be accessed by its index. Reading the CommaText property results in an string of the same format. Apart from the commas, used to separate the strings, the result looks much like the Text string of the stringlist.

But other string delimiters can be used, too, by reading or writing to the <link id="TStrings.DelimitedText"/> property, which uses the <link id="TStrings.Delimiter"/> character to separate the string fields. When spaces shall not act as additional delimiters, <link id="TStrings.StrictDelimiter"/> should be set to True.

CSV files (or similar formats) can be loaded into a stringlist, using LoadFromFile, and then every string in this list can be loaded into the CommaText (or DelimitedText) property of another stringlist, where the fields are accessible by index. The creation of CSV files can be performed in essentially the same way, using the beforementioned standard methods and properties.

Last not least stringlists can be used as dictionaries, where every entry consists of an key and an value string, separated by "=" or by an specified <link id="TStrings.NameValueSeparator"/>. The value strings then are accessible by Values[name]. The standard methods can be used to save and load entire dictionaries in one go.</descr>
      </topic>
      <element name="TStrings.GetDelimitedText">
        <short>Return the list contents as a delimited string.</short>
        <errors>Currently StrictDelimiter usage prevents quoting at all :-(</errors>
        <seealso>
          <link id="TStrings.DelimitedText"/>
        </seealso>
      </element>
      <short>Basic classes for RTL</short>
      <descr>
        <p>This documentation describes the FPC <file>classes</file> unit. 
The <file>Classes</file> unit contains basic classes for the Free Component
Library (FCL):
</p>
        <ul>
          <li>a <link id="TList"/> class for maintaining lists of pointers, </li>
          <li>
            <link id="TStringList"/> for lists of strings, </li>
          <li>
            <link id="TCollection"/> to manage collections of objects </li>
          <li>
            <link id="TStream"/> classes to support streaming.</li>
        </ul>
        <p>Furthermore it introduces methods for object persistence, and classes
that understand a client-owner relationship, with automatic memory 
management.
</p>
      </descr>
    </module>
  </package>
</fpdoc-descriptions>
